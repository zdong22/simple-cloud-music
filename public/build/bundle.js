
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind$1(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.46.4' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    var LoadableEntryAction;
    (function (LoadableEntryAction) {
        LoadableEntryAction[LoadableEntryAction["NoOp"] = 0] = "NoOp";
        LoadableEntryAction[LoadableEntryAction["New"] = 1] = "New";
        LoadableEntryAction[LoadableEntryAction["Resume"] = 2] = "Resume";
    })(LoadableEntryAction || (LoadableEntryAction = {}));
    var UnloadableEntryAction;
    (function (UnloadableEntryAction) {
        UnloadableEntryAction[UnloadableEntryAction["NoOp"] = 0] = "NoOp";
        UnloadableEntryAction[UnloadableEntryAction["Destroy"] = 1] = "Destroy";
        UnloadableEntryAction[UnloadableEntryAction["Pause"] = 2] = "Pause";
    })(UnloadableEntryAction || (UnloadableEntryAction = {}));
    var NavigationType;
    (function (NavigationType) {
        NavigationType[NavigationType["GoForwardNewState"] = 0] = "GoForwardNewState";
        NavigationType[NavigationType["GoForwardResumeState"] = 1] = "GoForwardResumeState";
        NavigationType[NavigationType["GoBackward"] = 2] = "GoBackward";
        NavigationType[NavigationType["Replace"] = 3] = "Replace";
    })(NavigationType || (NavigationType = {}));
    var StackRouterEventType;
    (function (StackRouterEventType) {
        StackRouterEventType[StackRouterEventType["Navigate"] = 0] = "Navigate";
        StackRouterEventType[StackRouterEventType["Mount"] = 1] = "Mount";
        StackRouterEventType[StackRouterEventType["Destroy"] = 2] = "Destroy";
        StackRouterEventType[StackRouterEventType["UpdateConfig"] = 3] = "UpdateConfig";
    })(StackRouterEventType || (StackRouterEventType = {}));

    function animationFrame() {
        return new Promise((res) => requestAnimationFrame(() => res()));
    }
    function sleep(ms) {
        return new Promise((res) => setTimeout(() => res(), ms));
    }
    function dispatchCustomEvent(element, eventName) {
        element.dispatchEvent(new CustomEvent(eventName, {
            bubbles: true,
            cancelable: true,
        }));
    }

    /* eslint-disable no-restricted-properties */
    function makeStyleTag(content) {
        const styleTag = document.createElement('style');
        styleTag.innerHTML = content;
        return styleTag;
    }
    function commonTransitionGenerator(duration, styleGenerators) {
        return async (transitionFunctionData) => {
            const timestamp = new Date().getTime();
            const unloadClass = `unload-${timestamp}`;
            const loadClass = `load-${timestamp}`;
            const routerClass = `router-${timestamp}`;
            const { mountPointToUnload, mountPointToLoad, scroll, routerMountPoint, } = transitionFunctionData;
            mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.classList.add(unloadClass);
            mountPointToLoad.classList.add(loadClass);
            routerMountPoint.classList.add(routerClass);
            const styleNodes = new Array(styleGenerators.length);
            for (let i = 0; i < styleGenerators.length; i++) {
                const styleNode = styleGenerators[i](loadClass, unloadClass, routerClass, transitionFunctionData);
                styleNodes[i] = styleNode;
                document.head.appendChild(styleNode);
                await animationFrame();
                await animationFrame();
                await animationFrame();
            }
            let preventAutoScroll = false;
            const scrollListener = () => { preventAutoScroll = true; };
            window.addEventListener('scroll', scrollListener);
            await sleep(duration);
            window.removeEventListener('scroll', scrollListener);
            if (!preventAutoScroll) {
                window.scrollTo(scroll.x, scroll.y);
                if (window.getComputedStyle(document.documentElement).scrollBehavior === 'smooth') {
                    // At the moment of writing this comment there is no official/simple way to wait for the
                    // window.scrollTo method to complete the animation
                    // Hack: loop for a maximum of 500ms checking if the scroll position is close enough to the target scroll
                    const threshold = 5;
                    for (let i = 0; i < 50; i++) {
                        if (Math.sqrt(Math.pow(window.scrollX - scroll.x, 2)
                            + Math.pow(window.scrollY - scroll.y, 2)) < threshold) {
                            break;
                        }
                        await sleep(10);
                    }
                }
            }
            for (const styleNode of styleNodes) {
                document.head.removeChild(styleNode);
            }
            mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.classList.remove(unloadClass);
            mountPointToLoad.classList.remove(loadClass);
            routerMountPoint.classList.remove(routerClass);
        };
    }
    function slide(duration) {
        return commonTransitionGenerator(duration, [
            (loadClass, unloadClass, routerClass, { navigationType, }) => makeStyleTag(`
				html {
					scroll-behavior: smooth;
				}
				.${loadClass} {
					position: absolute;
					z-index: 2;
					left: 0;
					top: 0;
					right: 0;
					opacity: 0;
					transform: translateX(${navigationType === NavigationType.GoBackward ? '-' : ''}50%);
				}
				.${unloadClass} {
					position: relative;
					z-index: 1;
					opacity: 1;
					transform: translateX(0%);
				}
				.${routerClass} {
					position: relative;
					overflow: hidden;
				}
			`),
            (_1, _2, routerClass, { mountPointToLoad, mountPointToUnload, }) => makeStyleTag(`
				.${routerClass} {
					min-height: ${Math.max(mountPointToLoad.offsetHeight, (mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.offsetHeight) || 0)}px;
					min-width: ${Math.max(mountPointToLoad.offsetWidth, (mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.offsetWidth) || 0)}px;
				}
			`),
            (loadClass, unloadClass, _, { navigationType }) => makeStyleTag(`
				.${loadClass} {
					transition: transform ${duration}ms, opacity ${Math.floor(duration / 2)}ms linear ${Math.floor(duration / 2)}ms;
					opacity: 1;
					transform: translateX(0%);
				}
				.${unloadClass} {
					transition: transform ${duration}ms, opacity ${Math.floor(duration / 2)}ms linear;
					opacity: 0;
					transform: translateX(${navigationType === NavigationType.GoBackward ? '' : '-'}50%);
				}
			`),
        ]);
    }
    function dive(duration) {
        return commonTransitionGenerator(duration, [
            (loadClass, unloadClass, routerClass, { navigationType }) => makeStyleTag(`
				html {
					scroll-behavior: smooth;
				}
				.${loadClass} {
					position: absolute;
					z-index: 2;
					left: 0;
					top: 0;
					right: 0;
					opacity: 0;
					transform: translateZ(${navigationType === NavigationType.GoBackward ? '' : '-'}150px);
				}
				.${unloadClass} {
					position: relative;
					z-index: 1;
					opacity: 1;
					transform: translateZ(0px);
				}
				.${routerClass} {
					perspective: 1200px;
					perspective-origin: top center;
					position: relative;
					overflow: hidden;
				}
			`),
            (_1, _2, routerClass, { mountPointToLoad, mountPointToUnload, }) => makeStyleTag(`
				.${routerClass} {
					min-height: ${Math.max(mountPointToLoad.offsetHeight, (mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.offsetHeight) || 0)}px;
					min-width: ${Math.max(mountPointToLoad.offsetWidth, (mountPointToUnload === null || mountPointToUnload === void 0 ? void 0 : mountPointToUnload.offsetWidth) || 0)}px;
				}
			`),
            (loadClass, unloadClass, _, { navigationType }) => makeStyleTag(`
				.${loadClass} {
					transition: transform ${duration}ms, opacity ${Math.floor(duration / 2)}ms linear ${Math.floor(duration / 2)}ms;
					opacity: 1;
					transform: translateZ(0px);
				}
				.${unloadClass} {
					transition: transform ${duration}ms, opacity ${Math.floor(duration / 2)}ms linear;
					opacity: 0;
					transform: translateZ(${navigationType === NavigationType.GoBackward ? '-' : ''}150px);
				}
			`),
        ]);
    }
    function noAnimation() {
        return ({ scroll }) => {
            window.scrollTo(scroll.x, scroll.y);
            return Promise.resolve();
        };
    }

    const config = {
        defaultResumable: true,
        useHash: true,
        restoreScroll: true,
        routes: {},
        mountPoint: null,
        transitionFn: noAnimation(),
        dispatch: null,
    };
    const internalCache = writable([]);
    /** Current component cache readable store */
    derived(internalCache, (x) => x);
    /* LOCATION */
    function getLocation() {
        if (config.useHash) {
            const hashIndex = window.location.href.indexOf('#/');
            const location = hashIndex > -1 ? window.location.href.substring(hashIndex + 1) : '/';
            return location;
        }
        const relativeUrl = (window.location.pathname || '/') + window.location.search;
        return relativeUrl;
    }
    // Used in the `pop` function to prevent a double trigger of the PopStateEvent
    let ignorePopStateEvent = false;
    const _location = writable(getLocation(), (set) => {
        let previousLocation = null;
        const handlePopState = async () => {
            if (ignorePopStateEvent) {
                return;
            }
            const newLocation = getLocation();
            if (previousLocation !== newLocation) {
                previousLocation = newLocation;
                set(newLocation);
            }
        };
        window.addEventListener('popstate', handlePopState);
        return function stop() {
            window.removeEventListener('popstate', handlePopState);
        };
    });
    /**
     * Readable store representing the current location
     */
    const location$1 = derived(_location, ($_location) => $_location);
    /* PATHNAME */
    function getPathname(location) {
        const queryStringPosition = location.indexOf('?');
        if (queryStringPosition !== -1) {
            return location.substring(0, queryStringPosition);
        }
        return location;
    }
    /**
     * Readable store that contains the pathname part of the location
     */
    derived(location$1, getPathname);
    /* SEARCH */
    function getSearch(location) {
        const queryStringPosition = location.indexOf('?');
        if (queryStringPosition !== -1) {
            return location.substring(queryStringPosition);
        }
        return '';
    }
    /**
     * Readable store that contains the search part of the location
     */
    const search$1 = derived(location$1, getSearch);
    /* UTILS */
    let lastHistoryTimestamp;
    async function waitForHistoryState(callback) {
        const historyState = window.history.state;
        callback();
        // Wait for history.state to pick the current state (without this sleep history.state points to the previous state)
        // See https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event
        let limit = 100;
        while (historyState === window.history.state && limit) {
            await sleep(2);
            limit--;
        }
        if (historyState === window.history.state) {
            console.warn('unable to detect history change');
        }
    }
    function buildParams(pathname, routeKey) {
        const { pattern, keys } = regexparam(routeKey);
        const matches = pattern.exec(pathname) || [];
        const params = keys.reduce((params, _, index) => {
            params[keys[index]] = matches[index + 1] === undefined ? null : decodeURIComponent(matches[index + 1]);
            return params;
        }, {});
        return Object.keys(params).length === 0 ? undefined : params;
    }
    /* EVENT-BASED EXECUTION */
    const eventQueue = [];
    function enqueueEvent(event) {
        eventQueue.push(event);
        consumeQueue();
    }
    let consumingQueue = false;
    async function consumeQueue() {
        if (consumingQueue) {
            return;
        }
        consumingQueue = true;
        while (eventQueue.length > 0) {
            const item = eventQueue.shift();
            switch (item.type) {
                case StackRouterEventType.Navigate:
                    await handleHistoryChange(item.payload);
                    break;
                case StackRouterEventType.Mount:
                    await mount(item.payload);
                    break;
                case StackRouterEventType.Destroy:
                    await destroy();
                    break;
                case StackRouterEventType.UpdateConfig:
                    await updateConfig(item.payload);
                    break;
                // no default
            }
        }
        consumingQueue = false;
    }
    /* INIT & DESTROY */
    let locationSubscription = noop;
    function handleUpdateConfig(initConfig) {
        enqueueEvent({
            type: StackRouterEventType.UpdateConfig,
            payload: initConfig,
        });
    }
    function updateConfig(initConfig) {
        const previousUseHash = config.useHash;
        Object.keys(initConfig)
            .forEach((key) => {
            if (initConfig[key] !== undefined) {
                config[key] = initConfig[key];
            }
        });
        if (previousUseHash !== config.useHash) {
            const currentLocation = getLocation();
            if (get_store_value(_location) !== currentLocation) {
                _location.set(currentLocation);
            }
        }
        if ('scrollRestoration' in window.history) {
            window.history.scrollRestoration = config.restoreScroll ? 'manual' : 'auto';
        }
    }
    function handleStackRouterComponentMount(initConfig) {
        enqueueEvent({
            type: StackRouterEventType.Mount,
            payload: initConfig,
        });
    }
    function mount(initConfig) {
        updateConfig(initConfig);
        locationSubscription = location$1
            .subscribe(async ($location) => {
            // Wait for history.state to pick the current state (without this sleep history.state can point to the previous state)
            // See https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event
            let currentState = window.history.state;
            enqueueEvent({
                type: StackRouterEventType.Navigate,
                payload: {
                    location: $location,
                    state: currentState,
                },
            });
        });
    }
    function handleStackRouterComponentDestroy() {
        enqueueEvent({
            type: StackRouterEventType.Destroy,
        });
    }
    async function destroy() {
        locationSubscription();
        const currentCache = get_store_value(internalCache);
        for (const entry of currentCache) {
            // eslint-disable-next-line no-use-before-define
            if (entry === activeCacheEntry) {
                if (entry.entryConfig.onBeforeUnload && entry.entryConfig.onBeforeUnload.length > 0) {
                    for (const callback of entry.entryConfig.onBeforeUnload) {
                        await callback(true);
                    }
                }
                if (entry.entryConfig.resumable && entry.entryConfig.onPause && entry.entryConfig.onPause.length > 0) {
                    for (const callback of entry.entryConfig.onPause) {
                        await callback(true);
                    }
                }
                if (entry.entryConfig.onAfterUnload && entry.entryConfig.onAfterUnload.length > 0) {
                    for (const callback of entry.entryConfig.onAfterUnload) {
                        await callback(true);
                    }
                }
            }
            entry.componentInstance.$destroy();
        }
        // eslint-disable-next-line no-use-before-define
        activeCacheEntry = null;
        internalCache.set([]);
        locationSubscription = noop;
        config.mountPoint = null;
        config.dispatch = null;
    }
    let editableEntryConfig = null;
    async function prepareCacheEntryToActivate(cache, pathname) {
        const routeKeys = Object.keys(config.routes);
        const routeKey = routeKeys.find((routeKey) => {
            const { pattern } = regexparam(routeKey);
            return pattern.test(pathname);
        });
        if (routeKey === undefined || routeKey === null) {
            return {
                message: 'no route found',
            };
        }
        const params = buildParams(pathname, routeKey);
        const routeDescriptor = typeof config.routes[routeKey] === 'object' ? config.routes[routeKey] : {};
        // Check guards before updating params
        const guards = routeDescriptor.guards
            || (routeDescriptor.guard && [routeDescriptor.guard])
            || [];
        for (const guard of guards) {
            try {
                if (!await guard(params)) {
                    return {
                        message: 'access forbidden by guard',
                        params,
                    };
                }
            }
            catch (err) {
                return {
                    message: 'guard error',
                    params,
                    err,
                };
            }
        }
        const resumableEntry = cache.find((s) => s.routeMatch === routeKey);
        let entry;
        if (resumableEntry) {
            editableEntryConfig = resumableEntry.entryConfig;
            entry = resumableEntry;
            if (resumableEntry.pathname !== pathname) {
                resumableEntry.componentInstance.$set({ params });
                resumableEntry.pathname = pathname;
            }
        }
        else {
            const mountPoint = document.createElement('div');
            editableEntryConfig = {
                resumable: config.defaultResumable,
            };
            let component;
            if (typeof config.routes[routeKey] !== 'object') {
                component = config.routes[routeKey];
            }
            else if (routeDescriptor.component) {
                component = routeDescriptor.component;
            }
            else if (routeDescriptor.componentProvider) {
                try {
                    const resolved = await routeDescriptor.componentProvider();
                    component = resolved.default || resolved;
                    // Cache the promise result so that it will be available in the future
                    // without having to call the provider again
                    routeDescriptor.component = component;
                }
                catch (err) {
                    return {
                        message: 'unable to get component from provider',
                        err,
                    };
                }
            }
            else {
                return {
                    message: 'unable to get a component constructor',
                    err: new Error('unable to get a component constructor'),
                };
            }
            entry = {
                component,
                // eslint-disable-next-line new-cap
                componentInstance: new component({ target: mountPoint, props: { params } }),
                mountPoint,
                pathname,
                routeMatch: routeKey,
                entryConfig: editableEntryConfig,
            };
        }
        await tick();
        editableEntryConfig = null;
        return entry;
    }
    let activeCacheEntry = null;
    async function handleHistoryChange(historyItem) {
        var _a, _b, _c, _d;
        const currentCache = get_store_value(internalCache);
        const isNewHistoryItem = !historyItem.state;
        if (isNewHistoryItem) {
            historyItem.state = {
                timestamp: new Date().getTime(),
            };
            await waitForHistoryState(() => window.history.replaceState(historyItem.state, '', (config.useHash ? '#' : '') + historyItem.location));
        }
        const pageToLoadResult = await prepareCacheEntryToActivate(currentCache, getPathname(historyItem.location));
        if ('message' in pageToLoadResult) {
            switch (pageToLoadResult.message) {
                case 'access forbidden by guard':
                    (_a = config.dispatch) === null || _a === void 0 ? void 0 : _a.call(config, 'forbidden', {
                        ...pageToLoadResult,
                        location: historyItem.location,
                    });
                    break;
                default:
                    (_b = config.dispatch) === null || _b === void 0 ? void 0 : _b.call(config, 'error', {
                        ...pageToLoadResult,
                        location: historyItem.location,
                    });
                    break;
            }
            return;
        }
        const pageToLoad = pageToLoadResult;
        const pageToUnload = activeCacheEntry;
        const newTopIndexInCurrentStack = currentCache.findIndex((s) => s.routeMatch === pageToLoad.routeMatch);
        let pageToLoadAction = LoadableEntryAction.NoOp;
        let pageToUnloadAction = UnloadableEntryAction.NoOp;
        let navigationType = NavigationType.GoForwardNewState;
        if (!pageToUnload) {
            pageToLoadAction = LoadableEntryAction.New;
        }
        else {
            if (pageToUnload.routeMatch !== pageToLoad.routeMatch) {
                if (newTopIndexInCurrentStack !== -1) {
                    pageToLoadAction = LoadableEntryAction.Resume;
                }
                else {
                    pageToLoadAction = LoadableEntryAction.New;
                }
                if (pageToUnload.entryConfig.resumable) {
                    pageToUnloadAction = UnloadableEntryAction.Pause;
                }
                else {
                    pageToUnloadAction = UnloadableEntryAction.Destroy;
                }
            }
            if (isNewHistoryItem) {
                navigationType = NavigationType.GoForwardNewState;
            }
            else if (historyItem.state.timestamp > lastHistoryTimestamp) {
                navigationType = NavigationType.GoForwardResumeState;
            }
            else if (historyItem.state.timestamp < lastHistoryTimestamp) {
                navigationType = NavigationType.GoBackward;
            }
            else {
                navigationType = NavigationType.Replace;
            }
        }
        (_c = config.dispatch) === null || _c === void 0 ? void 0 : _c.call(config, 'navigation-start', {
            location: historyItem.location,
            navigationType,
            pageToLoad,
            pageToUnload,
            pageToLoadAction,
            pageToUnloadAction,
        });
        // BEFORE TRANSITION
        async function beforeUnload() {
            if (pageToUnload
                && pageToUnloadAction !== UnloadableEntryAction.NoOp
                && pageToUnload.entryConfig.onBeforeUnload
                && pageToUnload.entryConfig.onBeforeUnload.length > 0) {
                for (const callback of pageToUnload.entryConfig.onBeforeUnload) {
                    await callback();
                }
            }
        }
        async function beforeLoad() {
            if (pageToLoad
                && pageToLoadAction !== LoadableEntryAction.NoOp
                && pageToLoad.entryConfig.onBeforeLoad
                && pageToLoad.entryConfig.onBeforeLoad.length > 0) {
                for (const callback of pageToLoad.entryConfig.onBeforeLoad) {
                    await callback();
                }
            }
        }
        await Promise.all([beforeUnload(), beforeLoad()]);
        // DURING TRANSITION
        async function pause() {
            if (pageToUnload
                && pageToUnloadAction === UnloadableEntryAction.Pause
                && pageToUnload.entryConfig.onPause
                && pageToUnload.entryConfig.onPause.length > 0) {
                for (const callback of pageToUnload.entryConfig.onPause) {
                    await callback();
                }
            }
        }
        async function resume() {
            if (pageToLoad && pageToLoadAction === LoadableEntryAction.Resume) {
                const { returnValue } = historyItem.state || {};
                await waitForHistoryState(() => {
                    // Remove returnValue and scroll
                    window.history.replaceState({
                        timestamp: historyItem.state.timestamp,
                    }, '', (config.useHash ? '#' : '') + historyItem.location);
                });
                if (pageToLoad.entryConfig.onResume && pageToLoad.entryConfig.onResume.length > 0) {
                    for (const callback of pageToLoad.entryConfig.onResume) {
                        await callback(returnValue);
                    }
                }
            }
        }
        const oldTopMountPoint = pageToUnload ? pageToUnload.mountPoint : null;
        const newTopMountPoint = pageToLoad.mountPoint;
        if (oldTopMountPoint !== newTopMountPoint) {
            async function transition() {
                if (config.mountPoint) {
                    if (!newTopMountPoint.parentElement) {
                        config.mountPoint.appendChild(newTopMountPoint);
                    }
                    await config.transitionFn({
                        navigationType,
                        routerMountPoint: config.mountPoint,
                        mountPointToLoad: newTopMountPoint,
                        mountPointToUnload: oldTopMountPoint,
                        scroll: historyItem.state.scroll || { x: 0, y: 0 },
                    });
                    if (oldTopMountPoint) {
                        config.mountPoint.removeChild(oldTopMountPoint);
                    }
                }
            }
            await Promise.all([
                transition(),
                pause(),
                resume(),
            ]);
        }
        // AFTER TRANSITION
        async function afterLoad() {
            if (pageToLoad
                && pageToLoadAction !== LoadableEntryAction.NoOp
                && pageToLoad.entryConfig.onAfterLoad
                && pageToLoad.entryConfig.onAfterLoad.length > 0) {
                for (const callback of pageToLoad.entryConfig.onAfterLoad) {
                    await callback();
                }
            }
        }
        async function afterUnload() {
            if (pageToUnload
                && pageToUnloadAction !== UnloadableEntryAction.NoOp
                && pageToUnload.entryConfig.onAfterUnload
                && pageToUnload.entryConfig.onAfterUnload.length > 0) {
                for (const callback of pageToUnload.entryConfig.onAfterUnload) {
                    await callback();
                }
            }
        }
        await Promise.all([afterLoad(), afterUnload()]);
        if (pageToLoadAction === LoadableEntryAction.New) {
            currentCache.push(pageToLoad);
        }
        if (pageToUnload && pageToUnloadAction === UnloadableEntryAction.Destroy) {
            pageToUnload.componentInstance.$destroy();
            currentCache.splice(currentCache.indexOf(pageToUnload), 1);
        }
        internalCache.set(currentCache);
        activeCacheEntry = pageToLoad;
        lastHistoryTimestamp = historyItem.state.timestamp;
        (_d = config.dispatch) === null || _d === void 0 ? void 0 : _d.call(config, 'navigation-end', {
            location: historyItem.location,
            navigationType,
            pageToLoad,
            pageToUnload,
            pageToLoadAction,
            pageToUnloadAction,
        });
    }
    /**
     * Navigates to a new location
     * If scroll restoration is enabled, the current window scroll position is persisted before leaving the current location
     * If the new location equals the current one, this function won't modify the browser history
     * @param location new location
     */
    async function push(location) {
        if (location === getLocation()) {
            return;
        }
        if (config.restoreScroll) {
            await waitForHistoryState(() => {
                window.history.replaceState({
                    timestamp: window.history.state ? window.history.state.timestamp : new Date().getTime(),
                    scroll: {
                        x: window.scrollX,
                        y: window.scrollY,
                    },
                }, '', (config.useHash ? '#' : '') + getLocation());
            });
        }
        await waitForHistoryState(() => {
            window.history.pushState(undefined, '', (config.useHash ? '#' : '') + location);
        });
        dispatchCustomEvent(window, 'popstate');
    }
    /**
     * Navigates back
     * @param returnValue a serializable object that will be returned to the component associated with the previous location if resumable
     */
    async function pop(returnValue) {
        ignorePopStateEvent = true;
        await waitForHistoryState(() => window.history.back());
        await waitForHistoryState(() => {
            window.history.replaceState({
                ...window.history.state || {},
                returnValue,
            }, '', (config.useHash ? '#' : '') + getLocation());
        });
        ignorePopStateEvent = false;
        dispatchCustomEvent(window, 'popstate');
    }
    /* COMPONENT LIFECYCLE */
    const lifecycleErrorText = 'lifecycle functions can only be'
        + ' called while initializing or before preparing a component to resume (i.e. with a reactive statement on "params")';
    /**
     * Attaches a callback to the resume lifecycle phase.
     * Lifecycle summary (|| = semi-parallel execution, achieved with Promise.all):
     * - create the page component if not in cache
     * - before-unload previous component || before-load new component
     * - pause previous component if resumable || resume new component if in cache || animate-transition
     * - after-unload previous component || after-load new component
     * - destroy previous component if not resumable
     * @param callback function that will be called when the component is resumed
     */
    function onResume(callback) {
        if (!editableEntryConfig) {
            throw new Error(lifecycleErrorText);
        }
        if (!editableEntryConfig.onResume) {
            editableEntryConfig.onResume = [];
        }
        editableEntryConfig.onResume.push(callback);
    }

    /* node_modules\svelte-stack-router\src\StackRouter.svelte generated by Svelte v3.46.4 */
    const file$1p = "node_modules\\svelte-stack-router\\src\\StackRouter.svelte";

    function create_fragment$1p(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "stack-router-mount-point");
    			add_location(div, file$1p, 52, 0, 1577);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[6](div);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StackRouter', slots, []);
    	let { defaultResumable = true } = $$props;
    	let { useHash = true } = $$props;
    	let { restoreScroll = true } = $$props;
    	let { transitionFn = dive(300) } = $$props;
    	let { routes } = $$props;
    	let dispatch = createEventDispatcher();
    	let mountPoint;

    	onMount(() => {
    		handleStackRouterComponentMount({
    			mountPoint,
    			routes,
    			defaultResumable,
    			useHash,
    			restoreScroll,
    			transitionFn,
    			dispatch
    		});
    	});

    	onDestroy(() => {
    		handleStackRouterComponentDestroy();
    	});

    	const writable_props = ['defaultResumable', 'useHash', 'restoreScroll', 'transitionFn', 'routes'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StackRouter> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			mountPoint = $$value;
    			$$invalidate(0, mountPoint);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('defaultResumable' in $$props) $$invalidate(1, defaultResumable = $$props.defaultResumable);
    		if ('useHash' in $$props) $$invalidate(2, useHash = $$props.useHash);
    		if ('restoreScroll' in $$props) $$invalidate(3, restoreScroll = $$props.restoreScroll);
    		if ('transitionFn' in $$props) $$invalidate(4, transitionFn = $$props.transitionFn);
    		if ('routes' in $$props) $$invalidate(5, routes = $$props.routes);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		handleStackRouterComponentMount,
    		handleStackRouterComponentDestroy,
    		handleUpdateConfig,
    		dive,
    		defaultResumable,
    		useHash,
    		restoreScroll,
    		transitionFn,
    		routes,
    		dispatch,
    		mountPoint
    	});

    	$$self.$inject_state = $$props => {
    		if ('defaultResumable' in $$props) $$invalidate(1, defaultResumable = $$props.defaultResumable);
    		if ('useHash' in $$props) $$invalidate(2, useHash = $$props.useHash);
    		if ('restoreScroll' in $$props) $$invalidate(3, restoreScroll = $$props.restoreScroll);
    		if ('transitionFn' in $$props) $$invalidate(4, transitionFn = $$props.transitionFn);
    		if ('routes' in $$props) $$invalidate(5, routes = $$props.routes);
    		if ('dispatch' in $$props) dispatch = $$props.dispatch;
    		if ('mountPoint' in $$props) $$invalidate(0, mountPoint = $$props.mountPoint);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*defaultResumable, useHash, restoreScroll, transitionFn, routes*/ 62) {
    			(handleUpdateConfig({
    				routes,
    				defaultResumable,
    				useHash,
    				restoreScroll,
    				transitionFn
    			}));
    		}
    	};

    	return [
    		mountPoint,
    		defaultResumable,
    		useHash,
    		restoreScroll,
    		transitionFn,
    		routes,
    		div_binding
    	];
    }

    class StackRouter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {
    			defaultResumable: 1,
    			useHash: 2,
    			restoreScroll: 3,
    			transitionFn: 4,
    			routes: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StackRouter",
    			options,
    			id: create_fragment$1p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*routes*/ ctx[5] === undefined && !('routes' in props)) {
    			console.warn("<StackRouter> was created without expected prop 'routes'");
    		}
    	}

    	get defaultResumable() {
    		throw new Error("<StackRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultResumable(value) {
    		throw new Error("<StackRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useHash() {
    		throw new Error("<StackRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useHash(value) {
    		throw new Error("<StackRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScroll() {
    		throw new Error("<StackRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScroll(value) {
    		throw new Error("<StackRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionFn() {
    		throw new Error("<StackRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionFn(value) {
    		throw new Error("<StackRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routes() {
    		throw new Error("<StackRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error("<StackRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule$1(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var isStandalone = createCommonjsModule$1(function (module) {
    (function(global) {

      function isStandalone() {
        return navigator.standalone || (window.matchMedia('(display-mode: standalone)').matches);
      }

      if (
        module.exports &&
        typeof window !== 'undefined'
      ) {
        module.exports = isStandalone();
      } else {
        global.isStandalone = isStandalone();
      }
    })(commonjsGlobal$1);
    });

    /* node_modules\svelte-remixicon\lib\icons\AccountCircleFill.svelte generated by Svelte v3.46.4 */

    const file$1o = "node_modules\\svelte-remixicon\\lib\\icons\\AccountCircleFill.svelte";

    function create_fragment$1o(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1o, 17, 0, 295);
    			attr_dev(path1, "d", "M12 2c5.52 0 10 4.48 10 10s-4.48 10-10 10S2 17.52 2 12 6.48 2 12 2zM6.023 15.416C7.491 17.606 9.695 19 12.16 19c2.464 0 4.669-1.393 6.136-3.584A8.968 8.968 0 0 0 12.16 13a8.968 8.968 0 0 0-6.137 2.416zM12 11a3 3 0 1 0 0-6 3 3 0 0 0 0 6z");
    			add_location(path1, file$1o, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1o, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountCircleFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class AccountCircleFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountCircleFill",
    			options,
    			id: create_fragment$1o.name
    		});
    	}

    	get size() {
    		throw new Error("<AccountCircleFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<AccountCircleFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<AccountCircleFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<AccountCircleFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<AccountCircleFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<AccountCircleFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ArrowLeftLine.svelte generated by Svelte v3.46.4 */

    const file$1n = "node_modules\\svelte-remixicon\\lib\\icons\\ArrowLeftLine.svelte";

    function create_fragment$1n(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1n, 17, 0, 295);
    			attr_dev(path1, "d", "M7.828 11H20v2H7.828l5.364 5.364-1.414 1.414L4 12l7.778-7.778 1.414 1.414z");
    			add_location(path1, file$1n, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1n, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArrowLeftLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ArrowLeftLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArrowLeftLine",
    			options,
    			id: create_fragment$1n.name
    		});
    	}

    	get size() {
    		throw new Error("<ArrowLeftLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ArrowLeftLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ArrowLeftLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ArrowLeftLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ArrowLeftLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ArrowLeftLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ArrowRightSLine.svelte generated by Svelte v3.46.4 */

    const file$1m = "node_modules\\svelte-remixicon\\lib\\icons\\ArrowRightSLine.svelte";

    function create_fragment$1m(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1m, 17, 0, 295);
    			attr_dev(path1, "d", "M13.172 12l-4.95-4.95 1.414-1.414L16 12l-6.364 6.364-1.414-1.414z");
    			add_location(path1, file$1m, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1m, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArrowRightSLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ArrowRightSLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArrowRightSLine",
    			options,
    			id: create_fragment$1m.name
    		});
    	}

    	get size() {
    		throw new Error("<ArrowRightSLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ArrowRightSLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ArrowRightSLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ArrowRightSLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ArrowRightSLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ArrowRightSLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\Calendar2Fill.svelte generated by Svelte v3.46.4 */

    const file$1l = "node_modules\\svelte-remixicon\\lib\\icons\\Calendar2Fill.svelte";

    function create_fragment$1l(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1l, 17, 0, 295);
    			attr_dev(path1, "d", "M17 3h4a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h4V1h2v2h6V1h2v2zM4 9v10h16V9H4zm2 2h2v2H6v-2zm5 0h2v2h-2v-2zm5 0h2v2h-2v-2z");
    			add_location(path1, file$1l, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1l, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Calendar2Fill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class Calendar2Fill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Calendar2Fill",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get size() {
    		throw new Error("<Calendar2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Calendar2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Calendar2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Calendar2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Calendar2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Calendar2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ChatHeartFill.svelte generated by Svelte v3.46.4 */

    const file$1k = "node_modules\\svelte-remixicon\\lib\\icons\\ChatHeartFill.svelte";

    function create_fragment$1k(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1k, 17, 0, 295);
    			attr_dev(path1, "d", "M6.455 19L2 22.5V4a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6.455zm5.563-4.3l3.359-3.359a2.25 2.25 0 0 0-3.182-3.182l-.177.177-.177-.177a2.25 2.25 0 0 0-3.182 3.182l3.359 3.359z");
    			add_location(path1, file$1k, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1k, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChatHeartFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ChatHeartFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChatHeartFill",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get size() {
    		throw new Error("<ChatHeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ChatHeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ChatHeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ChatHeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ChatHeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChatHeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ChatHeartLine.svelte generated by Svelte v3.46.4 */

    const file$1j = "node_modules\\svelte-remixicon\\lib\\icons\\ChatHeartLine.svelte";

    function create_fragment$1j(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1j, 17, 0, 295);
    			attr_dev(path1, "fill-rule", "nonzero");
    			attr_dev(path1, "d", "M6.455 19L2 22.5V4a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6.455zM4 18.385L5.763 17H20V5H4v13.385zm8.018-3.685L8.659 11.34a2.25 2.25 0 0 1 3.182-3.182l.177.177.177-.177a2.25 2.25 0 0 1 3.182 3.182l-3.36 3.359z");
    			add_location(path1, file$1j, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1j, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChatHeartLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ChatHeartLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChatHeartLine",
    			options,
    			id: create_fragment$1j.name
    		});
    	}

    	get size() {
    		throw new Error("<ChatHeartLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ChatHeartLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ChatHeartLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ChatHeartLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ChatHeartLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChatHeartLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ChatQuoteFill.svelte generated by Svelte v3.46.4 */

    const file$1i = "node_modules\\svelte-remixicon\\lib\\icons\\ChatQuoteFill.svelte";

    function create_fragment$1i(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$1i, 17, 0, 295);
    			attr_dev(path1, "d", "M21 3c.552 0 1 .448 1 1v14c0 .552-.448 1-1 1H6.455L2 22.5V4c0-.552.448-1 1-1h18zM10.962 8.1l-.447-.688C8.728 8.187 7.5 9.755 7.5 11.505c0 .995.277 1.609.792 2.156.324.344.837.589 1.374.589.966 0 1.75-.784 1.75-1.75 0-.92-.711-1.661-1.614-1.745-.16-.015-.324-.012-.479.01v-.092c.006-.422.092-1.633 1.454-2.466l.185-.107-.447-.688zm4.553-.688c-1.787.775-3.015 2.343-3.015 4.093 0 .995.277 1.609.792 2.156.324.344.837.589 1.374.589.966 0 1.75-.784 1.75-1.75 0-.92-.711-1.661-1.614-1.745-.16-.015-.324-.012-.479.01 0-.313-.029-1.762 1.639-2.665z");
    			add_location(path1, file$1i, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1i, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChatQuoteFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ChatQuoteFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChatQuoteFill",
    			options,
    			id: create_fragment$1i.name
    		});
    	}

    	get size() {
    		throw new Error("<ChatQuoteFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ChatQuoteFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ChatQuoteFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ChatQuoteFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ChatQuoteFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChatQuoteFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ChatQuoteLine.svelte generated by Svelte v3.46.4 */

    const file$1h = "node_modules\\svelte-remixicon\\lib\\icons\\ChatQuoteLine.svelte";

    function create_fragment$1h(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$1h, 17, 0, 295);
    			attr_dev(path1, "d", "M21 3c.552 0 1 .448 1 1v14c0 .552-.448 1-1 1H6.455L2 22.5V4c0-.552.448-1 1-1h18zm-1 2H4v13.385L5.763 17H20V5zm-9.485 2.412l.447.688c-1.668.903-1.639 2.352-1.639 2.664.155-.02.318-.024.48-.009.902.084 1.613.825 1.613 1.745 0 .966-.784 1.75-1.75 1.75-.537 0-1.05-.245-1.374-.59-.515-.546-.792-1.16-.792-2.155 0-1.75 1.228-3.318 3.015-4.093zm5 0l.447.688c-1.668.903-1.639 2.352-1.639 2.664.155-.02.318-.024.48-.009.902.084 1.613.825 1.613 1.745 0 .966-.784 1.75-1.75 1.75-.537 0-1.05-.245-1.374-.59-.515-.546-.792-1.16-.792-2.155 0-1.75 1.228-3.318 3.015-4.093z");
    			add_location(path1, file$1h, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1h, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChatQuoteLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ChatQuoteLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChatQuoteLine",
    			options,
    			id: create_fragment$1h.name
    		});
    	}

    	get size() {
    		throw new Error("<ChatQuoteLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ChatQuoteLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ChatQuoteLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ChatQuoteLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ChatQuoteLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChatQuoteLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\CheckboxBlankCircleLine.svelte generated by Svelte v3.46.4 */

    const file$1g = "node_modules\\svelte-remixicon\\lib\\icons\\CheckboxBlankCircleLine.svelte";

    function create_fragment$1g(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1g, 17, 0, 295);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z");
    			add_location(path1, file$1g, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1g, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CheckboxBlankCircleLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class CheckboxBlankCircleLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CheckboxBlankCircleLine",
    			options,
    			id: create_fragment$1g.name
    		});
    	}

    	get size() {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CheckboxBlankCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\Compass3Fill.svelte generated by Svelte v3.46.4 */

    const file$1f = "node_modules\\svelte-remixicon\\lib\\icons\\Compass3Fill.svelte";

    function create_fragment$1f(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1f, 17, 0, 295);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm4.5-14.5L10 10l-2.5 6.5L14 14l2.5-6.5zM12 13a1 1 0 1 1 0-2 1 1 0 0 1 0 2z");
    			add_location(path1, file$1f, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1f, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Compass3Fill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class Compass3Fill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Compass3Fill",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get size() {
    		throw new Error("<Compass3Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Compass3Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Compass3Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Compass3Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Compass3Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Compass3Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\DeleteBinLine.svelte generated by Svelte v3.46.4 */

    const file$1e = "node_modules\\svelte-remixicon\\lib\\icons\\DeleteBinLine.svelte";

    function create_fragment$1e(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1e, 17, 0, 295);
    			attr_dev(path1, "d", "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-9 3h2v6H9v-6zm4 0h2v6h-2v-6zM9 4v2h6V4H9z");
    			add_location(path1, file$1e, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1e, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DeleteBinLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class DeleteBinLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeleteBinLine",
    			options,
    			id: create_fragment$1e.name
    		});
    	}

    	get size() {
    		throw new Error("<DeleteBinLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<DeleteBinLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<DeleteBinLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<DeleteBinLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<DeleteBinLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DeleteBinLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\DislikeLine.svelte generated by Svelte v3.46.4 */

    const file$1d = "node_modules\\svelte-remixicon\\lib\\icons\\DislikeLine.svelte";

    function create_fragment$1d(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$1d, 17, 0, 295);
    			attr_dev(path1, "d", "M2.808 1.393l18.384 18.385-1.414 1.414-3.747-3.747L12 21.485 3.52 12.993c-2.04-2.284-2.028-5.753.034-8.023L1.393 2.808l1.415-1.415zm2.172 10.23L12 18.654l2.617-2.623-9.645-9.645c-1.294 1.497-1.3 3.735.008 5.237zm15.263-6.866c2.262 2.268 2.34 5.88.236 8.236l-1.635 1.636-1.414-1.414 1.59-1.592c1.374-1.576 1.299-3.958-.193-5.453-1.5-1.502-3.92-1.563-5.49-.153l-1.335 1.198-1.336-1.197c-.35-.314-.741-.555-1.155-.723l-2.25-2.25c1.668-.206 3.407.289 4.74 1.484 2.349-2.109 5.979-2.039 8.242.228z");
    			add_location(path1, file$1d, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1d, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DislikeLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class DislikeLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DislikeLine",
    			options,
    			id: create_fragment$1d.name
    		});
    	}

    	get size() {
    		throw new Error("<DislikeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<DislikeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<DislikeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<DislikeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<DislikeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DislikeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\GitRepositoryPrivateLine.svelte generated by Svelte v3.46.4 */

    const file$1c = "node_modules\\svelte-remixicon\\lib\\icons\\GitRepositoryPrivateLine.svelte";

    function create_fragment$1c(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1c, 17, 0, 295);
    			attr_dev(path1, "fill-rule", "nonzero");
    			attr_dev(path1, "d", "M6 10v10h13V10H6zm12-2h2a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h2V7a6 6 0 1 1 12 0v1zm-2 0V7a4 4 0 1 0-8 0v1h8zm-9 3h2v2H7v-2zm0 3h2v2H7v-2zm0 3h2v2H7v-2z");
    			add_location(path1, file$1c, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1c, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GitRepositoryPrivateLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class GitRepositoryPrivateLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GitRepositoryPrivateLine",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get size() {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<GitRepositoryPrivateLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\Heart2Fill.svelte generated by Svelte v3.46.4 */

    const file$1b = "node_modules\\svelte-remixicon\\lib\\icons\\Heart2Fill.svelte";

    function create_fragment$1b(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$1b, 17, 0, 295);
    			attr_dev(path1, "d", "M20.243 4.757c2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236C5.515 3 8.093 2.56 10.261 3.44L6.343 7.358l1.414 1.415L12 4.53l-.013-.014.014.013c2.349-2.109 5.979-2.039 8.242.228z");
    			add_location(path1, file$1b, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1b, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heart2Fill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class Heart2Fill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heart2Fill",
    			options,
    			id: create_fragment$1b.name
    		});
    	}

    	get size() {
    		throw new Error("<Heart2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Heart2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Heart2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Heart2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Heart2Fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Heart2Fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\Heart2Line.svelte generated by Svelte v3.46.4 */

    const file$1a = "node_modules\\svelte-remixicon\\lib\\icons\\Heart2Line.svelte";

    function create_fragment$1a(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$1a, 17, 0, 295);
    			attr_dev(path1, "d", "M20.243 4.757c2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236 2.265-2.264 5.888-2.34 8.244-.228 2.349-2.109 5.979-2.039 8.242.228zM5.172 6.172c-1.49 1.49-1.565 3.875-.192 5.451L12 18.654l7.02-7.03c1.374-1.577 1.299-3.959-.193-5.454-1.487-1.49-3.881-1.562-5.453-.186l-4.202 4.203-1.415-1.414 2.825-2.827-.082-.069c-1.575-1.265-3.877-1.157-5.328.295z");
    			add_location(path1, file$1a, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1a, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heart2Line', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class Heart2Line extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heart2Line",
    			options,
    			id: create_fragment$1a.name
    		});
    	}

    	get size() {
    		throw new Error("<Heart2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Heart2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Heart2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Heart2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Heart2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Heart2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\HeartFill.svelte generated by Svelte v3.46.4 */

    const file$19 = "node_modules\\svelte-remixicon\\lib\\icons\\HeartFill.svelte";

    function create_fragment$19(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$19, 17, 0, 295);
    			attr_dev(path1, "d", "M12.001 4.529c2.349-2.109 5.979-2.039 8.242.228 2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236 2.265-2.264 5.888-2.34 8.244-.228z");
    			add_location(path1, file$19, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$19, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HeartFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class HeartFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeartFill",
    			options,
    			id: create_fragment$19.name
    		});
    	}

    	get size() {
    		throw new Error("<HeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<HeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<HeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<HeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<HeartFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<HeartFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\HeartPulseFill.svelte generated by Svelte v3.46.4 */

    const file$18 = "node_modules\\svelte-remixicon\\lib\\icons\\HeartPulseFill.svelte";

    function create_fragment$18(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$18, 17, 0, 295);
    			attr_dev(path1, "d", "M16.5 3C19.538 3 22 5.5 22 9c0 7-7.5 11-10 12.5-1.978-1.187-7.084-3.937-9.132-8.5h4.698l.934-1.556 3 5L13.566 13H17v-2h-4.566l-.934 1.556-3-5L6.434 11H2.21C2.074 10.363 2 9.696 2 9c0-3.5 2.5-6 5.5-6C9.36 3 11 4 12 5c1-1 2.64-2 4.5-2z");
    			add_location(path1, file$18, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$18, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HeartPulseFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class HeartPulseFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeartPulseFill",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get size() {
    		throw new Error("<HeartPulseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<HeartPulseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<HeartPulseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<HeartPulseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<HeartPulseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<HeartPulseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\HeartPulseLine.svelte generated by Svelte v3.46.4 */

    const file$17 = "node_modules\\svelte-remixicon\\lib\\icons\\HeartPulseLine.svelte";

    function create_fragment$17(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$17, 17, 0, 295);
    			attr_dev(path1, "d", "M16.5 3C19.538 3 22 5.5 22 9c0 7-7.5 11-10 12.5-1.977-1.186-7.083-3.937-9.131-8.499L1 13v-2h1.21C2.074 10.364 2 9.698 2 9c0-3.5 2.5-6 5.5-6C9.36 3 11 4 12 5c1-1 2.64-2 4.5-2zm0 2c-1.076 0-2.24.57-3.086 1.414L12 7.828l-1.414-1.414C9.74 5.57 8.576 5 7.5 5 5.56 5 4 6.656 4 9c0 .685.09 1.352.267 2h2.167L8.5 7.556l3 5L12.434 11H17v2h-3.434L11.5 16.444l-3-5L7.566 13H5.108c.79 1.374 1.985 2.668 3.537 3.903.745.592 1.54 1.145 2.421 1.7.299.189.595.37.934.572.339-.202.635-.383.934-.571.881-.556 1.676-1.109 2.42-1.701C18.335 14.533 20 11.943 20 9c0-2.36-1.537-4-3.5-4z");
    			add_location(path1, file$17, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$17, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HeartPulseLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class HeartPulseLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeartPulseLine",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get size() {
    		throw new Error("<HeartPulseLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<HeartPulseLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<HeartPulseLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<HeartPulseLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<HeartPulseLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<HeartPulseLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\LinksLine.svelte generated by Svelte v3.46.4 */

    const file$16 = "node_modules\\svelte-remixicon\\lib\\icons\\LinksLine.svelte";

    function create_fragment$16(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$16, 17, 0, 295);
    			attr_dev(path1, "d", "M13.06 8.11l1.415 1.415a7 7 0 0 1 0 9.9l-.354.353a7 7 0 0 1-9.9-9.9l1.415 1.415a5 5 0 1 0 7.071 7.071l.354-.354a5 5 0 0 0 0-7.07l-1.415-1.415 1.415-1.414zm6.718 6.011l-1.414-1.414a5 5 0 1 0-7.071-7.071l-.354.354a5 5 0 0 0 0 7.07l1.415 1.415-1.415 1.414-1.414-1.414a7 7 0 0 1 0-9.9l.354-.353a7 7 0 0 1 9.9 9.9z");
    			add_location(path1, file$16, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$16, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LinksLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class LinksLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinksLine",
    			options,
    			id: create_fragment$16.name
    		});
    	}

    	get size() {
    		throw new Error("<LinksLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<LinksLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<LinksLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<LinksLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<LinksLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<LinksLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\Message2Line.svelte generated by Svelte v3.46.4 */

    const file$15 = "node_modules\\svelte-remixicon\\lib\\icons\\Message2Line.svelte";

    function create_fragment$15(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$15, 17, 0, 295);
    			attr_dev(path1, "d", "M6.455 19L2 22.5V4a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6.455zm-.692-2H20V5H4v13.385L5.763 17zM11 10h2v2h-2v-2zm-4 0h2v2H7v-2zm8 0h2v2h-2v-2z");
    			add_location(path1, file$15, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$15, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Message2Line', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class Message2Line extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Message2Line",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get size() {
    		throw new Error("<Message2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Message2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Message2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Message2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Message2Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Message2Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PauseFill.svelte generated by Svelte v3.46.4 */

    const file$14 = "node_modules\\svelte-remixicon\\lib\\icons\\PauseFill.svelte";

    function create_fragment$14(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$14, 17, 0, 295);
    			attr_dev(path1, "d", "M6 5h2v14H6V5zm10 0h2v14h-2V5z");
    			add_location(path1, file$14, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$14, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PauseFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PauseFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PauseFill",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get size() {
    		throw new Error("<PauseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PauseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PauseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PauseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PauseFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PauseFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PlayCircleLine.svelte generated by Svelte v3.46.4 */

    const file$13 = "node_modules\\svelte-remixicon\\lib\\icons\\PlayCircleLine.svelte";

    function create_fragment$13(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$13, 17, 0, 295);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zM10.622 8.415l4.879 3.252a.4.4 0 0 1 0 .666l-4.88 3.252a.4.4 0 0 1-.621-.332V8.747a.4.4 0 0 1 .622-.332z");
    			add_location(path1, file$13, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$13, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayCircleLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PlayCircleLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayCircleLine",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get size() {
    		throw new Error("<PlayCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PlayCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PlayCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PlayCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PlayCircleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PlayCircleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PlayFill.svelte generated by Svelte v3.46.4 */

    const file$12 = "node_modules\\svelte-remixicon\\lib\\icons\\PlayFill.svelte";

    function create_fragment$12(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$12, 17, 0, 295);
    			attr_dev(path1, "d", "M19.376 12.416L8.777 19.482A.5.5 0 0 1 8 19.066V4.934a.5.5 0 0 1 .777-.416l10.599 7.066a.5.5 0 0 1 0 .832z");
    			add_location(path1, file$12, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$12, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PlayFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayFill",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get size() {
    		throw new Error("<PlayFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PlayFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PlayFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PlayFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PlayFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PlayFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PlayListFill.svelte generated by Svelte v3.46.4 */

    const file$11 = "node_modules\\svelte-remixicon\\lib\\icons\\PlayListFill.svelte";

    function create_fragment$11(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$11, 17, 0, 295);
    			attr_dev(path1, "d", "M2 18h10v2H2v-2zm0-7h14v2H2v-2zm0-7h20v2H2V4zm17 11.17V9h5v2h-3v7a3 3 0 1 1-2-2.83z");
    			add_location(path1, file$11, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$11, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayListFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PlayListFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayListFill",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get size() {
    		throw new Error("<PlayListFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PlayListFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PlayListFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PlayListFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PlayListFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PlayListFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PlayListLine.svelte generated by Svelte v3.46.4 */

    const file$10 = "node_modules\\svelte-remixicon\\lib\\icons\\PlayListLine.svelte";

    function create_fragment$10(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$10, 17, 0, 295);
    			attr_dev(path1, "d", "M2 18h10v2H2v-2zm0-7h14v2H2v-2zm0-7h20v2H2V4zm17 11.17V9h5v2h-3v7a3 3 0 1 1-2-2.83zM18 19a1 1 0 1 0 0-2 1 1 0 0 0 0 2z");
    			add_location(path1, file$10, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$10, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayListLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PlayListLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayListLine",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get size() {
    		throw new Error("<PlayListLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PlayListLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PlayListLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PlayListLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PlayListLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PlayListLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\PlayMiniLine.svelte generated by Svelte v3.46.4 */

    const file$$ = "node_modules\\svelte-remixicon\\lib\\icons\\PlayMiniLine.svelte";

    function create_fragment$$(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$$, 17, 0, 295);
    			attr_dev(path1, "fill-rule", "nonzero");
    			attr_dev(path1, "d", "M9 8.482v7.036L15.03 12 9 8.482zM7.752 5.44l10.508 6.13a.5.5 0 0 1 0 .863l-10.508 6.13A.5.5 0 0 1 7 18.128V5.871a.5.5 0 0 1 .752-.432z");
    			add_location(path1, file$$, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$$, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayMiniLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class PlayMiniLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayMiniLine",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get size() {
    		throw new Error("<PlayMiniLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<PlayMiniLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<PlayMiniLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<PlayMiniLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<PlayMiniLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<PlayMiniLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\RadioButtonLine.svelte generated by Svelte v3.46.4 */

    const file$_ = "node_modules\\svelte-remixicon\\lib\\icons\\RadioButtonLine.svelte";

    function create_fragment$_(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$_, 17, 0, 295);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-3a5 5 0 1 1 0-10 5 5 0 0 1 0 10z");
    			add_location(path1, file$_, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$_, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RadioButtonLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class RadioButtonLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RadioButtonLine",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get size() {
    		throw new Error("<RadioButtonLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<RadioButtonLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RadioButtonLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RadioButtonLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<RadioButtonLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<RadioButtonLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\RadioFill.svelte generated by Svelte v3.46.4 */

    const file$Z = "node_modules\\svelte-remixicon\\lib\\icons\\RadioFill.svelte";

    function create_fragment$Z(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$Z, 17, 0, 295);
    			attr_dev(path1, "d", "M17 10h3V6H4v4h11V8h2v2zM6 3V1h2v2h13.008c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3H6zm1 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6z");
    			add_location(path1, file$Z, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Z, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RadioFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class RadioFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RadioFill",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get size() {
    		throw new Error("<RadioFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<RadioFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RadioFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RadioFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<RadioFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<RadioFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\RadioLine.svelte generated by Svelte v3.46.4 */

    const file$Y = "node_modules\\svelte-remixicon\\lib\\icons\\RadioLine.svelte";

    function create_fragment$Y(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$Y, 17, 0, 295);
    			attr_dev(path1, "d", "M17 10V8h-2v2H5V6h14v4h-2zM6 3V1h2v2h13.008c.548 0 .992.445.992.993v16.014a1 1 0 0 1-.992.993H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3H6zM4 5v14h16V5H4zm4 13a3 3 0 1 1 0-6 3 3 0 0 1 0 6z");
    			add_location(path1, file$Y, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Y, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RadioLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class RadioLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RadioLine",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get size() {
    		throw new Error("<RadioLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<RadioLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RadioLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RadioLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<RadioLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<RadioLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\RefreshLine.svelte generated by Svelte v3.46.4 */

    const file$X = "node_modules\\svelte-remixicon\\lib\\icons\\RefreshLine.svelte";

    function create_fragment$X(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$X, 17, 0, 295);
    			attr_dev(path1, "d", "M5.463 4.433A9.961 9.961 0 0 1 12 2c5.523 0 10 4.477 10 10 0 2.136-.67 4.116-1.81 5.74L17 12h3A8 8 0 0 0 6.46 6.228l-.997-1.795zm13.074 15.134A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12c0-2.136.67-4.116 1.81-5.74L7 12H4a8 8 0 0 0 13.54 5.772l.997 1.795z");
    			add_location(path1, file$X, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$X, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RefreshLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class RefreshLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RefreshLine",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get size() {
    		throw new Error("<RefreshLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<RefreshLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RefreshLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RefreshLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<RefreshLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<RefreshLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\RepeatOneLine.svelte generated by Svelte v3.46.4 */

    const file$W = "node_modules\\svelte-remixicon\\lib\\icons\\RepeatOneLine.svelte";

    function create_fragment$W(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$W, 17, 0, 295);
    			attr_dev(path1, "d", "M8 20v1.932a.5.5 0 0 1-.82.385l-4.12-3.433A.5.5 0 0 1 3.382 18H18a2 2 0 0 0 2-2V8h2v8a4 4 0 0 1-4 4H8zm8-17.932a.5.5 0 0 1 .82-.385l4.12 3.433a.5.5 0 0 1-.321.884H6a2 2 0 0 0-2 2v8H2V8a4 4 0 0 1 4-4h10V2.068zM11 8h2v8h-2v-6H9V9l2-1z");
    			add_location(path1, file$W, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$W, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RepeatOneLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class RepeatOneLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RepeatOneLine",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get size() {
    		throw new Error("<RepeatOneLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<RepeatOneLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<RepeatOneLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<RepeatOneLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<RepeatOneLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<RepeatOneLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\SearchLine.svelte generated by Svelte v3.46.4 */

    const file$V = "node_modules\\svelte-remixicon\\lib\\icons\\SearchLine.svelte";

    function create_fragment$V(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$V, 17, 0, 295);
    			attr_dev(path1, "d", "M18.031 16.617l4.283 4.282-1.415 1.415-4.282-4.283A8.96 8.96 0 0 1 11 20c-4.968 0-9-4.032-9-9s4.032-9 9-9 9 4.032 9 9a8.96 8.96 0 0 1-1.969 5.617zm-2.006-.742A6.977 6.977 0 0 0 18 11c0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7a6.977 6.977 0 0 0 4.875-1.975l.15-.15z");
    			add_location(path1, file$V, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$V, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class SearchLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchLine",
    			options,
    			id: create_fragment$V.name
    		});
    	}

    	get size() {
    		throw new Error("<SearchLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SearchLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SearchLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SearchLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SearchLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SearchLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ShuffleLine.svelte generated by Svelte v3.46.4 */

    const file$U = "node_modules\\svelte-remixicon\\lib\\icons\\ShuffleLine.svelte";

    function create_fragment$U(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$U, 17, 0, 295);
    			attr_dev(path1, "d", "M18 17.883V16l5 3-5 3v-2.09a9 9 0 0 1-6.997-5.365L11 14.54l-.003.006A9 9 0 0 1 2.725 20H2v-2h.725a7 7 0 0 0 6.434-4.243L9.912 12l-.753-1.757A7 7 0 0 0 2.725 6H2V4h.725a9 9 0 0 1 8.272 5.455L11 9.46l.003-.006A9 9 0 0 1 18 4.09V2l5 3-5 3V6.117a7 7 0 0 0-5.159 4.126L12.088 12l.753 1.757A7 7 0 0 0 18 17.883z");
    			add_location(path1, file$U, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$U, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ShuffleLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ShuffleLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ShuffleLine",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get size() {
    		throw new Error("<ShuffleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ShuffleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ShuffleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ShuffleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ShuffleLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ShuffleLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\SkipBackFill.svelte generated by Svelte v3.46.4 */

    const file$T = "node_modules\\svelte-remixicon\\lib\\icons\\SkipBackFill.svelte";

    function create_fragment$T(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$T, 17, 0, 295);
    			attr_dev(path1, "d", "M8 11.333l10.223-6.815a.5.5 0 0 1 .777.416v14.132a.5.5 0 0 1-.777.416L8 12.667V19a1 1 0 0 1-2 0V5a1 1 0 1 1 2 0v6.333z");
    			add_location(path1, file$T, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$T, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SkipBackFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class SkipBackFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SkipBackFill",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get size() {
    		throw new Error("<SkipBackFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SkipBackFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SkipBackFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SkipBackFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SkipBackFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SkipBackFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\SkipForwardFill.svelte generated by Svelte v3.46.4 */

    const file$S = "node_modules\\svelte-remixicon\\lib\\icons\\SkipForwardFill.svelte";

    function create_fragment$S(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$S, 17, 0, 295);
    			attr_dev(path1, "d", "M16 12.667L5.777 19.482A.5.5 0 0 1 5 19.066V4.934a.5.5 0 0 1 .777-.416L16 11.333V5a1 1 0 0 1 2 0v14a1 1 0 0 1-2 0v-6.333z");
    			add_location(path1, file$S, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$S, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SkipForwardFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class SkipForwardFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SkipForwardFill",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get size() {
    		throw new Error("<SkipForwardFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SkipForwardFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SkipForwardFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SkipForwardFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SkipForwardFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SkipForwardFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\SkipForwardMiniFill.svelte generated by Svelte v3.46.4 */

    const file$R = "node_modules\\svelte-remixicon\\lib\\icons\\SkipForwardMiniFill.svelte";

    function create_fragment$R(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$R, 17, 0, 295);
    			attr_dev(path1, "d", "M7.788 17.444A.5.5 0 0 1 7 17.035V6.965a.5.5 0 0 1 .788-.409l7.133 5.036a.5.5 0 0 1 0 .816l-7.133 5.036zM16 7a1 1 0 0 1 2 0v10a1 1 0 1 1-2 0V7z");
    			add_location(path1, file$R, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$R, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SkipForwardMiniFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class SkipForwardMiniFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SkipForwardMiniFill",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get size() {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SkipForwardMiniFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\SortDesc.svelte generated by Svelte v3.46.4 */

    const file$Q = "node_modules\\svelte-remixicon\\lib\\icons\\SortDesc.svelte";

    function create_fragment$Q(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0H24V24H0z");
    			add_location(path0, file$Q, 17, 0, 295);
    			attr_dev(path1, "d", "M20 4v12h3l-4 5-4-5h3V4h2zm-8 14v2H3v-2h9zm2-7v2H3v-2h11zm0-7v2H3V4h11z");
    			add_location(path1, file$Q, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Q, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SortDesc', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class SortDesc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SortDesc",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get size() {
    		throw new Error("<SortDesc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SortDesc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SortDesc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SortDesc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<SortDesc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SortDesc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\StarSFill.svelte generated by Svelte v3.46.4 */

    const file$P = "node_modules\\svelte-remixicon\\lib\\icons\\StarSFill.svelte";

    function create_fragment$P(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$P, 17, 0, 295);
    			attr_dev(path1, "d", "M12 17l-5.878 3.59 1.598-6.7-5.23-4.48 6.865-.55L12 2.5l2.645 6.36 6.866.55-5.231 4.48 1.598 6.7z");
    			add_location(path1, file$P, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$P, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StarSFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class StarSFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StarSFill",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get size() {
    		throw new Error("<StarSFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<StarSFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<StarSFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<StarSFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<StarSFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<StarSFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ThumbUpFill.svelte generated by Svelte v3.46.4 */

    const file$O = "node_modules\\svelte-remixicon\\lib\\icons\\ThumbUpFill.svelte";

    function create_fragment$O(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$O, 17, 0, 295);
    			attr_dev(path1, "d", "M2 9h3v12H2a1 1 0 0 1-1-1V10a1 1 0 0 1 1-1zm5.293-1.293l6.4-6.4a.5.5 0 0 1 .654-.047l.853.64a1.5 1.5 0 0 1 .553 1.57L14.6 8H21a2 2 0 0 1 2 2v2.104a2 2 0 0 1-.15.762l-3.095 7.515a1 1 0 0 1-.925.619H8a1 1 0 0 1-1-1V8.414a1 1 0 0 1 .293-.707z");
    			add_location(path1, file$O, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$O, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ThumbUpFill', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ThumbUpFill extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ThumbUpFill",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get size() {
    		throw new Error("<ThumbUpFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ThumbUpFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ThumbUpFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ThumbUpFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ThumbUpFill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ThumbUpFill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-remixicon\lib\icons\ThumbUpLine.svelte generated by Svelte v3.46.4 */

    const file$N = "node_modules\\svelte-remixicon\\lib\\icons\\ThumbUpLine.svelte";

    function create_fragment$N(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let mounted;
    	let dispose;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 24 24" },
    		{ width: /*size*/ ctx[0] },
    		{ height: /*size*/ ctx[0] },
    		{ fill: /*color*/ ctx[1] },
    		{
    			class: svg_class_value = "remixicon " + /*customClass*/ ctx[2]
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$N, 17, 0, 295);
    			attr_dev(path1, "d", "M14.6 8H21a2 2 0 0 1 2 2v2.104a2 2 0 0 1-.15.762l-3.095 7.515a1 1 0 0 1-.925.619H2a1 1 0 0 1-1-1V10a1 1 0 0 1 1-1h3.482a1 1 0 0 0 .817-.423L11.752.85a.5.5 0 0 1 .632-.159l1.814.907a2.5 2.5 0 0 1 1.305 2.853L14.6 8zM7 10.588V19h11.16L21 12.104V10h-6.4a2 2 0 0 1-1.938-2.493l.903-3.548a.5.5 0 0 0-.261-.571l-.661-.33-4.71 6.672c-.25.354-.57.644-.933.858zM5 11H3v8h2v-8z");
    			add_location(path1, file$N, 17, 51, 346);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$N, 7, 0, 135);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 24 24" },
    				dirty & /*size*/ 1 && { width: /*size*/ ctx[0] },
    				dirty & /*size*/ 1 && { height: /*size*/ ctx[0] },
    				dirty & /*color*/ 2 && { fill: /*color*/ ctx[1] },
    				dirty & /*customClass*/ 4 && svg_class_value !== (svg_class_value = "remixicon " + /*customClass*/ ctx[2]) && { class: svg_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size","color","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ThumbUpLine', slots, []);
    	let { size = '1em' } = $$props;
    	let { color = 'currentColor' } = $$props;
    	let { class: customClass = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
    		if ('class' in $$new_props) $$invalidate(2, customClass = $$new_props.class);
    	};

    	$$self.$capture_state = () => ({ size, color, customClass });

    	$$self.$inject_state = $$new_props => {
    		if ('size' in $$props) $$invalidate(0, size = $$new_props.size);
    		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$new_props.customClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, color, customClass, $$restProps, click_handler];
    }

    class ThumbUpLine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, { size: 0, color: 1, class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ThumbUpLine",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get size() {
    		throw new Error("<ThumbUpLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ThumbUpLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ThumbUpLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ThumbUpLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ThumbUpLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ThumbUpLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function fromElement(element_id, canvas_id, options) {
        const globalAccessKey = [options.globalAccessKey || '$wave'];
        const initGlobalObject = (elementId) => {
            window[globalAccessKey] = window[globalAccessKey] || {};
            window[globalAccessKey][elementId] = window[globalAccessKey][elementId] || {};
        };

        const getGlobal = options['getGlobal'] || function(elementId, accessKey) {
            initGlobalObject(elementId);
            return window[globalAccessKey][elementId][accessKey];
        };

        const setGlobal = options['setGlobal'] || function(elementId, accessKey, value) {
            let returnValue = getGlobal(elementId, accessKey);
            if(!returnValue) {
                window[globalAccessKey][elementId][accessKey] = window[globalAccessKey][elementId][accessKey] || value;
                returnValue = window[globalAccessKey][elementId][accessKey];
            }
            return returnValue;
        };

        const waveContext = this;
        let element = document.getElementById(element_id);
        if (!element) return
        element.crossOrigin = "anonymous";

        function run() {
            //user gesture has happened
            this.activated = true;

            //track current wave for canvas
            this.activeCanvas = this.activeCanvas || {};
            this.activeCanvas[canvas_id] = JSON.stringify(options);

            //track elements used so multiple elements use the same data
            this.activeElements[element_id] = this.activeElements[element_id] || {};
            if (this.activeElements[element_id].count) this.activeElements[element_id].count += 1;
            else this.activeElements[element_id].count = 1;

            const currentCount = this.activeElements[element_id].count;

            const audioCtx = setGlobal(element.id, 'audioCtx', new AudioContext());
            const analyser = setGlobal(element.id, 'analyser', audioCtx.createAnalyser());

            let source = getGlobal(element.id, 'source');
            if (source) {
                if (source.mediaElement !== element) {
                    source = audioCtx.createMediaElementSource(element);
                }
            } else {
                source = audioCtx.createMediaElementSource(element);
            }
            setGlobal(element.id, 'source', source);

            //beep test for ios
            const oscillator = audioCtx.createOscillator();
            oscillator.frequency.value = 1;
            oscillator.connect(audioCtx.destination);
            oscillator.start(0);
            oscillator.stop(0);

            source.connect(analyser);
            source.connect(audioCtx.destination);

            analyser.fftsize = 32768;
            const bufferLength = analyser.frequencyBinCount;
            const data = new Uint8Array(bufferLength);
            let frameCount = 1;

            function renderFrame() {
                //only run one wave visual per canvas
                if (JSON.stringify(options) !== this.activeCanvas[canvas_id]) {
                    return
                }

                //if the element or canvas go out of scope, stop animation
                if (!document.getElementById(element_id) || !document.getElementById(canvas_id))
                    return

                requestAnimationFrame(renderFrame);
                frameCount++;

                //check if this element is the last to be called 
                if (!(currentCount < this.activeElements[element_id].count)) {
                    analyser.getByteFrequencyData(data);
                    this.activeElements[element_id].data = data;
                }

                this.visualize(this.activeElements[element_id].data, canvas_id, options, frameCount);
            }

            renderFrame = renderFrame.bind(this);
            renderFrame();

        }


        const create = () => {
            //remove all events
            ["touchstart", "touchmove", "touchend", "mouseup", "click", "play"].forEach(event => {
                element.removeEventListener(event, create, { once: true });
            });

            run.call(waveContext);
        };

        if (this.activated || options['skipUserEventsWatcher']) {
            run.call(waveContext);
        } else {
            //wait for a valid user gesture 
            document.body.addEventListener("touchstart", create, { once: true });
            document.body.addEventListener("touchmove", create, { once: true });
            document.body.addEventListener("touchend", create, { once: true });
            document.body.addEventListener("mouseup", create, { once: true });
            document.body.addEventListener("click", create, { once: true });
            element.addEventListener("play", create, { once: true });
        }



    }

    function fromFile(file, options = {}) {
        //options
        if (!options.stroke) options.stroke = 10;

        let audio = new Audio();
        audio.src = file;

        let audioCtx = new AudioContext();
        let analyser = audioCtx.createAnalyser();

        let source = audioCtx.createMediaElementSource(audio);
        source.connect(analyser);

        analyser.fftSize = 64;
        let bufferLength = analyser.frequencyBinCount;

        let file_data;
        let temp_data = new Uint8Array(bufferLength);
        let getWave;
        let fdi = 0;
        let self = this;

        audio.addEventListener('loadedmetadata', async function () {

            while (audio.duration === Infinity) {
                await new Promise(r => setTimeout(r, 1000));
                audio.currentTime = 10000000 * Math.random();
            }

            audio.currentTime = 0;
            audio.play();
        });

        audio.onplay = function () {
            let findSize = (size) => {

                for (let range = 1; range <= 40; range++) {
                    let power = 2 ** range;

                    if (size <= power) return power;
                }

            };
            let d = audio.duration;
            audio.playbackRate = 16;

            d = d / audio.playbackRate;

            let drawRate = 20; //ms

            let size = ((d / (drawRate / 1000)) * (analyser.fftSize / 2));
            size = findSize(size);
            file_data = new Uint8Array(size);


            getWave = setInterval(function () {
                analyser.getByteFrequencyData(temp_data);

                for (let data in temp_data) {
                    data = temp_data[data];
                    file_data[fdi] = data;
                    fdi++;
                }

            }, drawRate);


        };

        audio.onended = function () {

            if (audio.currentTime === audio.duration && file_data !== undefined) {

                clearInterval(getWave);

                let canvas = document.createElement("canvas");
                canvas.height = window.innerHeight;
                canvas.width = window.innerWidth;

                self.visualize(file_data, canvas, options);
                let image = canvas.toDataURL("image/jpg");
                self.onFileLoad(image);

                canvas.remove();
            }

        };

    }

    function fromStream(stream, canvas_id, options = {}, connectDestination=true) {

        this.current_stream.id = canvas_id;
        this.current_stream.options = options;

        let audioCtx, analyser, source;
        if (!this.sources[stream.toString()]) {
            audioCtx = new AudioContext();
            analyser = audioCtx.createAnalyser();

            source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
            if (connectDestination) {
                source.connect(audioCtx.destination); //playback audio
            }
            
            this.sources[stream.toString()] = {
                "audioCtx": audioCtx,
                "analyser": analyser,
                "source": source
            };
        } else {
            cancelAnimationFrame(this.sources[stream.toString()].animation);
            audioCtx = this.sources[stream.toString()].audioCtx;
            analyser = this.sources[stream.toString()].analyser;
            source = this.sources[stream.toString()].source;
        }

        analyser.fftsize = 32768;
        let bufferLength = analyser.frequencyBinCount;
        this.current_stream.data = new Uint8Array(bufferLength);

        let self = this;
        let frameCount = 1;

        function renderFrame() {
            self.current_stream.animation = requestAnimationFrame(self.current_stream.loop);
            frameCount++;
            self.sources[stream.toString()].animation = self.current_stream.animation;
            analyser.getByteFrequencyData(self.current_stream.data);  

            self.visualize(self.current_stream.data, self.current_stream.id, self.current_stream.options, frameCount);
        }

        this.current_stream.loop = renderFrame;
        renderFrame();

    }

    function stopStream() {
        cancelAnimationFrame(this.current_stream.animation);
    }

    function playStream() {
        this.current_stream.loop();
    }

    var fromStream$1 = {
        fromStream,
        stopStream,
        playStream
    };

    var drawWave = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        const helper = new Helper(ctx);

        // data = helper.mutateData(data, "shrink", 200)
        data = helper.mutateData(data, "split", 4)[0];
        data = helper.mutateData(data, "scale", h);

        let points = helper.getPoints("line", w, [0, h], data.length, data, { offset: 100 });
        points.start = points.start.slice(0, points.end.length - 1);
        points.start.push([w, h]);
        points.start.push([0, h]);

        helper.drawPolygon(points.start, { lineColor: colors[0], color: colors[1], radius: (h * .008) });


    };

    var drawShine = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let cx = w / 2;
        let cy = h / 2;
        let r = h / 4;
        let percent = (h / 2 - r) / 255;
        let point_count = 512;
        let increase = (360 / point_count) * Math.PI / 180;

        for (let point = 1; point <= point_count; point++) {
            let p = data[600 % point]; //get value
            p *= percent;
            point++; //start at 1
            let a = point * increase;

            let sx = cx + r * Math.cos(a);
            let sy = cy + r * Math.sin(a);
            ctx.moveTo(sx, sy);

            let dx = cx + (r + p) * Math.cos(a);
            let dy = cy + (r + p) * Math.sin(a);
            ctx.lineTo(dx, dy);

        }
        ctx.stroke();

        if (options.colors[1]) {
            ctx.arc(cx, cy, r * .90, 0, 2 * Math.PI);
            ctx.fillStyle = options.colors[1];
            ctx.fill();
        }
    };

    var drawRing = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let cx = w / 2;
        let cy = h / 2;
        let r = (h - 10) / 2;
        let offset = r / 5;
        let percent = (r - offset) / 255;
        let point_count = 150;
        let increase = (360 / point_count) * Math.PI / 180;

        ctx.arc(cx, cy, r, 0, 2 * Math.PI, true);

        let fa = 0;
        let fx = cx + (r - (data[0] * percent)) * Math.cos(fa);
        let fy = cy + (r - (data[0] * percent)) * Math.sin(fa);
        ctx.moveTo(fx, fy);

        let q = 0;
        for (let point = 0; point < point_count; point++) {
            q += 1;
            if (point >= point_count / 2) {
                q -= 2;
            }

            let p = data[q]; //get value
            p *= percent;

            let a = point * increase;
            let x = cx + (r - p) * Math.cos(a);
            let y = cy + (r - p) * Math.sin(a);

            ctx.lineTo(x, y);
            ctx.arc(x, y, 2, 0, 2 * Math.PI);

        }
        ctx.lineTo(fx, fy);

        ctx.stroke();
        ctx.fillStyle = options.colors[1] || "#fff0";
        ctx.fill();
    };

    var drawBars = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let point_count = 64;
        let percent = h / 255;
        let increase = w / 64;
        let breakpoint = Math.floor(point_count / options.colors.length);

        for (let point = 1; point <= point_count; point++) {
            let p = data[point]; //get value
            p *= percent;

            let x = increase * point;

            ctx.moveTo(x, h);
            ctx.lineTo(x, h - p);

            if (point % breakpoint === 0) {
                let i = (point / breakpoint) - 1;
                ctx.strokeStyle = options.colors[i];
                ctx.stroke();
                ctx.beginPath();
            }

        }
    };

    var drawDualbars = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let percent = h / 255;
        let increase = w / 128;
        let point_count = 128;
        let min = 5;
        let breakpoint = Math.floor(point_count / options.colors.length);

        for (let point = 1; point <= point_count; point++) {
            let p = data[point]; //get value
            p += min;
            p *= percent;

            let x = increase * point;

            let mid = (h / 2) + (p / 2);

            ctx.moveTo(x, mid);
            ctx.lineTo(x, mid - p);

            if (point % breakpoint === 0) {
                let i = (point / breakpoint) - 1;
                ctx.strokeStyle = options.colors[i];
                ctx.stroke();
                ctx.beginPath();
            }

        }
    };

    var drawOrbs = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        const helper = new Helper(ctx);

        data = helper.mutateData(data, "organize").mids;
        data = helper.mutateData(data, "split", 2)[0];
        data = helper.mutateData(data, "shrink", 100);
        data = helper.mutateData(data, "mirror");
        data = helper.mutateData(data, "scale", h);
        data = helper.mutateData(data, "amp", .75);

        let points = helper.getPoints("line", w, [0, h / 2], data.length, data, { offset: 50 });
        points.start.forEach((start, i) => {
            helper.drawLine(start, points.end[i], { lineColor: colors[0] });

            helper.drawCircle(start, h * .01, { color: colors[1] || colors[0] });
            helper.drawCircle(points.end[i], h * .01, { color: colors[1] || colors[0] });
        });
    };

    var drawFlower = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let min = 5;
        let r = h / 4;
        let offset = r / 2;
        let cx = w / 2;
        let cy = h / 2;
        let point_count = 128;
        let percent = (r - offset) / 255;
        let increase = (360 / point_count) * Math.PI / 180;
        let breakpoint = Math.floor(point_count / options.colors.length);

        for (let point = 1; point <= point_count; point++) {
            let p = (data[point] + min) * percent;
            let a = point * increase;

            let sx = cx + (r - (p - offset)) * Math.cos(a);
            let sy = cy + (r - (p - offset)) * Math.sin(a);
            ctx.moveTo(sx, sy);

            let dx = cx + (r + p) * Math.cos(a);
            let dy = cy + (r + p) * Math.sin(a);
            ctx.lineTo(dx, dy);

            if (point % breakpoint === 0) {
                let i = (point / breakpoint) - 1;
                ctx.strokeStyle = options.colors[i];
                ctx.stroke();
                ctx.beginPath();
            }
        }

        ctx.stroke();
    };

    var drawFlowerBlocks = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;
        let r = h / 4;
        let cx = w / 2;
        let cy = h / 2;
        let point_count = 56;
        let percent = r / 255;
        let increase = (360 / point_count) * Math.PI / 180;

        for (let point = 1; point <= point_count; point++) {
            let p = (data[point]) * percent;
            let a = point * increase;

            let ax = cx + (r - (p / 2)) * Math.cos(a);
            let ay = cy + (r - (p / 2)) * Math.sin(a);
            ctx.moveTo(ax, ay);

            let bx = cx + (r + p) * Math.cos(a);
            let by = cy + (r + p) * Math.sin(a);
            ctx.lineTo(bx, by);

            let dx = cx + (r + p) * Math.cos(a + increase);
            let dy = cy + (r + p) * Math.sin(a + increase);
            ctx.lineTo(dx, dy);

            let ex = cx + (r - (p / 2)) * Math.cos(a + increase);
            let ey = cy + (r - (p / 2)) * Math.sin(a + increase);

            ctx.lineTo(ex, ey);
            ctx.lineTo(ax, ay);
        }

        if (options.colors[1]) {
            ctx.fillStyle = options.colors[1];
            ctx.fill();
        }

        ctx.stroke();
    };

    var drawBarsBlocks = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let percent = h / 255;
        let width = w / 64;

        for (let point = 0; point < 64; point++) {
            let p = data[point]; //get value
            p *= percent;
            let x = width * point;

            ctx.rect(x, h, width, -(p));
        }

        ctx.fillStyle = options.colors[1] || options.colors[0];
        ctx.stroke();
        ctx.fill();
    };

    var drawDualbarsBlocks = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let percent = h / 255;
        let width = w / 50;

        for (let point = 0; point <= 50; point++) {
            let p = data[point]; //get value
            p *= percent;
            let x = width * point;

            ctx.rect(x, (h / 2) + (p / 2), width, -(p));
        }

        if (options.colors[1]) {
            ctx.fillStyle = options.colors[1];
            ctx.fill();
        }

        ctx.stroke();
    };

    var drawStar = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let r = h / 4;
        let offset = r / 4;
        let cx = w / 2;
        let cy = h / 2;
        let point_count = 120;
        let percent = (r - offset - 35) / (255);
        let increase = (360 / point_count) * Math.PI / 180;

        let top = [];
        let bottom = [];

        for (let point = 1; point <= point_count; point++) {
            let p = ((data[200 % point])) * percent;
            let a = point * increase;

            let sx = cx + ((r) - p + offset) * Math.cos(a);
            let sy = cy + ((r) - p + offset) * Math.sin(a);
            ctx.moveTo(sx, sy);
            bottom.push({
                x: sx,
                y: sy
            });

            let dx = cx + (r + p + offset) * Math.cos(a);
            let dy = cy + (r + p + offset) * Math.sin(a);
            ctx.lineTo(dx, dy);
            top.push({
                x: dx,
                y: dy
            });

        }


        ctx.moveTo(top[0].x, top[0].y);
        for (let t in top) {
            t = top[t];

            ctx.lineTo(t.x, t.y);
        }
        ctx.closePath();

        ctx.moveTo(bottom[0].x, bottom[0].y);
        for (let b = bottom.length - 1; b >= 0; b++) {
            b = bottom[b];

            ctx.lineTo(b.x, b.y);
        }
        ctx.closePath();


        if (options.colors[1]) {
            ctx.fillStyle = options.colors[1];
            ctx.fill();
        }
        ctx.stroke();

        //inner color
        ctx.beginPath();
        ctx.moveTo(bottom[0].x, bottom[0].y);
        for (let b in bottom) {
            b = bottom[b];

            ctx.lineTo(b.x, b.y);
        }
        ctx.closePath();


        if (options.colors[2]) {
            ctx.fillStyle = options.colors[2];
            ctx.fill();
        }
        ctx.stroke();
    };

    var drawRoundWave = (functionContext) => {
        let { data, options, ctx, h, w } = functionContext;

        let r = h / 4;
        let cx = w / 2;
        let cy = h / 2;
        let point_count = 100;
        let percent = r / 255;
        let increase = (360 / point_count) * Math.PI / 180;
        let p = 0;

        // let z = (data[0] + min + offset) * percent;
        let sx = cx + (r + p) * Math.cos(0);
        let sy = cy + (r + p) * Math.sin(0);
        ctx.moveTo(sx, sy);

        for (let point = 1; point <= point_count; point++) {
            let p = (data[350 % point]) * percent;
            let a = point * increase;

            let dx = cx + (r + p) * Math.cos(a);
            let dy = cy + (r + p) * Math.sin(a);
            ctx.lineTo(dx, dy);
        }

        ctx.closePath();
        ctx.stroke();

        if (options.colors[1]) {
            ctx.fillStyle = options.colors[1];
            ctx.fill();
        }
    };

    var drawRings = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        let helper = new Helper(ctx);
        let minDimension = (h < w) ? h : w;

        data = helper.mutateData(data, "organize");
        data = [data.mids, data.vocals];

        data[0] = helper.mutateData(data[0], "scale", minDimension / 4);
        data[1] = helper.mutateData(data[1], "scale", minDimension / 8);

        data[0] = helper.mutateData(data[0], "shrink", 1 / 5);
        data[0] = helper.mutateData(data[0], "split", 2)[0];

        data[0] = helper.mutateData(data[0], "reverb");
        data[1] = helper.mutateData(data[1], "reverb");


        let outerCircle = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data[0].length, data[0]);
        let innerCircle = helper.getPoints("circle", minDimension / 4, [w / 2, h / 2], data[1].length, data[1]);

        helper.drawPolygon(outerCircle.end, { close: true, radius: 4, lineColor: colors[0], color: colors[1] });
        helper.drawPolygon(innerCircle.end, { close: true, radius: 4, lineColor: colors[2], color: colors[3] });

        let middle = ((minDimension / 4) + (minDimension / 2)) / 2;
        let largerInner = data[1] = helper.mutateData(data[1], "scale", ((minDimension / 4) - (minDimension / 2)));
        let innerBars = helper.getPoints("circle", middle, [w / 2, h / 2], data[1].length, largerInner);
        innerBars.start.forEach((start, i) => {
            helper.drawLine(start, innerBars.end[i], { lineColor: colors[4] || colors[2] });
        });
    };

    var drawShineRings = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;

        let helper = new Helper(ctx);
        let minDimension = (h < w) ? h : w;

        data = helper.mutateData(data, "organize");
        data.vocals = helper.mutateData(data.vocals, "scale", (minDimension / 2) / 2);
        data.base = helper.mutateData(data.base, "scale", (minDimension / 2) / 2);

        let outerBars = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.vocals.length, data.vocals);
        let innerWave = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.vocals.length, data.vocals, { offset: 100 });
        let thinLine = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.base.length, data.base, { offset: 100 });

        outerBars.start.forEach((start, i) => {
            helper.drawLine(start, outerBars.end[i], { lineColor: colors[0] });
        });

        helper.drawPolygon(innerWave.start, { close: true, lineColor: colors[1], color: colors[3], radius: 5 });
        helper.drawPolygon(thinLine.start, { close: true, lineColor: colors[2], color: colors[4], radius: 5 });
    };

    var drawCubes = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        let helper = new Helper(ctx);

        data = helper.mutateData(data, "organize").base;

        data = helper.mutateData(data, "shrink", 20).slice(0, 19);
        data = helper.mutateData(data, "scale", h);

        let points = helper.getPoints("line", w, [0, h], data.length, data);

        let spacing = 5;
        let squareSize = (w / 20) - spacing;
        let colorIndex = 0;

        points.start.forEach((start, i) => {
            let squareCount = Math.ceil(data[i] / squareSize);

            //find color stops from total possible squares in bar 
            let totalSquares = (h - (spacing * (h / squareSize))) / squareSize;
            let colorStop = Math.ceil(totalSquares / colors.length);

            for (let j = 1; j <= squareCount; j++) {
                let origin = [start[0], (start[1] - (squareSize * j) - (spacing * j))];
                helper.drawSquare(origin, squareSize, { color: colors[colorIndex], lineColor: "black" });
                if (j % colorStop == 0) {
                    colorIndex++;
                    if (colorIndex >= colors.length) colorIndex = colors.length - 1;
                }
            }
            colorIndex = 0;
        });
    };

    var drawBigBars = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        const helper = new Helper(ctx);

        data = helper.mutateData(data, "organize").vocals;
        data = helper.mutateData(data, "shrink", 10);
        data = helper.mutateData(data, "scale", h);
        data = helper.mutateData(data, "amp", 1);
        let points = helper.getPoints("line", w, [0, h / 2], data.length, data, { offset: 50 });

        let colorIndex = 0;
        let colorStop = Math.ceil(data.length / colors.length);
        points.start.forEach((start, i) => {
            if ((i + 1) % colorStop == 0) colorIndex++;
            helper.drawRectangle(start, data[i], w / data.length, { color: colors[colorIndex] });
        });

    };

    var drawShockwave = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;

        let helper = new Helper(ctx);

        data = helper.mutateData(data, "shrink", 300);
        data = helper.mutateData(data, "scale", h / 2);
        data = helper.mutateData(data, "split", 4).slice(0, 3);

        let colorIndex = 0;
        data.forEach((points) => {
            let wavePoints = helper.getPoints("line", w, [0, h / 2], points.length, points);
            helper.drawPolygon(wavePoints.end, { lineColor: colors[colorIndex], radius: (h * .015) });

            let invertedPoints = helper.getPoints("line", w, [0, h / 2], points.length, points, { offset: 100 });
            helper.drawPolygon(invertedPoints.start, { lineColor: colors[colorIndex], radius: (h * .015) });
            colorIndex++;
        });
    };

    var drawFireworks = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        const helper = new Helper(ctx);

        data = helper.mutateData(data, "shrink", 200).slice(0, 120);
        data = helper.mutateData(data, "mirror");
        data = helper.mutateData(data, "scale", (h / 4) + ((h / 4) * .35));

        let points = helper.getPoints("circle", h / 2, [w / 2, h / 2], data.length, data, { offset: 35, rotate: 270 });

        points.start.forEach((start, i) => {
            helper.drawLine(start, points.end[i]);
        });

        helper.drawPolygon(points.start, { close: true });

        points.end.forEach((end, i) => {
            helper.drawCircle(end, h * .01, { color: colors[0] });
        });
    };

    var drawStatic = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let helper = new Helper(ctx);

        data = helper.mutateData(data, "shrink", 1 / 8);
        data = helper.mutateData(data, "split", 2)[0];
        data = helper.mutateData(data, "scale", h);

        let points = helper.getPoints("line", w, [0, h / 2], data.length, data, { offset: 50 });
        let prevPoint = null;
        points.start.forEach((start, i) => {
            if (prevPoint) {
                helper.drawLine(prevPoint, start);
            }
            helper.drawLine(start, points.end[i]);
            prevPoint = points.end[i];
        });


    };

    var drawWeb = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let { colors } = options;
        const helper = new Helper(ctx);
        let minDimension = (h < w) ? h : w;

        data = helper.mutateData(data, "shrink", 100);
        data = helper.mutateData(data, "split", 2)[0];
        data = helper.mutateData(data, "scale", h / 4);

        let dataCopy = data;

        let points = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.length, data);
        helper.drawPolygon(points.end, { close: true });

        points.start.forEach((start, i) => {
            helper.drawLine(start, points.end[i]);
        });

        data = helper.mutateData(data, "scale", .7);
        points = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.length, data);
        helper.drawPolygon(points.end, { close: true });

        data = helper.mutateData(data, "scale", .3);
        points = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.length, data);
        helper.drawPolygon(points.end, { close: true });

        helper.drawCircle([w / 2, h / 2], minDimension / 2, { color: colors[2] });

        dataCopy = helper.mutateData(dataCopy, "scale", 1.4);
        points = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], dataCopy.length, dataCopy);
        points.end.forEach((end, i) => {
            helper.drawCircle(end, minDimension * .01, { color: colors[1], lineColor: colors[1] || colors[0] });
        });
    };

    var drawStitches = (functionContext) => {
        let { data, options, ctx, h, w, Helper } = functionContext;
        let helper = new Helper(ctx);
        let minDimension = (h < w) ? h : w;

        data = helper.mutateData(data, "shrink", 200);
        data = helper.mutateData(data, "split", 2)[0];
        data = helper.mutateData(data, "scale", h / 2);

        let points = helper.getPoints("circle", minDimension / 2, [w / 2, h / 2], data.length, data, { offset: 50 });

        helper.drawPolygon(points.end, { close: true });
        helper.drawPolygon(points.start, { close: true });

        for (let i = 0; i < points.start.length; i += 1) {
            let start = points.start[i];
            i++;
            let end = points.end[i] || points.end[0];

            helper.drawLine(start, end);
            helper.drawLine(end, points.start[i + 1] || points.start[0]);
        }
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var origami_1 = createCommonjsModule(function (module, exports) {
    /*!
     * Origami.js 0.5.0
     * https://origamijs.com/
     *
     * Copyright Raphael Amorim 2016
     * Released under the GPL-4.0 license
     *
     * Date: 2016-09-23T03:42Z
     */

    (function( window ) {

    /**
     * Config object: Maintain internal state
     * Later exposed as Origami.config
     * `config` initialized at top of scope
     */

    var Origami = {
      // Current Paper
      paper: null
    };

    var config = {
      // Document Styles
      documentStyles: [],

      // Virtual Styles
      virtualStyles: {},

      // All contexts saved
      contexts: [],

      // Origami Shapes Defaults
      defaults: {
        arc: {
          background: 'rgba(0, 0, 0, 0)',
          strokeStyle: 'rgba(0, 0, 0, 0)',
          lineWidth: null,
        },
        rect: {
          background: 'rgba(0, 0, 0, 0)',
          strokeStyle: 'rgba(0, 0, 0, 0)',
          lineWidth: null,
        },
        polygon: {
          background: 'rgba(0, 0, 0, 0)',
          strokeStyle: 'rgba(0, 0, 0, 0)',
          lineWidth: null,
        },
        line: {
          strokeStyle: 'rgba(0, 0, 0, 0)',
          lineWidth: null,
        },
        text: {
          font: '14px Helvetica',
          strokeStyle: 'rgba(0, 0, 0, 0)',
          color: '#000',
          lineWidth: null,
        }
      }
    };

    var prefix = "[origami.js]";

    Origami.warning = function warning(message, obj){
        if (console && console.warn)
            console.warn(prefix, message, obj);
    };

    Origami.error = function error(message){
        throw new Error(prefix.concat(' ' + message));
    };
    Origami.init = function(el) {
      if (el.canvas) {
        el = el.canvas;
      } else {
        el = document.querySelector(el);
      }

      if (!el)
        this.error('Please use a valid selector or canvas context');

      var existentContext = exists(el, config.contexts);
      if (existentContext) {
        this.paper = existentContext;
        return this;
      }

      if (!el.getContext)
        this.error('Please verify if it\'s a valid canvas element');

      el.width = el.clientWidth;
      el.height = el.clientHeight;
      var context = el.getContext('2d');
      var current = {
        element: el,
        queue: [],
        index: config.contexts.length,
        flip: false,
        frame: null,
        ctx: context,
        width: el.width,
        height: el.height,
      };

      config.contexts.push(current);
      this.paper = current;
      return this;
    };

    Origami.styles = function() {
      if (!config.virtualStyles.length)
        defineDocumentStyles();

      var selectors = arguments;
      if (!selectors.length) {
        config.virtualStyles['empty'] = true;
        return this;
      }

      for (var i = 0; i < selectors.length; i++) {
        var style = styleRuleValueFrom(selectors[i], (config.documentStyles[0] || []));
        config.virtualStyles[selectors[i]] = style;
      }
      return this;
    };

    Origami.getPaper = function() {
      return this.paper;
    };

    Origami.canvasCtx = function() {
      return this.paper.ctx;
    };

    Origami.getContexts = function() {
      return config.contexts;
    };

    Origami.cleanContexts = function() {
      config.contexts = [];
    };

    Origami.createComponent = function(component, fn) {
      Origami[component] = function(props) {
        fn.bind(this, this, props)();
        return this;
      };
    };

    Origami.fn = {};

    Origami.draw = function(options) {
      var self = this,
        customRender = false,
        ctx = self.paper.ctx;

      if (typeof(options) === 'string') {
        customRender = new origami.fn[options](self.paper);
        self.paper['ctx'] = customRender;
      }

      var abs = new Screen(self.paper),
        queueList = self.paper.queue;

      for (var i = 0; i < queueList.length; i++) {
        if (queueList[i].loaded === false || queueList[i].failed) {
          Origami.warning('couldn\'t able to load:', queueList[i].params);
        }
        abs[queueList[i].assign](queueList[i].params);
      }
      self.paper.queue = [];

      if (customRender) {
        customRender.draw();
        self.paper.ctx = ctx;
      }

      if (typeof(options) === 'function')
        options();
    };

    Origami.load = function(fn) {
      var mOrigami = clone(this);
      mOrigami.paper = this.paper;
      var loadInterval = setInterval(function() {
        var dataLoad = mOrigami.paper.queue.filter(function(item) {
          return (item.loaded === false && !item.failed);
        });

        // When already loaded
        if (!dataLoad.length) {
          clearInterval(loadInterval);
          fn.bind(mOrigami, mOrigami)();
        }
      }, 1);
    };

    function Queue(assign, params, loaded) {
      this.paper.queue.push({
        assign: assign,
        params: params,
        loaded: loaded
      });
    }

    var queue = Queue.bind(Origami);

    // Utilities.js

    var hasOwn = Object.prototype.hasOwnProperty;

    /**
     * Check if element exists in a Array of NodeItems
     * @param {NodeItem} current nodeItem to check
     * @param {Array} array of NodeItems
     * @returns {NodeItem} NodeItem exitent in array
     */
    function exists(el, arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].element.isEqualNode(el))
          return arr[i];
      }
      return false;
    }

    /**
     * Filter arguments by rules
     * @param {Array} methods arguments
     * @param {Object} rules to apply
     * @returns {Object} arguments filtered
     */
    function argsByRules(argsArray, rules) {
      var params = rules || ['x', 'y', 'width', 'height'],
        args = {};

      for (var i = 0; i < argsArray.length; i++) {
        if (typeof(argsArray[i]) === "object")
          args["style"] = argsArray[i];
        else
        if (params.length)
          args[params.shift()] = argsArray[i];
      }

      args.style = normalizeStyle(args.style);

      if ((typeof(args.x) === 'string') && (typeof(args.y) === 'string'))
        args = smartCoordinates(args);

      return args;
    }

    function getBorderStyleObject(prop) {
      return normalizeStyle({border: prop});
    }

    function normalizeStyle(style) {
      if (!style)
        style = {};

      var borderSize = (style.borderSize || null),
        borderColor = (style.borderColor || null),
        borderStyle = (style.borderStyle || []);

      if (style.border) {
        var border = [],
          borderString = style.border;

        // 0 - Size: [0-9]px
        border = border.concat(style.border.match(/[0-9]*\.?[0-9]px?/i));
        borderString = borderString.replace(/[0-9]*\.?[0-9]px?/i, '');

        // 1 - Style
        border = border.concat(borderString.match(/solid|dashed|dotted/i));
        borderString = borderString.replace(/solid|dashed|dotted/i, '');

        // 2 - Color
        border = border.concat(borderString.match(/[^\s]+/i));

        if (!borderSize)
          borderSize = border[0];
        if (!borderColor)
          borderColor = border[2];

        borderStyle = border[1];
      }

      if (borderSize)
        borderSize = borderSize.replace(/[^0-9]/g, '');

      if (typeof(borderStyle) === 'string') {
        if (borderStyle === 'dashed')
          borderStyle = [12];
        else if (borderStyle === 'dotted')
          borderStyle = [3];
        else
          borderStyle = [];
      }

      style['borderSize'] = borderSize;
      style['borderStyle'] = borderStyle;
      style['borderColor'] = borderColor;
      return style;
    }

    /**
     * Return args object with new coordinates based on behavior
     * @returns {Object} args
     */
    function smartCoordinates(args) {
      var x = args.x,
        y = args.y;

      var paper = Origami.getPaper(),
        elmWidth = paper.element.width,
        elmHeight = paper.element.height,
        radius = (args.r || 0);

      var width = (args.width || radius),
        height = (args.height || width);

      var axis = {
        x: [ 'right', 'center', 'left' ],
        y: [ 'top', 'center', 'bottom' ]
      };

      if (axis.x.indexOf(x) !== -1) {
        if (x === 'right')
          x = Math.floor(elmWidth - width);
        else if (x === 'center')
          if (radius)
            x = Math.floor(elmWidth / 2);
          else
            x = Math.floor((elmWidth / 2) - (width / 2));
        else if (x === 'left')
          x = radius;
      } else if ((x + '').substr(-1) === '%') {
        x = (elmWidth * parseInt(x, 10)) / 100;
      } else {
        x = 0;
      }

      if (axis.y.indexOf(y) !== -1) {
        if (y === 'top')
          y = radius;
        else if (y === 'center')
          if (radius)
            y = Math.floor(elmHeight / 2);
          else
            y = Math.floor((elmHeight / 2) - (height / 2));
        else if (y === 'bottom')
          y = Math.floor(elmHeight - height);
      } else if ((y + '').substr(-1) === '%') {
        y = (elmHeight * parseInt(y, 10)) / 100;
      } else {
        y = 0;
      }

      args.y = y;
      args.x = x;
      return args;
    }

    /**
     * Return all documentStyles to a especified origami context
     * @returns undefined
     */
    function defineDocumentStyles() {
      for (var i = 0; i < document.styleSheets.length; i++) {
        var mysheet = document.styleSheets[i],
          myrules = mysheet.cssRules ? mysheet.cssRules : mysheet.rules;
        config.documentStyles.push(myrules);
      }
    }

    /**
     * Merge defaults with user options
     * @param {Object} defaults Default settings
     * @param {Object} options User options
     * @returns {Object} Merged values of defaults and options
     */
    function extend(a, b, undefOnly) {
      for (var prop in b) {
        if (hasOwn.call(b, prop)) {

          // Avoid "Member not found" error in IE8 caused by messing with window.constructor
          // This block runs on every environment, so `global` is being used instead of `window`
          // to avoid errors on node.
          if (prop !== "constructor" || a !== commonjsGlobal) {
            if (b[prop] === undefined) {
              delete a[prop];
            } else if (!(undefOnly && typeof a[prop] !== "undefined")) {
              a[prop] = b[prop];
            }
          }
        }
      }
      return a;
    }

    /**
     * Get Style Rule from a specified element
     * @param {String} selector from element
     * @param {Array} Document Style Rules
     * @returns {Object} Merged values of defaults and options
     */
    function styleRuleValueFrom(selector, documentStyleRules) {
      for (var j = 0; j < documentStyleRules.length; j++) {
        if (documentStyleRules[j].selectorText && documentStyleRules[j].selectorText.toLowerCase() === selector) {
          return documentStyleRules[j].style;
        }
      }
    }

    /**
     * Clone a object
     * @param {Object} object
     * @returns {Object} cloned object
     */
    function clone(obj) {
      if (null == obj || "object" != typeof obj) return obj;
      var copy = obj.constructor();
      for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
      }
      return copy;
    }

    function Screen(currentContext) {
      this.paper = currentContext;
    }

    Screen.prototype.translate = function(params) {
      this.paper.ctx.translate(params.x, params.y);
    };

    Screen.prototype.background = function(params) {
      this.paper.element.style.backgroundColor = params.color;
    };

    Screen.prototype.restore = function() {
      this.paper.ctx.restore();
    };

    Screen.prototype.save = function() {
      this.paper.ctx.save();
    };

    Screen.prototype.composition = function(params) {
      this.paper.ctx.globalCompositeOperation = params.globalComposite;
    };

    Screen.prototype.rotate = function(params) {
      this.paper.ctx.rotate(params.degrees);
    };

    Screen.prototype.scale = function(params) {
      this.paper.ctx.scale(params.width, params.height);
    };

    Screen.prototype.flip = function(params) {
      this.paper.flip = 'horizontal';
      if (params.type && typeof(params.type) === 'string')
        this.paper.flip = params.type;
    };

    Screen.prototype.flipEnd = function() {
      this.paper.flip = false;
    };

    Screen.prototype.clear = function() {
      this.paper.ctx.clearRect(0, 0, this.paper.width, this.paper.height);
    };

    function ArcShape(params) {
      var args = params.args,
        style = args.style,
        def = config.defaults.arc;

      this.paper.ctx.beginPath();
      this.paper.ctx.setLineDash(style.borderStyle);
      this.paper.ctx.arc(args.x, args.y, (args.r || def.radius), (args.sAngle || 0), (args.eAngle || 2 * Math.PI));
      this.paper.ctx.fillStyle = (style.background || style.bg) ? (style.background || style.bg) : def.background;
      this.paper.ctx.fill();
      this.paper.ctx.lineWidth = (style.borderSize) ? style.borderSize : def.lineWidth;
      this.paper.ctx.strokeStyle = (style.borderColor) ? style.borderColor : def.strokeStyle;
      this.paper.ctx.stroke();
      this.paper.ctx.setLineDash([]);
      this.paper.ctx.closePath();
    }

    Screen.prototype.arc = ArcShape;

    Origami.arc = function() {
      var args = [].slice.call(arguments);
      args = argsByRules(args, ['x', 'y', 'r', 'sAngle', 'eAngle']);

      queue('arc', {
        args: args
      });
      return this;
    };

    function ImageShape(params) {
      var image = params.image,
        x = params.x,
        y = params.y,
        width = params.width,
        height = params.height;

      this.paper.ctx.save();
      if (this.paper.flip) {
        if (this.paper.flip === 'horizontal') {
          this.paper.ctx.scale(-1, 1);
          width = width * -1;
          x = x * -1;
        }
        if (this.paper.flip === 'vertical') {
          this.paper.ctx.scale(1, -1);
          height = height * -1;
          y = y * -1;
        }
      }

      this.paper.ctx.beginPath();
      this.paper.ctx.drawImage(image, Math.floor((x || 0)), Math.floor((y || 0)), width, height);
      this.paper.ctx.closePath();
      this.paper.ctx.restore();
    }

    Screen.prototype.image = ImageShape;

    Origami.image = function(image, x, y, width, height) {
      var self = this;
      if (!image)
        return this;

      if (typeof(image) === 'string') {
        var img = new Image();
        img.src = image;
        image = img;
      }

      var item = {
        image: image,
        x: x,
        y: y,
        width: width,
        height: height
      };

      if ((typeof(item.x) === 'string') && (typeof(item.y) === 'string'))
        item = smartCoordinates(item);

      if (image.complete) {
        item.width = width || image.naturalWidth;
        item.height = height || image.naturalHeight;

        queue('image', item);
        return self;
      }

      queue('image', item, false);
      var reference = (self.paper.queue.length - 1),
        currentQueue = config.contexts[this.paper.index].queue[reference];

      image.addEventListener('load', function() {
        if (!currentQueue)
          return false;
        currentQueue.params.width = (item.width || image.naturalWidth);
        currentQueue.params.height = (item.height || image.naturalHeight);
        currentQueue.loaded = true;
      });

      image.addEventListener('error', function() {
        if (!currentQueue)
          return false;
        currentQueue.failed = true;
      });

      return self;
    };

    function LineShape(params) {
      var def = config.defaults.line,
          style = params.style,
          pointA = params.pointA,
          pointB = params.pointB;

      this.paper.ctx.beginPath();
      this.paper.ctx.setLineDash(style.borderStyle);
      this.paper.ctx.moveTo((pointA.x || 0), (pointA.y || 0));
      this.paper.ctx.lineTo((pointB.x || 0), (pointB.y || 0));

      this.paper.ctx.lineWidth = (style.borderSize) ? style.borderSize : def.lineWidth;
      this.paper.ctx.strokeStyle = (style.borderColor) ? style.borderColor : def.strokeStyle;
      this.paper.ctx.stroke();
      this.paper.ctx.setLineDash([]);
      this.paper.ctx.closePath();
    }

    Screen.prototype.line = LineShape;

    Origami.line = function(pointA, pointB, style) {
      style = normalizeStyle(style);

      queue('line', {
        pointA: pointA,
        pointB: pointB,
        style: style
      });
      return this;
    };

    function PolygonShape(params) {
      var args = params.args,
        style = params.style,
        def = config.defaults.polygon;

      this.paper.ctx.beginPath();
      this.paper.ctx.setLineDash(style.borderStyle);
      this.paper.ctx.fillStyle = (style.background) ? style.background : def.background;
      this.paper.ctx.lineWidth = (style.borderSize) ? style.borderSize : def.lineWidth;
      this.paper.ctx.strokeStyle = (style.borderColor) ? style.borderColor : def.strokeStyle;

      for (var p = 0; p < args.length; p++) {
        if (!args[p].x)
          continue;

        if (p)
          this.paper.ctx.lineTo(args[p].x, args[p].y);
        else
          this.paper.ctx.moveTo(args[p].x, args[p].y);
      }

      this.paper.ctx.fill();
      this.paper.ctx.stroke();
      this.paper.ctx.setLineDash([]);
      this.paper.ctx.closePath();
    }

    Screen.prototype.polygon = PolygonShape;

    Origami.polygon = function() {
      var args = [].slice.call(arguments),
        settedArgs = argsByRules(args);

      queue('polygon', {
        style: settedArgs.style,
        args: args
      });
      return this;
    };

    function RectShape(params) {
      var def = config.defaults.rect,
        style = params.style,
        args = params.args;

      this.paper.ctx.beginPath();
      this.paper.ctx.setLineDash(style.borderStyle);
      this.paper.ctx.fillStyle = (style.background) ? style.background : def.background;
      this.paper.ctx.fillRect(args.x, args.y, args.width, (args.height || args.width));

      this.paper.ctx.lineWidth = (style.borderSize) ? style.borderSize : def.lineWidth;
      this.paper.ctx.strokeStyle = (style.borderColor) ? style.borderColor : def.strokeStyle;
      this.paper.ctx.strokeRect(args.x, args.y, args.width, (args.height || args.width));
      this.paper.ctx.setLineDash([]);
      this.paper.ctx.closePath();
    }

    Screen.prototype.rect = RectShape;

    Origami.rect = function() {
      var args = [].slice.call(arguments);
      args = argsByRules(args);

      queue('rect', {
        style: args.style,
        args: args
      });
      return this;
    };

    Origami.border = function() {
      var args = [].slice.call(arguments);
      args = argsByRules(args);

      queue('rect', {
        style: args.style,
        args: {
          x: 0,
          y: 0,
          width: this.paper.width,
          height: this.paper.height
        }
      });
      return this;
    };

    function CSSShape(style) {
      var self = this,
        style = config.virtualStyles[style];

      if (!style)
        return self;

      // TODO: Draw in all canvas
      var data = '<svg xmlns="http://www.w3.org/2000/svg" width="' +
        self.paper.width + 'px" height="' + self.paper.height + 'px">' +
        '<foreignObject width="100%" height="100%">' +
        '<div xmlns="http://www.w3.org/1999/xhtml">' +
        '<div style="' + style.cssText + '"></div>' +
        '</div></foreignObject>' +
        '</svg>';

      var DOMURL = window.URL || window.webkitURL || window,
        img = new Image(),
        svg = new Blob([data], {
          type: 'image/svg+xml;charset=utf-8'
        });

      var url = DOMURL.createObjectURL(svg);
      img.src = url;

      img.addEventListener('load', function() {
        self.paper.ctx.beginPath();
        self.paper.ctx.drawImage(img, 0, 0);
        DOMURL.revokeObjectURL(url);
        self.paper.ctx.closePath();
      });

      return self;
    }

    Screen.prototype.CSSShape = CSSShape;

    Origami.shape = function(style) {
      queue('CSSShape', style);
      return this;
    };

    function SpriteShape(params) {
      var properties = params.properties,
        dw = params.width / properties.frames;

      drawSprite.call(this, {
        image: params.image,
        posX: 0,
        posY: 0,
        frame: properties.frames,
        loop: properties.loop,
        width: dw,
        widthTotal: params.width,
        height: params.height,
        dx: params.x,
        dy: params.y,
        speed: properties.speed,
        animation: null
      });
    }

    function drawSprite(sprite) {
      var self = this;

      if (sprite.posX === sprite.widthTotal) {
        if (sprite.loop === false) {
          window.cancelAnimationFrame(sprite.animation);
          return;
        }
        sprite.posX = 0;
      }

      self.paper.ctx.clearRect(sprite.dx, sprite.dy, sprite.width, sprite.height);

      self.paper.ctx.beginPath();
      self.paper.ctx.drawImage(sprite.image, sprite.posX, sprite.posY,
        sprite.width, sprite.height, sprite.dx, sprite.dy,
        sprite.width, sprite.height);
      self.paper.ctx.closePath();

      sprite.posX = sprite.posX + sprite.width;

      setTimeout(function() {
        sprite.animation = window.requestAnimationFrame(drawSprite.bind(self, sprite));
      }, sprite.speed);
    }

    Screen.prototype.sprite = SpriteShape;

    Origami.sprite = function(x, y, properties) {
      var self = this;

      if (!properties || !properties.src)
        return this;

      var image = new Image();
        (properties.frames || 0);
        (properties.loop || true);
        (properties.speed || 10);

      image.src = properties.src;

      var item = {
        x: x,
        y: y,
        image: image,
        properties: properties,
        width: 0,
        height: 0
      };

      if (image.complete) {
        item.width = image.naturalWidth;
        item.height = image.naturalHeight;
        queue('sprite', item);
        return self;
      }

      queue('sprite', item, false);
      var reference = (self.paper.queue.length - 1),
        currentQueue = config.contexts[this.paper.index].queue[reference];

      image.addEventListener('load', function() {
        if (!currentQueue)
          return false;
        currentQueue.params.width = image.naturalWidth;
        currentQueue.params.height = image.naturalHeight;
        currentQueue.loaded = true;
      });

      image.addEventListener('error', function() {
        if (!currentQueue)
          return false;
        currentQueue.failed = true;
      });

      return this;
    };

    function TextShape(params) {
      var def = config.defaults.text,
        text = params.text,
        x = params.x,
        y = params.y,
        style = params.style;

      this.paper.ctx.beginPath();
      this.paper.ctx.setLineDash(style.borderStyle);
      this.paper.ctx.lineWidth = (style.borderSize) ? style.borderSize : def.lineWidth;
      this.paper.ctx.strokeStyle = (style.borderColor) ? style.borderColor : def.strokeStyle;
      this.paper.ctx.font = (style.font || def.font);
      this.paper.ctx.fillStyle = (style.color || def.color);
      this.paper.ctx.textAlign = (style.align || def.align);
      this.paper.ctx.fillText(text, x, y);
      this.paper.ctx.strokeText(text, x, y);
      this.paper.ctx.fill();
      this.paper.ctx.stroke();
      this.paper.ctx.setLineDash([]);
      this.paper.ctx.closePath();
    }

    Screen.prototype.text = TextShape;

    Origami.text = function(text, x, y, style) {
      style = normalizeStyle(style);

      var item = {
        text: text,
        x: x,
        y: y,
        style: style
      };

      if ((typeof(item.x) === 'string') && (typeof(item.y) === 'string'))
        item = smartCoordinates(item);

      queue('text', item);
      return this;
    };

    function ChartLine(config) {
      var ctx = this.paper.ctx,
        width = this.paper.width,
        height = this.paper.height;

      var line = getBorderStyleObject(config.line || "1px solid #000");
      var lineVariance = 2;

      var xPadding = 40;
      var yPadding = 40;
      var data = [];

      var gridLines = {
        vertical: true,
        horizontal: true
      };

      if (config.gridLines) {
        if (config.gridLines.vertical === false)
          gridLines.vertical = false;

        if (config.gridLines.horizontal === false)
          gridLines.horizontal = false;
      }

      for (var i = 0; i < config.labels.length; i++) {
        data.push({
          X: config.labels[i],
          Y: config.data[i]
        });
      }

      function getMaxY() {
        var max = 0;

        for (var i = 0; i < data.length; i++) {
          if (data[i].Y > max) {
            max = data[i].Y;
          }
        }

        max += 10 - max % 10;
        return max;
      }

      function getXPixel(val) {
        return ((width - xPadding) / data.length) * val + xPadding;
      }

      function getYPixel(val) {
        return height - (((height - yPadding) / getMaxY()) * val) - yPadding;
      }

      ctx.lineWidth = 0.8;
      ctx.strokeStyle = '#999';
      ctx.font = 'normal 12px Helvetica';
      ctx.fillStyle = '#5e5e5e';
      ctx.textAlign = "center";

      ctx.beginPath();
      ctx.moveTo(xPadding, yPadding / lineVariance);
      ctx.lineTo(xPadding, height - yPadding);
      ctx.lineTo(width - (xPadding / lineVariance), height - yPadding);
      ctx.stroke();

      // Data
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (var i = 0; i < getMaxY(); i += 10) {
        if (gridLines.horizontal) {
          ctx.beginPath();
          ctx.lineWidth = 0.8;
          ctx.strokeStyle = '#e7e7e7';
          ctx.moveTo(xPadding - 5, getYPixel(i));
          ctx.lineTo(width - (xPadding / lineVariance), getYPixel(i));
          ctx.stroke();
        }

        ctx.fillText(i, xPadding - 10, getYPixel(i));
      }

      // Labels
      ctx.textAlign = "left";
      for (var i = 0; i < data.length; i++) {
        if (gridLines.vertical) {
          ctx.beginPath();
          ctx.lineWidth = 0.8;
          ctx.strokeStyle = '#e7e7e7';
          ctx.moveTo(getXPixel(i), height - yPadding + 10);
          ctx.lineTo(getXPixel(i), yPadding / lineVariance);
          ctx.stroke();
        }

        ctx.fillText(data[i].X, getXPixel(i), height - yPadding + 20);
      }

      ctx.beginPath();
      ctx.lineWidth = line.borderSize;
      ctx.setLineDash(line.borderStyle);
      ctx.strokeStyle = line.borderColor;
      ctx.moveTo(getXPixel(0), getYPixel(data[0].Y));

      for (var i = 1; i < data.length; i++) {
        ctx.lineTo(getXPixel(i), getYPixel(data[i].Y));
      }
      ctx.stroke();
      ctx.setLineDash([]);

      if (config.points) {
        ctx.fillStyle = (config.pointsColor) ? config.pointsColor : 'rgb(75,75,75)';
        for (var i = 0; i < data.length; i++) {
          ctx.beginPath();
          ctx.arc(getXPixel(i), getYPixel(data[i].Y), 3, 0, Math.PI * 2, true);
          ctx.fill();
        }
      }
    }

    Screen.prototype.chartLine = ChartLine;

    Origami.chartLine = function(config) {
      queue('chartLine', config);
      return this;
    };
    // Resource.js

    Origami.background = function(color) {
      queue('background', {
        color: color
      });
      return this;
    };

    Origami.restore = function() {
      queue('restore');
      return this;
    };

    Origami.save = function() {
      queue('save');
      return this;
    };

    Origami.composition = function(globalComposite) {
      queue('composition', {
        globalComposite: globalComposite
      });
      return this;
    };

    Origami.translate = function(x, y) {
      if (x === undefined || x === null) {
        x = 'reset';
      }

      if (typeof(x) === 'string') {
        if (x === 'center') {
          x = context.width / 2;
          y = context.height / 2;
        }
        if (x === 'reset') {
          x = -context.width / 2;
          y = -context.height / 2;
        }
      }

      queue('translate', {
        x: x,
        y: y
      });
      return this;
    };

    Origami.rotate = function(degrees) {
      if (typeof(degrees) === 'undefined')
        degrees = 'slow';

      if (typeof(degrees) === 'string') {
        // Slow
        if (degrees === 'slow')
          degrees = ((2 * Math.PI) / 60) * new Date().getSeconds() +
          ((2 * Math.PI) / 60000) * new Date().getMilliseconds();

        // Normal
        else if (degrees === 'normal')
          degrees = ((2 * Math.PI) / 30) * new Date().getSeconds() +
          ((2 * Math.PI) / 30000) * new Date().getMilliseconds();

        // Fast
        else if (degrees === 'fast')
          degrees = ((2 * Math.PI) / 6) * new Date().getSeconds() +
          ((2 * Math.PI) / 6000) * new Date().getMilliseconds();
      }

      queue('rotate', {
        degrees: degrees
      });
      return this;
    };

    Origami.stopRender = function() {
      window.cancelAnimationFrame(this.paper.frame);
      this.paper.frame = false;
    };

    Origami.play = function() {
      this.paper.frame = 1;
      return this;
    };

    Origami.startRender = function(fn) {
      var self = this;
      if (self.paper.frame === false)
        return;

      self.draw(function() {
        self.paper.frame = window.requestAnimationFrame(fn.bind(this));
      });
    };

    Origami.scale = function(width, height) {
      queue('scale', {
        width: width,
        height: height
      });
      return this;
    };

    Origami.flip = function(type) {
      queue('flip', {
        type: type
      });
      return this;
    };

    Origami.flipEnd = function() {
      queue('flipEnd');
      return this;
    };

    Origami.clear = function() {
      queue('clear');
      return this;
    };

    Origami.on = function(ev, fn) {
      this.paper.element.addEventListener(ev, fn);
      return this;
    };

    var factory = extend(Origami.init.bind(this), Origami);

    // For consistency with CommonJS environments' exports
    if ( module && module.exports ){
        module.exports = factory;
    }

    // For CommonJS with exports, but without module.exports, like Rhino
    else if ( exports ) {
        exports.origami = factory;
    }

    // For browser, export only select globals
    else if ( typeof window === "object" ) {
        window.origami = extend(Origami.init.bind(Origami), Origami);
    }

    // Get a reference to the global object
    }( (function() {
        return this;
    })() ));
    });
    origami_1.origami;

    var drawRoundLayers = (functionContext) => {
        let { data, options, ctx, h, w, Helper, canvasId } = functionContext;
        new Helper(ctx);

        let origamiContext = {};
        let origami = origami_1.bind(origamiContext);

        origami(ctx)
            .rect(10, 10, 40, 40)
            .draw();


    };

    //options:type,colors,stroke
    function visualize(data, canvasId, options = {}, frame) {
        //make a clone of options
        options = { ...options };
        //options
        if (!options.stroke) options.stroke = 1;
        if (!options.colors) options.colors = ["#d92027", "#ff9234", "#ffcd3c", "#35d0ba"];


        let canvas = document.getElementById(canvasId);

        if (!canvas) return;

        let ctx = canvas.getContext("2d");
        let h = canvas.height;
        let w = canvas.width;



        ctx.strokeStyle = options.colors[0];
        ctx.lineWidth = options.stroke;

        let typeMap = {
            "bars": drawBars,
            "bars blocks": drawBarsBlocks,
            "big bars": drawBigBars,
            "cubes": drawCubes,
            "dualbars": drawDualbars,
            "dualbars blocks": drawDualbarsBlocks,
            "fireworks": drawFireworks,
            "flower": drawFlower,
            "flower blocks": drawFlowerBlocks,
            "orbs": drawOrbs,
            "ring": drawRing,
            "rings": drawRings,
            "round layers": drawRoundLayers,
            "round wave": drawRoundWave,
            "shine": drawShine,
            "shine rings": drawShineRings,
            "shockwave": drawShockwave,
            "star": drawStar,
            "static": drawStatic,
            "stitches": drawStitches,
            "wave": drawWave,
            "web": drawWeb
        };

        let frameRateMap = {
            "bars": 1,
            "bars blocks": 1,
            "big bars": 1,
            "cubes": 1,
            "dualbars": 1,
            "dualbars blocks": 1,
            "fireworks": 1,
            "flower": 1,
            "flower blocks": 1,
            "ring": 1,
            "rings": 1,
            "round layers": 1,
            "round wave": 1,
            "orbs": 1,
            "shine": 1,
            "shine rings": 1,
            "shockwave": 1,
            "star": 1,
            "static": 1,
            "stitches": 1,
            "wave": 1,
            "web": 1
        };

        const functionContext = {
            data, options, ctx, h, w, Helper: this.Helper, canvasId
        };

        if (typeof options.type == "string") options.type = [options.type];

        options.type.forEach(type => {
            //abide by the frame rate
            if (frame % frameRateMap[type] === 0) {
                //clear canvas
                ctx.clearRect(0, 0, w, h);
                ctx.beginPath();

                typeMap[type](functionContext);
            }
        });

    }

    function Helper(ctx) {
        this.ctx = ctx;
        this.mainColor = "black";
    }

    Helper.prototype = {
        __toRadians__(degree) {
            return (degree * Math.PI) / 180;
        },
        __rotatePoint__([pointX, pointY], [originX, originY], degree) {
            //clockwise
            let angle = this.__toRadians__(degree);
            let rotatedX = Math.cos(angle) * (pointX - originX) - Math.sin(angle) * (pointY - originY) + originX;
            let rotatedY = Math.sin(angle) * (pointX - originX) + Math.cos(angle) * (pointY - originY) + originY;

            return [rotatedX, rotatedY]
        },
        mutateData(data, type, extra = null) {
            if (type === "mirror") {
                let rtn = [];

                for (let i = 0; i < data.length; i += 2) {
                    rtn.push(data[i]);
                }

                rtn = [...rtn, ...rtn.reverse()];
                return rtn
            }

            if (type === "shrink") {
                //resize array by % of current array 
                if (extra < 1) {
                    extra = data.length * extra;
                }

                let rtn = [];
                let splitAt = Math.floor(data.length / extra);

                for (let i = 1; i <= extra; i++) {
                    let arraySection = data.slice(i * splitAt, (i * splitAt) + splitAt);
                    let middle = arraySection[Math.floor(arraySection.length / 2)];
                    rtn.push(middle);
                }

                return rtn
            }

            if (type === "split") {
                let size = Math.floor(data.length / extra);
                let rtn = [];
                let temp = [];

                let track = 0;
                for (let i = 0; i <= size * extra; i++) {
                    if (track === size) {
                        rtn.push(temp);
                        temp = [];
                        track = 0;
                    }

                    temp.push(data[i]);
                    track++;
                }

                return rtn
            }

            if (type === "scale") {
                let scalePercent = extra / 255;
                if (extra <= 3 && extra >= 0) scalePercent = extra;
                let rtn = data.map(value => value * scalePercent);
                return rtn
            }

            if (type === "organize") {
                let rtn = {};
                rtn.base = data.slice(60, 120);
                rtn.vocals = data.slice(120, 255);
                rtn.mids = data.slice(255, 2000);
                return rtn
            }

            if (type === "reverb") {
                let rtn = [];
                data.forEach((val, i) => {
                    rtn.push(val - (data[i + 1] || 0));
                });
                return rtn
            }

            if (type === "amp") {
                let rtn = [];
                data.forEach(val => {
                    rtn.push(val * (extra + 1));
                });
                return rtn
            }

            if (type === "min") {
                let rtn = [];
                data.forEach(value => {
                    if (value < extra) value = extra;
                    rtn.push(value);
                });
                return rtn
            }
        },
        getPoints(shape, size, [originX, originY], pointCount, endPoints, options = {}) {
            let { offset = 0, rotate = 0, customOrigin = [] } = options;
            let rtn = {
                start: [],
                end: []
            };

            if (shape === "circle") {

                let degreePerPoint = 360 / pointCount;
                let radianPerPoint = this.__toRadians__(degreePerPoint);
                let radius = size / 2;

                for (let i = 1; i <= pointCount; i++) {
                    let currentRadian = radianPerPoint * i;
                    let currentEndPoint = endPoints[i - 1];
                    let pointOffset = endPoints[i - 1] * (offset / 100);

                    let x = originX + (radius - pointOffset) * Math.cos(currentRadian);
                    let y = originY + (radius - pointOffset) * Math.sin(currentRadian);
                    let point1 = this.__rotatePoint__([x, y], [originX, originY], rotate);

                    rtn.start.push(point1);

                    x = originX + ((radius - pointOffset) + currentEndPoint) * Math.cos(currentRadian);
                    y = originY + ((radius - pointOffset) + currentEndPoint) * Math.sin(currentRadian);
                    let point2 = this.__rotatePoint__([x, y], [originX, originY], rotate);

                    rtn.end.push(point2);

                }

                return rtn
            }

            if (shape === "line") {
                let increment = size / pointCount;

                originX = customOrigin[0] || originX;
                originY = customOrigin[1] || originY;

                for (let i = 0; i <= pointCount; i++) {
                    let degree = rotate;
                    let pointOffset = endPoints[i] * (offset / 100);

                    let startingPoint = this.__rotatePoint__([originX + (i * increment), originY - pointOffset],
                        [originX, originY], degree);
                    rtn.start.push(startingPoint);

                    let endingPoint = this.__rotatePoint__([originX + (i * increment), (originY + endPoints[i]) - pointOffset],
                        [originX, originY], degree);
                    rtn.end.push(endingPoint);
                }

                return rtn

            }

        },
        drawCircle([x, y], diameter, options = {}) {
            let { color, lineColor = this.ctx.strokeStyle } = options;

            this.ctx.beginPath();
            this.ctx.arc(x, y, diameter / 2, 0, 2 * Math.PI);
            this.ctx.strokeStyle = lineColor;
            this.ctx.stroke();
            this.ctx.fillStyle = color;
            if (color) this.ctx.fill();
        },
        drawOval([x, y], height, width, options = {}) {
            let { rotation = 0, color, lineColor = this.ctx.strokeStyle } = options;
            if (rotation) rotation = this.__toRadians__(rotation);

            this.ctx.beginPath();
            this.ctx.ellipse(x, y, width, height, rotation, 0, 2 * Math.PI);
            this.ctx.strokeStyle = lineColor;
            this.ctx.stroke();
            this.ctx.fillStyle = color;
            if (color) this.ctx.fill();
        },
        drawSquare([x, y], diameter, options = {}) {
            this.drawRectangle([x, y], diameter, diameter, options);
        },
        drawRectangle([x, y], height, width, options = {}) {
            let { color, lineColor = this.ctx.strokeStyle, radius = 0, rotate = 0 } = options;

            // if (width < 2 * radius) radius = width / 2;
            // if (height < 2 * radius) radius = height / 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x + radius, y);
            let p1 = this.__rotatePoint__([x + width, y], [x, y], rotate);
            let p2 = this.__rotatePoint__([x + width, y + height], [x, y], rotate);
            this.ctx.arcTo(p1[0], p1[1], p2[0], p2[1], radius);

            let p3 = this.__rotatePoint__([x + width, y + height], [x, y], rotate);
            let p4 = this.__rotatePoint__([x, y + height], [x, y], rotate);
            this.ctx.arcTo(p3[0], p3[1], p4[0], p4[1], radius);

            let p5 = this.__rotatePoint__([x, y + height], [x, y], rotate);
            let p6 = this.__rotatePoint__([x, y], [x, y], rotate);
            this.ctx.arcTo(p5[0], p5[1], p6[0], p6[1], radius);

            let p7 = this.__rotatePoint__([x, y], [x, y], rotate);
            let p8 = this.__rotatePoint__([x + width, y], [x, y], rotate);
            this.ctx.arcTo(p7[0], p7[1], p8[0], p8[1], radius);
            this.ctx.closePath();

            this.ctx.strokeStyle = lineColor;
            this.ctx.stroke();
            this.ctx.fillStyle = color;
            if (color) this.ctx.fill();

        },
        drawLine([fromX, fromY], [toX, toY], options = {}) {
            let { lineColor = this.ctx.strokeStyle } = options;

            this.ctx.beginPath();
            this.ctx.moveTo(fromX, fromY);
            this.ctx.lineTo(toX, toY);
            this.ctx.strokeStyle = lineColor;
            this.ctx.stroke();
        },
        drawPolygon(points, options = {}) {
            let { color, lineColor = this.ctx.strokeStyle, radius = 0, close = false } = options;

            function getRoundedPoint(x1, y1, x2, y2, radius, first) {
                let total = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                let idx = first ? radius / total : (total - radius) / total;

                return [x1 + (idx * (x2 - x1)), y1 + (idx * (y2 - y1))];
            }

            function getRoundedPoints(pts, radius) {
                let len = pts.length;
                let res = new Array(len);

                for (let i2 = 0; i2 < len; i2++) {
                    let i1 = i2 - 1;
                    let i3 = i2 + 1;

                    if (i1 < 0) i1 = len - 1;
                    if (i3 == len) i3 = 0;

                    let p1 = pts[i1];
                    let p2 = pts[i2];
                    let p3 = pts[i3];

                    let prevPt = getRoundedPoint(p1[0], p1[1], p2[0], p2[1], radius, false);
                    let nextPt = getRoundedPoint(p2[0], p2[1], p3[0], p3[1], radius, true);
                    res[i2] = [prevPt[0], prevPt[1], p2[0], p2[1], nextPt[0], nextPt[1]];
                }
                return res;
            }
            if (radius > 0) {
                points = getRoundedPoints(points, radius);
            }

            let i, pt, len = points.length;
            for (i = 0; i < len; i++) {
                pt = points[i];
                if (i == 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(pt[0], pt[1]);
                } else {
                    this.ctx.lineTo(pt[0], pt[1]);
                }
                if (radius > 0) {
                    this.ctx.quadraticCurveTo(pt[2], pt[3], pt[4], pt[5]);
                }
            }

            if (close) this.ctx.closePath();
            this.ctx.strokeStyle = lineColor;
            this.ctx.stroke();

            this.ctx.fillStyle = color;
            if (color) this.ctx.fill();
        }

    };

    function Wave() {
        this.current_stream = {};
        this.sources = {};
        this.onFileLoad = null;
        this.activeElements = {};
        this.activated = false;

        window.AudioContext = window.AudioContext || window.webkitAudioContext;
    }

    Wave.prototype = {
        fromElement,
        fromFile,
        ...fromStream$1,
        visualize,
        Helper
    };

    var bundle_cjs = Wave;

    var js_cookie = createCommonjsModule$1(function (module, exports) {
    (function (factory) {
    	var registeredInModuleLoader;
    	{
    		module.exports = factory();
    		registeredInModuleLoader = true;
    	}
    	if (!registeredInModuleLoader) {
    		var OldCookies = window.Cookies;
    		var api = window.Cookies = factory();
    		api.noConflict = function () {
    			window.Cookies = OldCookies;
    			return api;
    		};
    	}
    }(function () {
    	function extend () {
    		var i = 0;
    		var result = {};
    		for (; i < arguments.length; i++) {
    			var attributes = arguments[ i ];
    			for (var key in attributes) {
    				result[key] = attributes[key];
    			}
    		}
    		return result;
    	}

    	function decode (s) {
    		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    	}

    	function init (converter) {
    		function api() {}

    		function set (key, value, attributes) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			attributes = extend({
    				path: '/'
    			}, api.defaults, attributes);

    			if (typeof attributes.expires === 'number') {
    				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
    			}

    			// We're using "expires" because "max-age" is not supported by IE
    			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

    			try {
    				var result = JSON.stringify(value);
    				if (/^[\{\[]/.test(result)) {
    					value = result;
    				}
    			} catch (e) {}

    			value = converter.write ?
    				converter.write(value, key) :
    				encodeURIComponent(String(value))
    					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

    			key = encodeURIComponent(String(key))
    				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
    				.replace(/[\(\)]/g, escape);

    			var stringifiedAttributes = '';
    			for (var attributeName in attributes) {
    				if (!attributes[attributeName]) {
    					continue;
    				}
    				stringifiedAttributes += '; ' + attributeName;
    				if (attributes[attributeName] === true) {
    					continue;
    				}

    				// Considers RFC 6265 section 5.2:
    				// ...
    				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
    				//     character:
    				// Consume the characters of the unparsed-attributes up to,
    				// not including, the first %x3B (";") character.
    				// ...
    				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    			}

    			return (document.cookie = key + '=' + value + stringifiedAttributes);
    		}

    		function get (key, json) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			var jar = {};
    			// To prevent the for loop in the first place assign an empty array
    			// in case there are no cookies at all.
    			var cookies = document.cookie ? document.cookie.split('; ') : [];
    			var i = 0;

    			for (; i < cookies.length; i++) {
    				var parts = cookies[i].split('=');
    				var cookie = parts.slice(1).join('=');

    				if (!json && cookie.charAt(0) === '"') {
    					cookie = cookie.slice(1, -1);
    				}

    				try {
    					var name = decode(parts[0]);
    					cookie = (converter.read || converter)(cookie, name) ||
    						decode(cookie);

    					if (json) {
    						try {
    							cookie = JSON.parse(cookie);
    						} catch (e) {}
    					}

    					jar[name] = cookie;

    					if (key === name) {
    						break;
    					}
    				} catch (e) {}
    			}

    			return key ? jar[key] : jar;
    		}

    		api.set = set;
    		api.get = function (key) {
    			return get(key, false /* read as raw */);
    		};
    		api.getJSON = function (key) {
    			return get(key, true /* read as json */);
    		};
    		api.remove = function (key, attributes) {
    			set(key, '', extend(attributes, {
    				expires: -1
    			}));
    		};

    		api.defaults = {};

    		api.withConverter = init;

    		return api;
    	}

    	return init(function () {});
    }));
    });

    var Emoji = {
      : '86',
      : '85',
      : '359',
      : '95',
      : '363',
      : '96',
      : '356',
      : '362',
      : '352',
      : '342',
      : '343',
      : '348',
      : '353',
      : '361',
      : '341',
      : '97',
      : '346',
      : '354',
      : '350',
      : '351',
      : '357',
      : '355',
      : '115',
      : '360',
      : '94',
      : '87',
      : '358',
      : '33',
      : '34',
      : '303',
      : '309',
      : '314',
      : '89',
      : '13',
      : '372',
      : '14',
      : '379',
      : '380',
      : '374',
      : '262',
      : '106',
      : '376',
      : '367',
      : '81',
      : '78',
      : '100',
      : '459',
      : '450',
      : '461',
      : '116',
      : '411',
      : '101',
      : '52',
      : '107',
      : '0',
      : '1',
      : '337',
      18: '186',
      : '312',
      : '313',
      : 'dx2',
      : 'dx3',
      : 'dx4',
      : 'dx5',
      : 'dx6',
      : 'dx7',
      : 'dx8',
      : 'dx8',
      : 'dx10',
      : 'dx11',
      : 'dx12',
      : 'dx13',
      : 'dx14',
      : 'dx15',
      : 'dx16',
      : 'dx17',
      : 'dx18',
      : 'dx19',
      : 'dx20',
      : 'dx21',
      : 'dx22',
      : 'dx23',
      : 'dx24',
    };

    // cookie
    function setCookies(string) {
      const cookies = string.split(';;');
      cookies.map(cookie => {
        document.cookie = cookie;
      });
    }

    //
    //format'yyyyMMdd''yyyyMMdd''yyyy-MM-dd''yyyy/MM/dd''yyyy-MM-dd hh:mm:ss'
    function formatTime(time, format = 'yyyyMMdd') {
      const timer = new Date(time);
      const Y = timer.getFullYear();
      const M = timer.getMonth() + 1 < 10 ? '0' + (timer.getMonth() + 1) : timer.getMonth() + 1;
      const D = timer.getDate() < 10 ? '0' + timer.getDate() : timer.getDate();
      const h = timer.getHours() < 10 ? '0' + timer.getHours() : timer.getHours();
      const m = timer.getMinutes() < 10 ? '0' + timer.getMinutes() : timer.getMinutes();
      const s = timer.getSeconds() < 10 ? '0' + timer.getSeconds() : timer.getSeconds();
      switch (format) {
        case 'yyyyMMdd':
          return `${Y}${M}${D}`;
        case 'yyyyMMdd':
          return `${Y}${M}${D}`;
        case 'yyyy-MM-dd':
          return `${Y}-${M}-${D}`;
        case 'yyyy/MM/dd':
          return `${Y}/${M}/${D}`;
        case 'yyyy-MM-dd hh:mm:ss':
          return `${Y}-${M}-${D} ${h}:${m}:${s}`;
        default:
          console.log('format');
          break;
      }
    }

    /**
     * @param {} Array
     */
    function songerListToStr(arr = [], isObj = true) {
      let songerList = [];
      if (isObj) {
        for (let i = 0; i < arr.length; i++) {
          songerList.push(arr[i].name);
        }
        return songerList.join('/');
      } else {
        for (let i = 0; i < arr.length; i++) {
          songerList.push(arr[i]);
        }
        return songerList.join('/');
      }
    }

    /**
     *   100000 10
     * @param {} num
     * @param {} point
     */
    function tranNumber(num, point = 1) {
      let numStr = parseInt(num).toString();
      // 
      if (numStr.length < 5) {
        return numStr;
      }
      //8
      else if (numStr.length > 8) {
        let decimal = numStr.substring(numStr.length - 8, numStr.length - 8 + point);
        return parseFloat(parseInt(num / 100000000) + '.' + decimal) + '';
      }
      //6 (10W 10W)
      else if (numStr.length > 4) {
        let decimal = numStr.substring(numStr.length - 4, numStr.length - 4 + point);
        return parseFloat(parseInt(num / 10000) + '.' + decimal) + '';
      }
    }

    /**
     * scrollTop
     * @param {} dom
     * @param {scrollTop} position
     */
    function scrollSmoothTo(dom, position) {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
          return setTimeout(callback, 17);
        };
      }
      // 
      var scrollTop = dom.scrollTop;
      // step
      var step = function () {
        // 
        var distance = position - scrollTop;
        // 
        scrollTop = scrollTop + distance / 10;
        if (Math.abs(distance) < 1) {
          dom.scrollTo(0, position);
        } else {
          dom.scrollTo(0, scrollTop);
          requestAnimationFrame(step);
        }
      };
      step();
    }

    //toast
    /* Toast('',2000)*/
    function Toast$1(msg, duration, callback) {
      duration = isNaN(duration) ? 1000 : duration;
      if (localStorage.getItem('isShowToast') === '1') ; else {
        localStorage.setItem('isShowToast', '1');
        let m = document.createElement('div');
        m.innerHTML = msg;
        m.style.cssText =
          'max-width:80%;padding:10px;color: rgb(255, 255, 255);text-align: center;border-radius: 4px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999999;background: rgba(0, 0, 0,.7);font-size: 14px;';
        document.body.appendChild(m);
        setTimeout(function () {
          const d = 0.5;
          m.style.transition = 'ttransform ' + d + 's ease-in, opacity ' + d + 's ease-in';
          m.style.opacity = '0';
          setTimeout(function () {
            localStorage.setItem('isShowToast', '0');
            document.body.removeChild(m);
            if (typeof callback === 'function') callback();
          }, d * 1000);
        }, duration);
      }
    }

    //alert
    /* Alert('')*/
    function Alert(msg, btnText = '') {
      let m = document.createElement('div');
      m.onclick = function () {
        // m.style.display = "none";
        document.body.removeChild(m);
      };
      let strHtml = `<div>${msg}</div><div style='height:36px;width:60%;line-height:36px;color:#fff;margin:20px auto 0px;background:var(--primary-text-color);border-radius: 4px;'>${btnText}</div>`;
      m.innerHTML = strHtml;
      m.style.cssText =
        'width:60%;padding:20px;color: #666;text-align: center;border-radius: 10px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999999;background: rgba(255, 255, 255, 1);font-size: 14px;box-shadow: 0 0 30px 0 rgba(0, 0, 0, 0.15)';
      document.body.appendChild(m);
    }

    /**
     *
     * @param {string} msg 
     * @param {function} callback 
     * @param {function} cancelback 
     * @param {string} yes 
     * @param {string} no 
     */
    function Confirm(msg, callback, yes = '', no = '', cancelback) {
      let m = document.createElement('div');
      let strHtml = `<div>${msg}</div><div style='height:36px;line-height:36px;color:#fff;margin:20px auto 0px;display:flex'><div style='flex:1;background:#e2e2e2;color:#666;line-height:36px;border-radius: 4px;margin:0 5px;' id='ConfirmNo'>${no}</div> <div style='margin:0 5px;flex:1;border-radius: 4px;line-height:36px;background:var(--primary-text-color);' id='ConfirmYes'>${yes}</div></div>`;
      m.innerHTML = strHtml;
      m.style.cssText =
        'width:60%;padding:20px;color: #666;text-align: center;border-radius: 10px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999999;background: rgba(255, 255, 255, 1);font-size: 14px;box-shadow: 0 0 30px 0 rgba(0, 0, 0, 0.15)';
      document.body.appendChild(m);
      document.getElementById('ConfirmNo').onclick = function () {
        document.body.removeChild(m);
        cancelback();
      };
      document.getElementById('ConfirmYes').onclick = function () {
        document.body.removeChild(m);
        callback();
      };
    }

    /**
     * 
     * @param {Array} array ,
     * @param {Number} subLength 
     * @returns 
     */
    function cutArray(array, subLength = 150) {
      let newArr = [];
      if (array.length <= subLength) {
        newArr.push(array);
        return newArr;
      } else {
        let index = 0;
        while (index < array.length) {
          newArr.push(array.slice(index, (index += subLength)));
        }
        return newArr;
      }
    }

    /**
     *  emoji  [] 
     * @param {string} text
     * @returns
     */
    function emojiToImg(text) {
      const regex = /\[[^\[\]]{1,4}\]/g; //  /\[.{1,10}\]/g
      if (!text.match(regex)) {
        let fullText = `<span>${text}</span>`;
        return fullText;
      } else {
        let textMatchList = text.match(regex);
        if (textMatchList.length > 0) {
          //[]
          for (let x = 0; x < textMatchList.length; x++) {
            if (textMatchList[x].indexOf('][') > -1) {
              let itemList = textMatchList[x].split('][');
              for (let t = 0; t < itemList.length; t++) {
                if (itemList[t].substr(0, 1) !== '[') {
                  itemList[t] = `[${itemList[t]}`;
                }
                if (itemList[t].substr(itemList[t].length - 1, 1) !== ']') {
                  itemList[t] = `${itemList[t]}]`;
                }
              }
              textMatchList = itemList;
            }
          }
          for (let p = 0; p < textMatchList.length; p++) {
            textMatchList[p] = textMatchList[p].substr(1); //
            textMatchList[p] = textMatchList[p].substring(0, textMatchList[p].length - 1); //
          }
          const newtextMatchList = textMatchList;
          if (newtextMatchList.length > 1) {
            let newText = text;
            for (let i = 0; i < newtextMatchList.length; i++) {
              if (Emoji.hasOwnProperty(newtextMatchList[i])) {
                newText = newText.replace(
                  new RegExp(`\\[${newtextMatchList[i]}\\]`, 'g'),
                  `<img style="vertical-align:middle;height:18px;width:18px;" src="${emojiToUrl(
                Emoji[newtextMatchList[i]]
              )}"></img>`
                );
              } else {
                newText = text;
              }
            }
            let fullText = `<span>${newText}</span>`;
            return fullText;
          } else {
            if (Emoji.hasOwnProperty(newtextMatchList[0])) {
              let newText = text.replace(
                new RegExp(`\\[${newtextMatchList[0]}\\]`, 'g'),
                `<img style="vertical-align:middle;height:18px;width:18px;" src="${emojiToUrl(
              Emoji[newtextMatchList[0]]
            )}"></img>`
              );
              let fullText = `<span>${newText}</span>`;
              return fullText;
            } else {
              let fullText = `<span>${text}</span>`;
              return fullText;
            }
          }
        } else {
          let fullText = `<span>${text}</span>`;
          return fullText;
        }
      }
    }
    function emojiToUrl(value) {
      if (value.substring(0, 2) === 'dx') {
        return `/images/dd_and_xx/${value}.png`;
      } else {
        return `https://s1.music.126.net/style/web2/emt/emoji_${value}.png`;
      }
    }

    /**
     *  URL 
     * @param {string} search,
     * @returns 
     */
    function getRequest(search) {
      let theRequest = new Object();
      let strs = '';
      if (search.indexOf('?') != -1) {
        let str = search.substr(1);
        strs = str.split('&');
        for (let i = 0; i < strs.length; i++) {
          theRequest[strs[i].split('=')[0]] = decodeURIComponent(strs[i].split('=')[1]);
        }
      }
      return theRequest;
    }

    /**
     *  ripple  DOM 
     * @param {dom} dom
     */
    function ripple(dom, list = false) {
      if (list) {
        for (let t = 0; t < dom.childNodes.length; t++) {
          dom.childNodes[t].addEventListener('touchstart', createRipple);
          dom.childNodes[t].addEventListener('touchend', removeRipple);
        }
      } else {
        dom.addEventListener('touchstart', createRipple);
        dom.addEventListener('touchend', removeRipple);
      }
    }
    function computeRippleStyles(element, event) {
      const { top, left } = element.getBoundingClientRect();
      const { clientWidth, clientHeight } = element;
      const radius = Math.sqrt(clientWidth ** 2 + clientHeight ** 2) / 2;
      const size = radius * 2;
      const localX = event.changedTouches[0].clientX - left;
      const localY = event.changedTouches[0].clientY - top;
      const centerX = (clientWidth - radius * 2) / 2;
      const centerY = (clientHeight - radius * 2) / 2;
      const x = localX - radius;
      const y = localY - radius;
      return { x, y, centerX, centerY, size };
    }
    function createRipple(event) {
      const container = this;
      const { x, y, centerX, centerY, size } = computeRippleStyles(container, event);
      const ripple = document.createElement('div');
      ripple.classList.add('my-ripple');
      ripple.style.opacity = `0`;
      ripple.style.transform = `translate(${x}px, ${y}px) scale3d(.3, .3, .3)`;
      ripple.style.width = `${size}px`;
      ripple.style.height = `${size}px`;
      // 
      ripple.dataset.createdAt = String(performance.now());
      const { position } = window.getComputedStyle(container);
      container.style.overflow = 'hidden';
      position === 'static' && (this.style.position = 'relative');
      container.appendChild(ripple);
      window.setTimeout(() => {
        ripple.style.transform = `translate(${centerX}px, ${centerY}px) scale3d(1, 1, 1)`;
        ripple.style.opacity = `.2`;
      });
    }
    function removeRipple() {
      const container = this;
      const ripples = container.querySelectorAll('.my-ripple');
      if (!ripples.length) {
        return;
      }
      const lastRipple = ripples[ripples.length - 1];
      // 
      const delay = 300 - performance.now() + Number(lastRipple.dataset.createdAt);
      setTimeout(() => {
        lastRipple.style.opacity = `0`;
        setTimeout(() => lastRipple.parentNode?.removeChild(lastRipple), 300);
      }, delay);
    }

    // 
    function getOsInfo() {
      var userAgent = navigator.userAgent.toLowerCase();
      var os = 'Unknown';
      var version = 'Unknown';
      if (userAgent.indexOf('win') > -1) {
        os = 'Windows';
        if (userAgent.indexOf('windows nt 5.0') > -1) {
          version = 'Windows 2000';
        } else if (userAgent.indexOf('windows nt 5.1') > -1 || userAgent.indexOf('windows nt 5.2') > -1) {
          version = 'Windows XP';
        } else if (userAgent.indexOf('windows nt 6.0') > -1) {
          version = 'Windows Vista';
        } else if (userAgent.indexOf('windows nt 6.1') > -1 || userAgent.indexOf('windows 7') > -1) {
          version = 'Windows 7';
        } else if (userAgent.indexOf('windows nt 6.2') > -1 || userAgent.indexOf('windows 8') > -1) {
          version = 'Windows 8';
        } else if (userAgent.indexOf('windows nt 6.3') > -1) {
          version = 'Windows 8.1';
        } else if (userAgent.indexOf('windows nt 6.2') > -1 || userAgent.indexOf('windows nt 10.0') > -1) {
          version = 'Windows 10';
        } else {
          version = 'Unknown';
        }
      } else if (userAgent.indexOf('iphone') > -1) {
        os = 'iPhone';
      } else if (userAgent.indexOf('mac') > -1) {
        os = 'Mac';
      } else if (
        userAgent.indexOf('x11') > -1 ||
        userAgent.indexOf('unix') > -1 ||
        userAgent.indexOf('sunname') > -1 ||
        userAgent.indexOf('bsd') > -1
      ) {
        os = 'Unix';
      } else if (userAgent.indexOf('linux') > -1) {
        if (userAgent.indexOf('android') > -1) {
          os = 'Android';
        } else {
          os = 'Linux';
        }
      } else {
        os = 'Unknown';
      }
      return { os, version };
    }

    //
    function getUserAgentInfo() {
      var userAgent = navigator.userAgent;
      var version;
      if (/opera/i.test(userAgent) || /OPR/i.test(userAgent)) {
        version = getVersion(userAgent, 'OPR/(\\d+\\.+\\d+)');
        return { browser: 'opera', version };
      } else if (/compatible/i.test(userAgent) && /MSIE/i.test(userAgent)) {
        version = getVersion(userAgent, 'MSIE (\\d+\\.+\\d+)');
        return { browser: 'ie', version };
      } else if (/Edge/i.test(userAgent)) {
        version = getVersion(userAgent, 'Edge/(\\d+\\.+\\d+)');
        return { browser: 'edge', version };
      } else if (/Firefox/i.test(userAgent)) {
        version = getVersion(userAgent, 'Firefox/(\\d+\\.+\\d+)');
        return { browser: 'firefox', version };
      } else if (/Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)) {
        version = getVersion(userAgent, 'Safari/(\\d+\\.+\\d+)');
        return { browser: 'safari', version };
      } else if (/Chrome/i.test(userAgent) && /Safari/i.test(userAgent)) {
        version = getVersion(userAgent, 'Chrome/(\\d+\\.+\\d+)');
        return { browser: 'chrome', version };
      } else if (!!window.ActiveXObject || 'ActiveXObject' in window) {
        version = 11;
        return { browser: 'ie', version };
      }
    }
    //
    function getVersion(userAgent, reg) {
      var reBrowser = new RegExp(reg);
      reBrowser.test(userAgent);
      return parseFloat(RegExp['$1']);
    }

    //
    // times(number)
    function timeToMinute(times) {
      var result = '00:00';
      var hour, minute, second;
      if (times > 0) {
        hour = Math.floor(times / 3600);
        if (hour < 10) {
          hour = '0' + hour;
        }
        minute = Math.floor((times - 3600 * hour) / 60);
        if (minute < 10) {
          minute = '0' + minute;
        }
        second = Math.floor((times - 3600 * hour - 60 * minute) % 60);
        if (second < 10) {
          second = '0' + second;
        }
        if (hour == '00') {
          result = minute + ':' + second;
        } else if (minute == '00') {
          // result = hour + ":" + minute + ":" + second;
          result = minute + ':' + second;
        } else {
          result = second;
        }
      }
      return result;
    }

    /* src\components\base\Button.svelte generated by Svelte v3.46.4 */
    const file$M = "src\\components\\base\\Button.svelte";

    function create_fragment$M(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", "botton svelte-1svp9rd");
    			toggle_class(button, "default", /*type*/ ctx[0] === 'default');
    			toggle_class(button, "primary", /*type*/ ctx[0] === 'primary');
    			add_location(button, file$M, 21, 0, 401);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[5](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*setClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (dirty & /*type*/ 1) {
    				toggle_class(button, "default", /*type*/ ctx[0] === 'default');
    			}

    			if (dirty & /*type*/ 1) {
    				toggle_class(button, "primary", /*type*/ ctx[0] === 'primary');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[5](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { type = 'default' } = $$props;
    	const dispatch = createEventDispatcher();

    	function setClick() {
    		dispatch('BtnClick');
    	}

    	let btnDom;

    	onMount(() => {
    		if (btnDom) {
    			ripple(btnDom);
    		}
    	});

    	const writable_props = ['type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			btnDom = $$value;
    			$$invalidate(1, btnDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(0, type = $$props.type);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		ripple,
    		type,
    		dispatch,
    		setClick,
    		btnDom
    	});

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(0, type = $$props.type);
    		if ('btnDom' in $$props) $$invalidate(1, btnDom = $$props.btnDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [type, btnDom, setClick, $$scope, slots, button_binding];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { type: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\NavBar.svelte generated by Svelte v3.46.4 */
    const file$L = "src\\components\\base\\NavBar.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (79:4) {#if rightIcons.length > 0}
    function create_if_block$q(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*rightIcons*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*iconClick, rightIcons, isRefresh*/ 2240) {
    				each_value = /*rightIcons*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(79:4) {#if rightIcons.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (80:6) {#each rightIcons as rightIcon}
    function create_each_block$g(ctx) {
    	let div;
    	let span;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*rightIcon*/ ctx[17].icon;

    	function switch_props(ctx) {
    		return {
    			props: {
    				size: "22",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[14](/*rightIcon*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(span, "class", "svelte-zr2dre");
    			toggle_class(span, "rotate-icon", /*rightIcon*/ ctx[17].id === 'RefreshLine' && /*isRefresh*/ ctx[7]);
    			add_location(span, file$L, 81, 10, 2076);
    			attr_dev(div, "class", "right-item svelte-zr2dre");
    			add_location(div, file$L, 80, 8, 1999);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (switch_instance) {
    				mount_component(switch_instance, span, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (switch_value !== (switch_value = /*rightIcon*/ ctx[17].icon)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, span, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (dirty & /*rightIcons, isRefresh*/ 192) {
    				toggle_class(span, "rotate-icon", /*rightIcon*/ ctx[17].id === 'RefreshLine' && /*isRefresh*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(80:6) {#each rightIcons as rightIcon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div3;
    	let div0;
    	let arrowleftline;
    	let t0;
    	let div1;
    	let t1;
    	let t2;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;

    	arrowleftline = new ArrowLeftLine({
    			props: {
    				size: "22",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	let if_block = /*rightIcons*/ ctx[6].length > 0 && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(arrowleftline.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text(/*title*/ ctx[0]);
    			t2 = space();
    			div2 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "left svelte-zr2dre");

    			set_style(div0, "color", "rgba(" + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", " + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", " + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", 1)");

    			toggle_class(div0, "transparent", /*transparent*/ ctx[2]);
    			add_location(div0, file$L, 51, 2, 1178);
    			attr_dev(div1, "class", "center svelte-zr2dre");

    			set_style(div1, "color", "rgba(" + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", " + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", " + (/*transparent*/ ctx[2]
    			? 255 * (1 - /*alphaNumber*/ ctx[4])
    			: 0) + ", 1)");

    			toggle_class(div1, "dark", /*dark*/ ctx[5]);
    			add_location(div1, file$L, 68, 2, 1628);
    			attr_dev(div2, "class", "right svelte-zr2dre");
    			add_location(div2, file$L, 77, 2, 1876);
    			attr_dev(div3, "class", "nav secondary svelte-zr2dre");
    			set_style(div3, "background-color", "rgba(255, 255, 255, " + (/*transparent*/ ctx[2] ? /*alphaNumber*/ ctx[4] : 1) + ")");
    			toggle_class(div3, "transparent", /*transparent*/ ctx[2]);
    			toggle_class(div3, "fixed", /*transparent*/ ctx[2] ? true : /*fixed*/ ctx[3]);
    			add_location(div3, file$L, 45, 0, 996);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(arrowleftline, div0, null);
    			/*div0_binding*/ ctx[12](div0);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div1, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			if (if_block) if_block.m(div2, null);
    			/*div2_binding*/ ctx[15](div2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*click_handler*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*transparent, alphaNumber*/ 20) {
    				set_style(div0, "color", "rgba(" + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", " + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", " + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", 1)");
    			}

    			if (dirty & /*transparent*/ 4) {
    				toggle_class(div0, "transparent", /*transparent*/ ctx[2]);
    			}

    			if (!current || dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);

    			if (!current || dirty & /*transparent, alphaNumber*/ 20) {
    				set_style(div1, "color", "rgba(" + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", " + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", " + (/*transparent*/ ctx[2]
    				? 255 * (1 - /*alphaNumber*/ ctx[4])
    				: 0) + ", 1)");
    			}

    			if (dirty & /*dark*/ 32) {
    				toggle_class(div1, "dark", /*dark*/ ctx[5]);
    			}

    			if (/*rightIcons*/ ctx[6].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*rightIcons*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*transparent, alphaNumber*/ 20) {
    				set_style(div3, "background-color", "rgba(255, 255, 255, " + (/*transparent*/ ctx[2] ? /*alphaNumber*/ ctx[4] : 1) + ")");
    			}

    			if (dirty & /*transparent*/ 4) {
    				toggle_class(div3, "transparent", /*transparent*/ ctx[2]);
    			}

    			if (dirty & /*transparent, fixed*/ 12) {
    				toggle_class(div3, "fixed", /*transparent*/ ctx[2] ? true : /*fixed*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arrowleftline.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arrowleftline.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(arrowleftline);
    			/*div0_binding*/ ctx[12](null);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[15](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavBar', slots, []);
    	let { title = 'Title' } = $$props;
    	let { leftEvent = false } = $$props;
    	let { transparent = false } = $$props;
    	let { fixed = true } = $$props;
    	let { alphaNumber = 1 } = $$props;
    	let { dark = false } = $$props;
    	let { rightIcons = [] } = $$props;
    	let { isRefresh = false } = $$props;
    	let leftDom;
    	let rightDoms;

    	onMount(() => {
    		if (leftDom) ripple(leftDom);

    		if (rightDoms) {
    			ripple(rightDoms);
    		}

    		return () => {
    			$$invalidate(9, rightDoms = null);
    		};
    	});

    	afterUpdate(() => {
    		if (rightDoms) {
    			ripple(rightDoms, true);
    		}
    	});

    	const dispatch = createEventDispatcher();

    	function setLeftClick() {
    		dispatch('setLeftClick');
    	}

    	function iconClick(id) {
    		dispatch('setRightIconClick', { id });
    	}

    	const writable_props = [
    		'title',
    		'leftEvent',
    		'transparent',
    		'fixed',
    		'alphaNumber',
    		'dark',
    		'rightIcons',
    		'isRefresh'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NavBar> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			leftDom = $$value;
    			$$invalidate(8, leftDom);
    		});
    	}

    	const click_handler = () => {
    		if (leftEvent) {
    			setLeftClick();
    		} else {
    			pop();
    		}
    	};

    	const click_handler_1 = rightIcon => iconClick(rightIcon.id);

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			rightDoms = $$value;
    			$$invalidate(9, rightDoms);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('leftEvent' in $$props) $$invalidate(1, leftEvent = $$props.leftEvent);
    		if ('transparent' in $$props) $$invalidate(2, transparent = $$props.transparent);
    		if ('fixed' in $$props) $$invalidate(3, fixed = $$props.fixed);
    		if ('alphaNumber' in $$props) $$invalidate(4, alphaNumber = $$props.alphaNumber);
    		if ('dark' in $$props) $$invalidate(5, dark = $$props.dark);
    		if ('rightIcons' in $$props) $$invalidate(6, rightIcons = $$props.rightIcons);
    		if ('isRefresh' in $$props) $$invalidate(7, isRefresh = $$props.isRefresh);
    	};

    	$$self.$capture_state = () => ({
    		pop,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		ArrowLeftLine,
    		ripple,
    		title,
    		leftEvent,
    		transparent,
    		fixed,
    		alphaNumber,
    		dark,
    		rightIcons,
    		isRefresh,
    		leftDom,
    		rightDoms,
    		dispatch,
    		setLeftClick,
    		iconClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('leftEvent' in $$props) $$invalidate(1, leftEvent = $$props.leftEvent);
    		if ('transparent' in $$props) $$invalidate(2, transparent = $$props.transparent);
    		if ('fixed' in $$props) $$invalidate(3, fixed = $$props.fixed);
    		if ('alphaNumber' in $$props) $$invalidate(4, alphaNumber = $$props.alphaNumber);
    		if ('dark' in $$props) $$invalidate(5, dark = $$props.dark);
    		if ('rightIcons' in $$props) $$invalidate(6, rightIcons = $$props.rightIcons);
    		if ('isRefresh' in $$props) $$invalidate(7, isRefresh = $$props.isRefresh);
    		if ('leftDom' in $$props) $$invalidate(8, leftDom = $$props.leftDom);
    		if ('rightDoms' in $$props) $$invalidate(9, rightDoms = $$props.rightDoms);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		leftEvent,
    		transparent,
    		fixed,
    		alphaNumber,
    		dark,
    		rightIcons,
    		isRefresh,
    		leftDom,
    		rightDoms,
    		setLeftClick,
    		iconClick,
    		div0_binding,
    		click_handler,
    		click_handler_1,
    		div2_binding
    	];
    }

    class NavBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			title: 0,
    			leftEvent: 1,
    			transparent: 2,
    			fixed: 3,
    			alphaNumber: 4,
    			dark: 5,
    			rightIcons: 6,
    			isRefresh: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavBar",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get title() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leftEvent() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leftEvent(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transparent() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transparent(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alphaNumber() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alphaNumber(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightIcons() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightIcons(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isRefresh() {
    		throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isRefresh(value) {
    		throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Divider.svelte generated by Svelte v3.46.4 */

    const file$K = "src\\components\\base\\Divider.svelte";

    function create_fragment$K(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "diveder svelte-zquzag");
    			add_location(div, file$K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Divider', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Divider> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Divider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Divider",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src\components\base\Input.svelte generated by Svelte v3.46.4 */
    const file$J = "src\\components\\base\\Input.svelte";

    // (43:2) {#if rightBtn}
    function create_if_block$p(ctx) {
    	let span;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*btnText*/ ctx[5]);
    			attr_dev(span, "class", "right-btn svelte-17e6v9z");
    			add_location(span, file$J, 43, 4, 1011);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*btnClick*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*btnText*/ 32) set_data_dev(t, /*btnText*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(43:2) {#if rightBtn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let input;
    	let input_placeholder_value;
    	let t2;
    	let mounted;
    	let dispose;
    	let if_block = /*rightBtn*/ ctx[4] && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "label svelte-17e6v9z");
    			add_location(div0, file$J, 33, 2, 742);
    			attr_dev(input, "maxlength", /*maxlength*/ ctx[2]);

    			attr_dev(input, "placeholder", input_placeholder_value = /*placeholder*/ ctx[3]
    			? /*placeholder*/ ctx[3]
    			: /*defatltPlaceholder*/ ctx[7]);

    			set_style(input, "width", /*rightBtn*/ ctx[4] ? '75%' : '100%');
    			attr_dev(input, "class", "svelte-17e6v9z");
    			add_location(input, file$J, 34, 2, 778);
    			attr_dev(div1, "class", "box svelte-17e6v9z");
    			add_location(div1, file$J, 32, 0, 721);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, input);
    			set_input_value(input, /*value*/ ctx[0]);
    			/*input_binding*/ ctx[12](input);
    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[11]),
    					listen_dev(input, "input", /*setInput*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);

    			if (dirty & /*maxlength*/ 4) {
    				attr_dev(input, "maxlength", /*maxlength*/ ctx[2]);
    			}

    			if (dirty & /*placeholder, defatltPlaceholder*/ 136 && input_placeholder_value !== (input_placeholder_value = /*placeholder*/ ctx[3]
    			? /*placeholder*/ ctx[3]
    			: /*defatltPlaceholder*/ ctx[7])) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*rightBtn*/ 16) {
    				set_style(input, "width", /*rightBtn*/ ctx[4] ? '75%' : '100%');
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			if (/*rightBtn*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*input_binding*/ ctx[12](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let defatltPlaceholder;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, []);
    	let { label = 'label' } = $$props;
    	let { type = 'text' } = $$props;
    	let { maxlength = 15 } = $$props;
    	let { placeholder = null } = $$props;
    	let { value = '' } = $$props;
    	let { rightBtn = false } = $$props;
    	let { btnText = '' } = $$props;
    	let inputDom;
    	const dispatch = createEventDispatcher();

    	onMount(() => {
    		setTimeout(
    			function () {
    				inputDom.scrollIntoView(true);
    				inputDom.scrollIntoViewIfNeeded();
    			},
    			300
    		);

    		$$invalidate(6, inputDom.type = type, inputDom);
    	});

    	function setInput() {
    		dispatch('setInput', { value });
    	}

    	function btnClick() {
    		dispatch('setBtn');
    	}

    	const writable_props = ['label', 'type', 'maxlength', 'placeholder', 'value', 'rightBtn', 'btnText'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputDom = $$value;
    			$$invalidate(6, inputDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('maxlength' in $$props) $$invalidate(2, maxlength = $$props.maxlength);
    		if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('rightBtn' in $$props) $$invalidate(4, rightBtn = $$props.rightBtn);
    		if ('btnText' in $$props) $$invalidate(5, btnText = $$props.btnText);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		label,
    		type,
    		maxlength,
    		placeholder,
    		value,
    		rightBtn,
    		btnText,
    		inputDom,
    		dispatch,
    		setInput,
    		btnClick,
    		defatltPlaceholder
    	});

    	$$self.$inject_state = $$props => {
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('maxlength' in $$props) $$invalidate(2, maxlength = $$props.maxlength);
    		if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('rightBtn' in $$props) $$invalidate(4, rightBtn = $$props.rightBtn);
    		if ('btnText' in $$props) $$invalidate(5, btnText = $$props.btnText);
    		if ('inputDom' in $$props) $$invalidate(6, inputDom = $$props.inputDom);
    		if ('defatltPlaceholder' in $$props) $$invalidate(7, defatltPlaceholder = $$props.defatltPlaceholder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*label*/ 2) {
    			$$invalidate(7, defatltPlaceholder = '' + label);
    		}
    	};

    	return [
    		value,
    		label,
    		maxlength,
    		placeholder,
    		rightBtn,
    		btnText,
    		inputDom,
    		defatltPlaceholder,
    		setInput,
    		btnClick,
    		type,
    		input_input_handler,
    		input_binding
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			label: 1,
    			type: 10,
    			maxlength: 2,
    			placeholder: 3,
    			value: 0,
    			rightBtn: 4,
    			btnText: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get label() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightBtn() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightBtn(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get btnText() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set btnText(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Progress.svelte generated by Svelte v3.46.4 */
    const file$I = "src\\components\\base\\Progress.svelte";

    function create_fragment$I(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "ball svelte-ckiir6");
    			set_style(div0, "left", "calc(" + /*currentLong*/ ctx[1] / /*max*/ ctx[0] * 100 + "% - 7px)");
    			add_location(div0, file$I, 74, 4, 1869);
    			attr_dev(div1, "class", "fill svelte-ckiir6");
    			set_style(div1, "transform", "scaleX(" + /*currentLong*/ ctx[1] / /*max*/ ctx[0] + ")");
    			add_location(div1, file$I, 75, 4, 1949);
    			attr_dev(div2, "class", "rail svelte-ckiir6");
    			add_location(div2, file$I, 73, 2, 1845);
    			attr_dev(div3, "class", "slider svelte-ckiir6");
    			add_location(div3, file$I, 65, 0, 1684);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			/*div3_binding*/ ctx[11](div3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "click", /*handleClick*/ ctx[3], false, false, false),
    					listen_dev(div3, "touchstart", /*touchStart*/ ctx[4], false, false, false),
    					listen_dev(div3, "touchmove", /*touchMove*/ ctx[6], false, false, false),
    					listen_dev(div3, "touchend", /*touchEnd*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*currentLong, max*/ 3) {
    				set_style(div0, "left", "calc(" + /*currentLong*/ ctx[1] / /*max*/ ctx[0] * 100 + "% - 7px)");
    			}

    			if (dirty & /*currentLong, max*/ 3) {
    				set_style(div1, "transform", "scaleX(" + /*currentLong*/ ctx[1] / /*max*/ ctx[0] + ")");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*div3_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Progress', slots, []);
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { step = 1 } = $$props;
    	let { current = 0 } = $$props;
    	let { timeCurrent = 0 } = $$props;
    	let currentLong = 0;
    	let slider;
    	let scale = 0;
    	let movePoint = 20;
    	const dispatch = createEventDispatcher();

    	onMount(() => {
    		scale = slider.clientWidth / (max / step);
    	});

    	afterUpdate(() => {
    		$$invalidate(1, currentLong = current);
    	});

    	function setCurrent() {
    		dispatch('setCurrent', { current });
    	}

    	function setTimeCurrent() {
    		dispatch('setTimeCurrent', { timeCurrent });
    	}

    	function handleClick(e) {
    		const distance = e.clientX - slider.getBoundingClientRect().left;
    		const value = Math.round(distance / scale) * step;
    		$$invalidate(7, current = $$invalidate(1, currentLong = value));
    		setCurrent();
    	}

    	function touchStart(e) {
    		movePoint = e.changedTouches[0].clientX;
    	}

    	function touchEnd(e) {
    		movePoint = e.changedTouches[0].clientX;

    		if (movePoint <= 20) {
    			$$invalidate(7, current = $$invalidate(8, timeCurrent = $$invalidate(1, currentLong = min)));
    		} else if (movePoint >= 355) {
    			$$invalidate(7, current = $$invalidate(8, timeCurrent = $$invalidate(1, currentLong = max)));
    		} else {
    			$$invalidate(7, current = $$invalidate(8, timeCurrent = $$invalidate(1, currentLong = (movePoint - 20) / 335 * 100)));
    		}

    		setCurrent();
    		setTimeCurrent();
    	}

    	function touchMove(e) {
    		movePoint = e.changedTouches[0].clientX;

    		if (movePoint <= 20) {
    			$$invalidate(8, timeCurrent = $$invalidate(1, currentLong = min));
    		} else if (movePoint >= 355) {
    			$$invalidate(8, timeCurrent = $$invalidate(1, currentLong = max));
    		} else {
    			$$invalidate(8, timeCurrent = $$invalidate(1, currentLong = (movePoint - 20) / 335 * 100));
    		}

    		setTimeCurrent();
    	}

    	const writable_props = ['min', 'max', 'step', 'current', 'timeCurrent'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Progress> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			slider = $$value;
    			$$invalidate(2, slider);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('min' in $$props) $$invalidate(9, min = $$props.min);
    		if ('max' in $$props) $$invalidate(0, max = $$props.max);
    		if ('step' in $$props) $$invalidate(10, step = $$props.step);
    		if ('current' in $$props) $$invalidate(7, current = $$props.current);
    		if ('timeCurrent' in $$props) $$invalidate(8, timeCurrent = $$props.timeCurrent);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		createEventDispatcher,
    		min,
    		max,
    		step,
    		current,
    		timeCurrent,
    		currentLong,
    		slider,
    		scale,
    		movePoint,
    		dispatch,
    		setCurrent,
    		setTimeCurrent,
    		handleClick,
    		touchStart,
    		touchEnd,
    		touchMove
    	});

    	$$self.$inject_state = $$props => {
    		if ('min' in $$props) $$invalidate(9, min = $$props.min);
    		if ('max' in $$props) $$invalidate(0, max = $$props.max);
    		if ('step' in $$props) $$invalidate(10, step = $$props.step);
    		if ('current' in $$props) $$invalidate(7, current = $$props.current);
    		if ('timeCurrent' in $$props) $$invalidate(8, timeCurrent = $$props.timeCurrent);
    		if ('currentLong' in $$props) $$invalidate(1, currentLong = $$props.currentLong);
    		if ('slider' in $$props) $$invalidate(2, slider = $$props.slider);
    		if ('scale' in $$props) scale = $$props.scale;
    		if ('movePoint' in $$props) movePoint = $$props.movePoint;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		max,
    		currentLong,
    		slider,
    		handleClick,
    		touchStart,
    		touchEnd,
    		touchMove,
    		current,
    		timeCurrent,
    		min,
    		step,
    		div3_binding
    	];
    }

    class Progress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			min: 9,
    			max: 0,
    			step: 10,
    			current: 7,
    			timeCurrent: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Progress",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get min() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get current() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set current(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get timeCurrent() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timeCurrent(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    //TabBar
    // export const isShowTabBarStore = writable(false);

    //Loading
    const isLoadingStore = writable(false);

    //
    const isLoginStore = writable(JSON.parse(localStorage.getItem('isLogin')) ? true : false);
    //Home
    const isHomePageStore = writable(true);
    //
    const defaultResumableStore = writable(false);
    //active
    const homeActiveStore = writable('1');
    //
    const restoreScrollStore = writable(localStorage.getItem('restoreScroll') === '0' ? false : true);
    //
    const musicQualityStore = writable(
      localStorage.getItem('musicQuality') ? localStorage.getItem('musicQuality') : '0'
    );
    //
    const isShowTranslateStore = writable(localStorage.getItem('isShowTranslate') === '0' ? false : true);
    // id
    const currentDetailSongerIdStore = writable(0);
    //
    const coverImgUrlStore = writable('');
    //
    const isShowCommentStore = writable(localStorage.getItem('isShowComment') === '0' ? '0' : '1');

    /* src\components\base\TabBar.svelte generated by Svelte v3.46.4 */
    const file$H = "src\\components\\base\\TabBar.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[7] = list;
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (36:2) {#each navDatas as navData, i}
    function create_each_block$f(ctx) {
    	let div2;
    	let div0;
    	let switch_instance;
    	let t0;
    	let div1;
    	let t1_value = /*navData*/ ctx[6].text + "";
    	let t1;
    	let t2;
    	let i = /*i*/ ctx[8];
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*navData*/ ctx[6].icon;

    	function switch_props(ctx) {
    		return { props: { size: "24px" }, $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[4](/*i*/ ctx[8]);
    	}

    	const assign_div2 = () => /*div2_binding*/ ctx[5](div2, i);
    	const unassign_div2 = () => /*div2_binding*/ ctx[5](null, i);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(div0, file$H, 44, 6, 1081);
    			attr_dev(div1, "class", "nav-text svelte-1v0ei6g");
    			add_location(div1, file$H, 47, 6, 1170);
    			attr_dev(div2, "class", "nav-item svelte-1v0ei6g");
    			toggle_class(div2, "active", /*$homeActiveStore*/ ctx[2] === /*i*/ ctx[8]);
    			add_location(div2, file$H, 36, 4, 895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			append_dev(div2, t2);
    			assign_div2();
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (switch_value !== (switch_value = /*navData*/ ctx[6].icon)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (i !== /*i*/ ctx[8]) {
    				unassign_div2();
    				i = /*i*/ ctx[8];
    				assign_div2();
    			}

    			if (dirty & /*$homeActiveStore*/ 4) {
    				toggle_class(div2, "active", /*$homeActiveStore*/ ctx[2] === /*i*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (switch_instance) destroy_component(switch_instance);
    			unassign_div2();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(36:2) {#each navDatas as navData, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let div;
    	let current;
    	let each_value = /*navDatas*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "secondary nav svelte-1v0ei6g");

    			set_style(div, "bottom", /*$isHomePageStore*/ ctx[1]
    			? '0px'
    			: 'calc(-55px - env(safe-area-inset-bottom))');

    			add_location(div, file$H, 34, 0, 738);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tabDoms, $homeActiveStore, homeActiveStore, navDatas*/ 13) {
    				each_value = /*navDatas*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*$isHomePageStore*/ 2) {
    				set_style(div, "bottom", /*$isHomePageStore*/ ctx[1]
    				? '0px'
    				: 'calc(-55px - env(safe-area-inset-bottom))');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $isHomePageStore;
    	let $homeActiveStore;
    	validate_store(isHomePageStore, 'isHomePageStore');
    	component_subscribe($$self, isHomePageStore, $$value => $$invalidate(1, $isHomePageStore = $$value));
    	validate_store(homeActiveStore, 'homeActiveStore');
    	component_subscribe($$self, homeActiveStore, $$value => $$invalidate(2, $homeActiveStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabBar', slots, []);

    	let navDatas = [
    		{
    			icon: ThumbUpFill,
    			text: '',
    			path: '/love'
    		},
    		{
    			icon: Compass3Fill,
    			text: '',
    			path: '/discover'
    		},
    		{
    			icon: AccountCircleFill,
    			text: '',
    			path: '/mine'
    		}
    	];

    	let tabDoms = [];

    	onMount(() => {
    		if (tabDoms.length > 0) {
    			for (let r = 0; r < tabDoms.length; r++) {
    				ripple(tabDoms[r]);
    			}
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabBar> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => {
    		homeActiveStore.set(i);
    	};

    	function div2_binding($$value, i) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tabDoms[i] = $$value;
    			$$invalidate(0, tabDoms);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		ThumbUpFill,
    		Compass3Fill,
    		AccountCircleFill,
    		isHomePageStore,
    		homeActiveStore,
    		ripple,
    		navDatas,
    		tabDoms,
    		$isHomePageStore,
    		$homeActiveStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('navDatas' in $$props) $$invalidate(3, navDatas = $$props.navDatas);
    		if ('tabDoms' in $$props) $$invalidate(0, tabDoms = $$props.tabDoms);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		tabDoms,
    		$isHomePageStore,
    		$homeActiveStore,
    		navDatas,
    		click_handler,
    		div2_binding
    	];
    }

    class TabBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabBar",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\components\base\Switch.svelte generated by Svelte v3.46.4 */
    const file$G = "src\\components\\base\\Switch.svelte";

    function create_fragment$G(ctx) {
    	let div1;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "ball svelte-5vgcov");
    			set_style(div0, "left", /*check*/ ctx[0] ? '25px' : '1px');
    			add_location(div0, file$G, 17, 2, 382);
    			attr_dev(div1, "class", "box svelte-5vgcov");

    			set_style(div1, "background-color", /*check*/ ctx[0]
    			? 'var(--primary-text-color)'
    			: 'rgb(177, 177, 177)');

    			add_location(div1, file$G, 12, 0, 243);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*setChange*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*check*/ 1) {
    				set_style(div0, "left", /*check*/ ctx[0] ? '25px' : '1px');
    			}

    			if (dirty & /*check*/ 1) {
    				set_style(div1, "background-color", /*check*/ ctx[0]
    				? 'var(--primary-text-color)'
    				: 'rgb(177, 177, 177)');
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Switch', slots, []);
    	let { check = false } = $$props;
    	const dispatch = createEventDispatcher();

    	function setChange() {
    		dispatch('switchClick', { check: !check });
    	}

    	const writable_props = ['check'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Switch> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('check' in $$props) $$invalidate(0, check = $$props.check);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		check,
    		dispatch,
    		setChange
    	});

    	$$self.$inject_state = $$props => {
    		if ('check' in $$props) $$invalidate(0, check = $$props.check);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [check, setChange];
    }

    class Switch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { check: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Switch",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get check() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set check(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Cell.svelte generated by Svelte v3.46.4 */
    const file$F = "src\\components\\base\\Cell.svelte";

    // (37:4) {#if titleDesc != ''}
    function create_if_block_2$b(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*titleDesc*/ ctx[2]);
    			attr_dev(div, "class", "title-des svelte-lgfbu");
    			add_location(div, file$F, 37, 6, 883);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*titleDesc*/ 4) set_data_dev(t, /*titleDesc*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(37:4) {#if titleDesc != ''}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {:else}
    function create_else_block$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*desc*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*desc*/ 16) set_data_dev(t, /*desc*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(47:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:6) {#if desc === 'Switch'}
    function create_if_block_1$h(ctx) {
    	let div;
    	let switch_1;
    	let current;

    	switch_1 = new Switch({
    			props: { check: /*cellCheck*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(switch_1.$$.fragment);
    			attr_dev(div, "class", "switch svelte-lgfbu");
    			set_style(div, "margin-top", /*titleDesc*/ ctx[2] === '' ? '2px' : '8.5px');
    			add_location(div, file$F, 43, 8, 1037);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(switch_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_1_changes = {};
    			if (dirty & /*cellCheck*/ 1) switch_1_changes.check = /*cellCheck*/ ctx[0];
    			switch_1.$set(switch_1_changes);

    			if (!current || dirty & /*titleDesc*/ 4) {
    				set_style(div, "margin-top", /*titleDesc*/ ctx[2] === '' ? '2px' : '8.5px');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(switch_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(switch_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(switch_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(43:6) {#if desc === 'Switch'}",
    		ctx
    	});

    	return block;
    }

    // (52:2) {#if arrow}
    function create_if_block$o(ctx) {
    	let div;
    	let span;
    	let arrowrightsline;
    	let current;

    	arrowrightsline = new ArrowRightSLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			create_component(arrowrightsline.$$.fragment);
    			set_style(span, "position", "relative");
    			set_style(span, "top", "-1px");
    			add_location(span, file$F, 53, 6, 1344);
    			attr_dev(div, "class", "arrow svelte-lgfbu");
    			set_style(div, "line-height", /*titleDesc*/ ctx[2] === '' ? '26px' : '39px');
    			add_location(div, file$F, 52, 4, 1258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			mount_component(arrowrightsline, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*titleDesc*/ 4) {
    				set_style(div, "line-height", /*titleDesc*/ ctx[2] === '' ? '26px' : '39px');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arrowrightsline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arrowrightsline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(arrowrightsline);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(52:2) {#if arrow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div4;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let div3;
    	let div2;
    	let current_block_type_index;
    	let if_block1;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*titleDesc*/ ctx[2] != '' && create_if_block_2$b(ctx);
    	const if_block_creators = [create_if_block_1$h, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*desc*/ ctx[4] === 'Switch') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = /*arrow*/ ctx[3] && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[1]);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div0, "class", "title-main svelte-lgfbu");
    			add_location(div0, file$F, 35, 4, 811);
    			attr_dev(div1, "class", "title svelte-lgfbu");
    			add_location(div1, file$F, 34, 2, 786);
    			attr_dev(div2, "class", "desc-title svelte-lgfbu");
    			add_location(div2, file$F, 41, 4, 972);
    			attr_dev(div3, "class", "desc svelte-lgfbu");
    			add_location(div3, file$F, 40, 2, 948);
    			attr_dev(div4, "class", "cell svelte-lgfbu");
    			add_location(div4, file$F, 33, 0, 723);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div4, t3);
    			if (if_block2) if_block2.m(div4, null);
    			/*div4_binding*/ ctx[7](div4);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div4, "click", /*cellClick*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 2) set_data_dev(t0, /*title*/ ctx[1]);

    			if (/*titleDesc*/ ctx[2] != '') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div2, null);
    			}

    			if (/*arrow*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*arrow*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$o(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div4, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			if (if_block2) if_block2.d();
    			/*div4_binding*/ ctx[7](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell', slots, []);
    	let cellDom;
    	let { title = '' } = $$props;
    	let { titleDesc = '' } = $$props;
    	let { arrow = false } = $$props;
    	let { desc = '' } = $$props;
    	let { cellCheck = false } = $$props;
    	const dispatch = createEventDispatcher();

    	onMount(() => {
    		if (cellDom) {
    			ripple(cellDom);
    		}
    	});

    	function cellClick() {
    		if (desc === 'Switch') {
    			$$invalidate(0, cellCheck = !cellCheck);
    			dispatch('cellClick', { cellCheck });
    		} else {
    			dispatch('cellClick');
    		}
    	}

    	const writable_props = ['title', 'titleDesc', 'arrow', 'desc', 'cellCheck'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell> was created with unknown prop '${key}'`);
    	});

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			cellDom = $$value;
    			$$invalidate(5, cellDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('titleDesc' in $$props) $$invalidate(2, titleDesc = $$props.titleDesc);
    		if ('arrow' in $$props) $$invalidate(3, arrow = $$props.arrow);
    		if ('desc' in $$props) $$invalidate(4, desc = $$props.desc);
    		if ('cellCheck' in $$props) $$invalidate(0, cellCheck = $$props.cellCheck);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		ArrowRightSLine,
    		ripple,
    		Switch,
    		cellDom,
    		title,
    		titleDesc,
    		arrow,
    		desc,
    		cellCheck,
    		dispatch,
    		cellClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('cellDom' in $$props) $$invalidate(5, cellDom = $$props.cellDom);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('titleDesc' in $$props) $$invalidate(2, titleDesc = $$props.titleDesc);
    		if ('arrow' in $$props) $$invalidate(3, arrow = $$props.arrow);
    		if ('desc' in $$props) $$invalidate(4, desc = $$props.desc);
    		if ('cellCheck' in $$props) $$invalidate(0, cellCheck = $$props.cellCheck);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cellCheck, title, titleDesc, arrow, desc, cellDom, cellClick, div4_binding];
    }

    class Cell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			title: 1,
    			titleDesc: 2,
    			arrow: 3,
    			desc: 4,
    			cellCheck: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get title() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleDesc() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleDesc(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get arrow() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set arrow(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get desc() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set desc(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cellCheck() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cellCheck(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Radio.svelte generated by Svelte v3.46.4 */
    const file$E = "src\\components\\base\\Radio.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (22:8) {:else}
    function create_else_block$a(ctx) {
    	let checkboxblankcircleline;
    	let current;

    	checkboxblankcircleline = new CheckboxBlankCircleLine({
    			props: {
    				size: "20",
    				color: "rgb(214, 214, 214)",
    				style: "vertical-align: middle;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(checkboxblankcircleline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkboxblankcircleline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkboxblankcircleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkboxblankcircleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkboxblankcircleline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(22:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:8) {#if active === i}
    function create_if_block$n(ctx) {
    	let radiobuttonline;
    	let current;

    	radiobuttonline = new RadioButtonLine({
    			props: {
    				size: "20",
    				color: "var(--primary-text-color)",
    				style: "vertical-align: middle;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(radiobuttonline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(radiobuttonline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radiobuttonline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radiobuttonline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radiobuttonline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(20:8) {#if active === i}",
    		ctx
    	});

    	return block;
    }

    // (17:2) {#each radioData as item, i}
    function create_each_block$e(ctx) {
    	let div3;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let div2;
    	let t1_value = /*item*/ ctx[5].text + "";
    	let t1;
    	let t2;
    	let div1;
    	let t3_value = /*item*/ ctx[5].desc + "";
    	let t3;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$n, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*active*/ ctx[0] === /*i*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*i*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			div2 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			attr_dev(div0, "class", "left svelte-9r3wbp");
    			add_location(div0, file$E, 18, 6, 470);
    			attr_dev(div1, "class", "desc svelte-9r3wbp");
    			add_location(div1, file$E, 27, 8, 834);
    			attr_dev(div2, "class", "text svelte-9r3wbp");
    			add_location(div2, file$E, 25, 6, 785);
    			attr_dev(div3, "class", "item svelte-9r3wbp");
    			add_location(div3, file$E, 17, 4, 414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, t3);
    			append_dev(div3, t4);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div3, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if ((!current || dirty & /*radioData*/ 2) && t1_value !== (t1_value = /*item*/ ctx[5].text + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*radioData*/ 2) && t3_value !== (t3_value = /*item*/ ctx[5].desc + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(17:2) {#each radioData as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div;
    	let current;
    	let each_value = /*radioData*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "box svelte-9r3wbp");
    			add_location(div, file$E, 15, 0, 359);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectFun, radioData, active*/ 7) {
    				each_value = /*radioData*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Radio', slots, []);
    	let { radioData = [] } = $$props;
    	let { active = 0 } = $$props;
    	const dispatch = createEventDispatcher();

    	function selectFun(index) {
    		$$invalidate(0, active = index);
    		dispatch("RadioClick", { active });
    	}

    	const writable_props = ['radioData', 'active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Radio> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => selectFun(i);

    	$$self.$$set = $$props => {
    		if ('radioData' in $$props) $$invalidate(1, radioData = $$props.radioData);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		CheckboxBlankCircleLine,
    		RadioButtonLine,
    		radioData,
    		active,
    		dispatch,
    		selectFun
    	});

    	$$self.$inject_state = $$props => {
    		if ('radioData' in $$props) $$invalidate(1, radioData = $$props.radioData);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [active, radioData, selectFun, click_handler];
    }

    class Radio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { radioData: 1, active: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Radio",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get radioData() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radioData(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Tip.svelte generated by Svelte v3.46.4 */

    const file$D = "src\\components\\base\\Tip.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (6:2) {#each tipTextList as tipText}
    function create_each_block$d(ctx) {
    	let div;
    	let t_value = /*tipText*/ ctx[1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "tip svelte-1515ufj");
    			add_location(div, file$D, 6, 4, 100);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tipTextList*/ 1 && t_value !== (t_value = /*tipText*/ ctx[1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(6:2) {#each tipTextList as tipText}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div;
    	let each_value = /*tipTextList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$D, 4, 0, 55);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tipTextList*/ 1) {
    				each_value = /*tipTextList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tip', slots, []);
    	let { tipTextList = "" } = $$props;
    	const writable_props = ['tipTextList'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tip> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('tipTextList' in $$props) $$invalidate(0, tipTextList = $$props.tipTextList);
    	};

    	$$self.$capture_state = () => ({ tipTextList });

    	$$self.$inject_state = $$props => {
    		if ('tipTextList' in $$props) $$invalidate(0, tipTextList = $$props.tipTextList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tipTextList];
    }

    class Tip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { tipTextList: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tip",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get tipTextList() {
    		throw new Error("<Tip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tipTextList(value) {
    		throw new Error("<Tip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Pagination.svelte generated by Svelte v3.46.4 */
    const file$C = "src\\components\\base\\Pagination.svelte";

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    const get_default_slot_changes_1 = dirty => ({ item: dirty & /*items*/ 1 });

    const get_default_slot_context_1 = ctx => ({
    	item: /*item*/ ctx[13],
    	index: /*index*/ ctx[15]
    });

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ item: dirty & /*items*/ 1 });

    const get_default_slot_context = ctx => ({
    	item: /*item*/ ctx[13],
    	index: /*index*/ ctx[15]
    });

    // (67:4) {#if items.length > 0}
    function create_if_block_1$g(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$a, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*grid*/ ctx[3] > 1) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(67:4) {#if items.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (74:6) {:else}
    function create_else_block_1$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*items*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$scope, items*/ 257) {
    				each_value_1 = /*items*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(74:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:6) {#if grid > 1}
    function create_if_block_2$a(ctx) {
    	let div;
    	let current;
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "grid-box svelte-16siq8o");
    			set_style(div, "grid-template-columns", "repeat(" + /*grid*/ ctx[3] + ", " + 300 / /*grid*/ ctx[3] + "px)");
    			add_location(div, file$C, 68, 8, 1741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$scope, items*/ 257) {
    				each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*grid*/ 8) {
    				set_style(div, "grid-template-columns", "repeat(" + /*grid*/ ctx[3] + ", " + 300 / /*grid*/ ctx[3] + "px)");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(68:6) {#if grid > 1}",
    		ctx
    	});

    	return block;
    }

    // (75:8) {#each items as item, index}
    function create_each_block_1$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context_1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, items*/ 257)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(75:8) {#each items as item, index}",
    		ctx
    	});

    	return block;
    }

    // (70:10) {#each items as item, index}
    function create_each_block$c(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, items*/ 257)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(70:10) {#each items as item, index}",
    		ctx
    	});

    	return block;
    }

    // (88:2) {:else}
    function create_else_block$9(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = " ";
    			attr_dev(div, "class", "no-more no-more-text svelte-16siq8o");
    			add_location(div, file$C, 88, 4, 2321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(88:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (81:2) {#if hasMore}
    function create_if_block$m(ctx) {
    	let div1;
    	let div0;
    	let embed;
    	let embed_src_value;
    	let t0;
    	let span;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			embed = element("embed");
    			t0 = space();
    			span = element("span");
    			span.textContent = " ...";
    			attr_dev(embed, "width", "40");
    			attr_dev(embed, "height", "40");
    			if (!src_url_equal(embed.src, embed_src_value = "/images/Ripple.svg")) attr_dev(embed, "src", embed_src_value);
    			attr_dev(embed, "type", "image/svg+xml");
    			add_location(embed, file$C, 83, 8, 2144);
    			add_location(div0, file$C, 82, 6, 2129);
    			attr_dev(span, "class", "no-more-text svelte-16siq8o");
    			add_location(span, file$C, 85, 6, 2244);
    			attr_dev(div1, "class", "no-more svelte-16siq8o");
    			add_location(div1, file$C, 81, 4, 2100);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, embed);
    			append_dev(div1, t0);
    			append_dev(div1, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(81:2) {#if hasMore}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*items*/ ctx[0].length > 0 && create_if_block_1$g(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*hasMore*/ ctx[2]) return create_if_block$m;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if_block1.c();
    			add_location(div0, file$C, 65, 2, 1650);
    			attr_dev(div1, "class", "pagination-box svelte-16siq8o");
    			set_style(div1, "height", /*paginationHeight*/ ctx[1] + "px");
    			add_location(div1, file$C, 59, 0, 1493);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			/*div0_binding*/ ctx[10](div0);
    			append_dev(div1, t);
    			if_block1.m(div1, null);
    			/*div1_binding*/ ctx[11](div1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "scroll", throttle$1(debounce(/*loadData*/ ctx[6], 500)), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*items*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*items*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			}

    			if (!current || dirty & /*paginationHeight*/ 2) {
    				set_style(div1, "height", /*paginationHeight*/ ctx[1] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			/*div0_binding*/ ctx[10](null);
    			if_block1.d();
    			/*div1_binding*/ ctx[11](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function debounce(fn, delay) {
    	let timer = null;

    	return function () {
    		if (timer) {
    			clearTimeout(timer);
    		}

    		timer = setTimeout(
    			() => {
    				//change
    				fn.apply(this, arguments);

    				// 
    				timer = null;
    			},
    			delay
    		);
    	};
    }

    // 
    function throttle$1(fn, delay = 50) {
    	let timer = null;

    	return function () {
    		if (timer) {
    			return;
    		}

    		timer = setTimeout(
    			() => {
    				fn.apply(this, arguments);
    				timer = null;
    			},
    			delay
    		);
    	};
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Pagination', slots, ['default']);
    	let { bottomHeight = 0 } = $$props;
    	let { items = [] } = $$props;
    	let { paginationHeight = 0 } = $$props;
    	let { hasMore = true } = $$props;
    	let { grid = 1 } = $$props;
    	let paginationDom;
    	let paginationBoxDom;

    	//  
    	const dispatch = createEventDispatcher();

    	//  
    	let loadData = function () {
    		if (!items || items.length == 0) return;

    		// scrollTop
    		const scrollTop = paginationBoxDom.scrollTop;

    		//windowHeight
    		const windowHeight = document.documentElement.clientHeight || document.body.clientHeight;

    		//scrollHeight
    		const scrollHeight = paginationDom.scrollHeight;

    		// ;
    		if (scrollTop + windowHeight + bottomHeight >= scrollHeight) {
    			dispatch('load');
    		}
    	};

    	const writable_props = ['bottomHeight', 'items', 'paginationHeight', 'hasMore', 'grid'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pagination> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			paginationDom = $$value;
    			$$invalidate(4, paginationDom);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			paginationBoxDom = $$value;
    			$$invalidate(5, paginationBoxDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('bottomHeight' in $$props) $$invalidate(7, bottomHeight = $$props.bottomHeight);
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('paginationHeight' in $$props) $$invalidate(1, paginationHeight = $$props.paginationHeight);
    		if ('hasMore' in $$props) $$invalidate(2, hasMore = $$props.hasMore);
    		if ('grid' in $$props) $$invalidate(3, grid = $$props.grid);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		bottomHeight,
    		items,
    		paginationHeight,
    		hasMore,
    		grid,
    		paginationDom,
    		paginationBoxDom,
    		dispatch,
    		loadData,
    		debounce,
    		throttle: throttle$1
    	});

    	$$self.$inject_state = $$props => {
    		if ('bottomHeight' in $$props) $$invalidate(7, bottomHeight = $$props.bottomHeight);
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('paginationHeight' in $$props) $$invalidate(1, paginationHeight = $$props.paginationHeight);
    		if ('hasMore' in $$props) $$invalidate(2, hasMore = $$props.hasMore);
    		if ('grid' in $$props) $$invalidate(3, grid = $$props.grid);
    		if ('paginationDom' in $$props) $$invalidate(4, paginationDom = $$props.paginationDom);
    		if ('paginationBoxDom' in $$props) $$invalidate(5, paginationBoxDom = $$props.paginationBoxDom);
    		if ('loadData' in $$props) $$invalidate(6, loadData = $$props.loadData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		items,
    		paginationHeight,
    		hasMore,
    		grid,
    		paginationDom,
    		paginationBoxDom,
    		loadData,
    		bottomHeight,
    		$$scope,
    		slots,
    		div0_binding,
    		div1_binding
    	];
    }

    class Pagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			bottomHeight: 7,
    			items: 0,
    			paginationHeight: 1,
    			hasMore: 2,
    			grid: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pagination",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get bottomHeight() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomHeight(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get paginationHeight() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paginationHeight(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasMore() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasMore(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grid() {
    		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grid(value) {
    		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Title.svelte generated by Svelte v3.46.4 */
    const file$B = "src\\components\\base\\Title.svelte";

    // (23:2) {#if isShowRight}
    function create_if_block$l(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let span;
    	let arrowrightsline;
    	let current;

    	arrowrightsline = new ArrowRightSLine({
    			props: {
    				size: "24",
    				style: "vertical-align: middle;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*iconText*/ ctx[2]);
    			t1 = space();
    			span = element("span");
    			create_component(arrowrightsline.$$.fragment);
    			attr_dev(span, "class", "title-icon svelte-1r560jd");
    			add_location(span, file$B, 25, 6, 656);
    			attr_dev(div, "class", "title-right svelte-1r560jd");
    			add_location(div, file$B, 23, 4, 605);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, span);
    			mount_component(arrowrightsline, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*iconText*/ 4) set_data_dev(t0, /*iconText*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arrowrightsline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arrowrightsline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(arrowrightsline);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(23:2) {#if isShowRight}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*isShowRight*/ ctx[1] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (if_block) if_block.c();
    			add_location(div0, file$B, 21, 2, 560);
    			attr_dev(div1, "class", "title svelte-1r560jd");
    			add_location(div1, file$B, 20, 0, 491);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			if (if_block) if_block.m(div1, null);
    			/*div1_binding*/ ctx[5](div1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*setTitleClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (/*isShowRight*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isShowRight*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			/*div1_binding*/ ctx[5](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Title', slots, []);
    	let { title = 'Title' } = $$props;
    	let { isShowRight = false } = $$props;
    	let { iconText = '' } = $$props;
    	let titleDom;
    	const dispatch = createEventDispatcher();

    	function setTitleClick() {
    		dispatch('TitleClick');
    	}

    	onMount(() => {
    		if (titleDom) ripple(titleDom);
    	});

    	const writable_props = ['title', 'isShowRight', 'iconText'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Title> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			titleDom = $$value;
    			$$invalidate(3, titleDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('isShowRight' in $$props) $$invalidate(1, isShowRight = $$props.isShowRight);
    		if ('iconText' in $$props) $$invalidate(2, iconText = $$props.iconText);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		ArrowRightSLine,
    		ripple,
    		title,
    		isShowRight,
    		iconText,
    		titleDom,
    		dispatch,
    		setTitleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('isShowRight' in $$props) $$invalidate(1, isShowRight = $$props.isShowRight);
    		if ('iconText' in $$props) $$invalidate(2, iconText = $$props.iconText);
    		if ('titleDom' in $$props) $$invalidate(3, titleDom = $$props.titleDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, isShowRight, iconText, titleDom, setTitleClick, div1_binding];
    }

    class Title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { title: 0, isShowRight: 1, iconText: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get title() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isShowRight() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isShowRight(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconText() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconText(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\base\Picker.svelte generated by Svelte v3.46.4 */
    const file$A = "src\\components\\base\\Picker.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (35:6) {#each list as l, i}
    function create_each_block$b(ctx) {
    	let div;
    	let t_value = /*l*/ ctx[7].name + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*i*/ ctx[9], /*l*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "li svelte-wlt91d");
    			add_location(div, file$A, 35, 8, 916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*list*/ 2 && t_value !== (t_value = /*l*/ ctx[7].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(35:6) {#each list as l, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div4;
    	let div3;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let divider;
    	let t2;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;
    	divider = new Divider({ $$inline: true });
    	let each_value = /*list*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[2]);
    			t1 = space();
    			create_component(divider.$$.fragment);
    			t2 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "btn-item btn-center svelte-wlt91d");
    			add_location(div0, file$A, 29, 6, 720);
    			attr_dev(div1, "class", "btn svelte-wlt91d");
    			add_location(div1, file$A, 27, 4, 639);
    			attr_dev(div2, "class", "roller svelte-wlt91d");
    			add_location(div2, file$A, 33, 4, 858);
    			attr_dev(div3, "class", "pick svelte-wlt91d");
    			set_style(div3, "bottom", /*isShow*/ ctx[0] ? '0px' : '-350px');
    			add_location(div3, file$A, 26, 2, 572);
    			attr_dev(div4, "class", "pick-mask svelte-wlt91d");
    			set_style(div4, "display", /*isShow*/ ctx[0] ? 'block' : 'none');
    			add_location(div4, file$A, 25, 0, 474);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			mount_component(divider, div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div4, "click", /*changeShowFun*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 4) set_data_dev(t0, /*title*/ ctx[2]);

    			if (dirty & /*liClickFun, list*/ 10) {
    				each_value = /*list*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*isShow*/ 1) {
    				set_style(div3, "bottom", /*isShow*/ ctx[0] ? '0px' : '-350px');
    			}

    			if (!current || dirty & /*isShow*/ 1) {
    				set_style(div4, "display", /*isShow*/ ctx[0] ? 'block' : 'none');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(divider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(divider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(divider);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Picker', slots, []);
    	let { list = [] } = $$props;
    	let { title = "" } = $$props;
    	let { isShow = false } = $$props;
    	const dispatch = createEventDispatcher();

    	function liClickFun(index, item) {
    		dispatch("PickerClick", { index, item });
    	}

    	function changeShowFun() {
    		$$invalidate(0, isShow = false);
    		dispatch("ChangeShow", { isShow });
    	}

    	const writable_props = ['list', 'title', 'isShow'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Picker> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, l) => liClickFun(i, l);

    	$$self.$$set = $$props => {
    		if ('list' in $$props) $$invalidate(1, list = $$props.list);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('isShow' in $$props) $$invalidate(0, isShow = $$props.isShow);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Divider,
    		list,
    		title,
    		isShow,
    		dispatch,
    		liClickFun,
    		changeShowFun
    	});

    	$$self.$inject_state = $$props => {
    		if ('list' in $$props) $$invalidate(1, list = $$props.list);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('isShow' in $$props) $$invalidate(0, isShow = $$props.isShow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isShow, list, title, liClickFun, changeShowFun, click_handler];
    }

    class Picker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { list: 1, title: 2, isShow: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Picker",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get list() {
    		throw new Error("<Picker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Picker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Picker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Picker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isShow() {
    		throw new Error("<Picker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isShow(value) {
    		throw new Error("<Picker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    //true/false
    const playStatusStore = writable(false);
    //true/false
    const playIsMaxStore = writable(false);
    //true/false
    const playIsMinStore = writable(true);
    //
    const currentSongStore = writable(
      JSON.parse(localStorage.getItem('currentSong'))
        ? JSON.parse(localStorage.getItem('currentSong'))
        : {
            name: '',
            al: {
              picUrl: '/images/defaultCover.png',
            },
            url: 'https://m8.music.126.net/20210907010112/541ee038536db12045e4a99d565becd8/ymusic/5614/195d/ad51/33fff191fffc2fd5da6c94d71e7777ef.mp3',
            ar: [{ name: '' }],
          }
    );
    //
    const currentSongIndexStore = writable(0);
    //
    const currentPlayListStore = writable([
      JSON.parse(localStorage.getItem('currentSong'))
        ? JSON.parse(localStorage.getItem('currentSong'))
        : {
            name: '',
            al: {
              picUrl: '/images/defaultCover.png',
            },
            url: 'https://m8.music.126.net/20210907010112/541ee038536db12045e4a99d565becd8/ymusic/5614/195d/ad51/33fff191fffc2fd5da6c94d71e7777ef.mp3',
            ar: [{ name: '' }],
          },
    ]);
    //
    const maxPlayToTopStore = writable('100%');

    //FM
    const isFMPlayStore = writable(localStorage.getItem('isFMPlay') === '1' ? true : false);
    //FM
    const FMPlayStore = writable(
      JSON.parse(localStorage.getItem('FMPlay')) ? JSON.parse(localStorage.getItem('FMPlay')) : {}
    );
    //FM
    const FMPlayNextStore = writable({});
    //
    const currentTimeStore = writable('');
    //
    const currentLyricStore = writable(
      JSON.parse(localStorage.getItem('currentLyric'))
        ? JSON.parse(localStorage.getItem('currentLyric'))
        : {
            songId: '',
            lyric: '',
            tlyric: '',
          }
    );
    //cover--list--lyric--
    const mainCoverTypeStore = writable('cover');
    //repeat--repeatOnce--shuffle--heart--
    const playRepeatModelStore = writable('repeat');
    //
    const currentSongQualityStore = writable(128000);
    //
    const showVisualizerStore = writable(localStorage.getItem('showVisualizer') === '1' ? '1' : '0');

    /* src\components\Lyric.svelte generated by Svelte v3.46.4 */
    const file$z = "src\\components\\Lyric.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    // (286:8) {#if tlyric.trim() !== ''}
    function create_if_block$k(ctx) {
    	let div;
    	let t_value = /*lyric*/ ctx[6].text_t + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "t-text svelte-145k8f8");
    			add_location(div, file$z, 286, 10, 9734);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lyricArr*/ 16 && t_value !== (t_value = /*lyric*/ ctx[6].text_t + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(286:8) {#if tlyric.trim() !== ''}",
    		ctx
    	});

    	return block;
    }

    // (273:4) {#each lyricArr as lyric, i}
    function create_each_block$a(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*lyric*/ ctx[6].text + "";
    	let t0;
    	let t1;
    	let show_if = /*tlyric*/ ctx[5].trim() !== '';
    	let t2;
    	let if_block = show_if && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			add_location(div0, file$z, 284, 8, 9663);
    			attr_dev(div1, "class", "ly svelte-145k8f8");

    			set_style(div1, "filter", /*isBlue*/ ctx[2] && /*i*/ ctx[20] !== /*currentIndex*/ ctx[3]
    			? `blur(${Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) < 7
				? Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) * 1
				: 0}px)`
    			: 'none');

    			set_style(div1, "-webkit-filter", /*isBlue*/ ctx[2] && /*i*/ ctx[20] !== /*currentIndex*/ ctx[3]
    			? `blur(${Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) < 7
				? Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) * 1
				: 0}px)`
    			: 'none');

    			toggle_class(div1, "active", /*i*/ ctx[20] === /*currentIndex*/ ctx[3]);
    			add_location(div1, file$z, 273, 6, 9229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lyricArr*/ 16 && t0_value !== (t0_value = /*lyric*/ ctx[6].text + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*tlyric*/ 32) show_if = /*tlyric*/ ctx[5].trim() !== '';

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					if_block.m(div1, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*isBlue, currentIndex*/ 12) {
    				set_style(div1, "filter", /*isBlue*/ ctx[2] && /*i*/ ctx[20] !== /*currentIndex*/ ctx[3]
    				? `blur(${Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) < 7
					? Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) * 1
					: 0}px)`
    				: 'none');
    			}

    			if (dirty & /*isBlue, currentIndex*/ 12) {
    				set_style(div1, "-webkit-filter", /*isBlue*/ ctx[2] && /*i*/ ctx[20] !== /*currentIndex*/ ctx[3]
    				? `blur(${Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) < 7
					? Math.abs(/*i*/ ctx[20] - /*currentIndex*/ ctx[3]) * 1
					: 0}px)`
    				: 'none');
    			}

    			if (dirty & /*currentIndex*/ 8) {
    				toggle_class(div1, "active", /*i*/ ctx[20] === /*currentIndex*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(273:4) {#each lyricArr as lyric, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div1;
    	let div0;
    	let mounted;
    	let dispose;
    	let each_value = /*lyricArr*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "box svelte-145k8f8");
    			set_style(div0, "max-height", /*maxHeight*/ ctx[0]);
    			add_location(div0, file$z, 264, 2, 9011);
    			attr_dev(div1, "class", "xbox");
    			add_location(div1, file$z, 263, 0, 8989);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[11](div0);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "touchstart", /*touchStart*/ ctx[7], false, false, false),
    					listen_dev(div0, "touchend", /*touchEnd*/ ctx[8], false, false, false),
    					listen_dev(div0, "touchmove", touchMove, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isBlue, currentIndex, Math, lyricArr, tlyric*/ 60) {
    				each_value = /*lyricArr*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*maxHeight*/ 1) {
    				set_style(div0, "max-height", /*maxHeight*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function sum(arr) {
    	if (Array.isArray(arr)) {
    		var arrSum = 0;

    		for (var i = 0; i < arr.length; i++) {
    			arrSum += arr[i];
    		}

    		return arrSum;
    	}
    }

    //text
    function formatLyric(text) {
    	//
    	if (text.slice(1, 3) === 'by') {
    		text = text.slice(text.indexOf('\n') + 1);
    	}

    	let lyricNew = [];
    	let arr = text.split('\n'); //\n
    	let row = arr.length; //

    	for (let i = 0; i < row; i++) {
    		let temp_row = arr[i]; //"[00:04.302][02:10.00]hello world";
    		let temp_arr = temp_row.split(']'); //]
    		let text = temp_arr.pop(); //

    		//
    		temp_arr.forEach(element => {
    			let obj = {};
    			let time_arr = element.substr(1, element.length - 1).split(':'); //[
    			let s = Math.ceil(time_arr[0]) * 60 + Math.ceil(time_arr[1]); //currentTime
    			obj.time = s > 0 ? s - 1 : s; //
    			obj.text = text.trim(); //
    			lyricNew.push(obj); //lyric
    		});
    	}

    	if (lyricNew.length === 1) {
    		lyricNew = [{ time: 0, text: lyricNew[0].text }, { time: 0, text: lyricNew[0].text }];
    	}

    	if (lyricNew === []) return [];

    	for (let u = 0; u < lyricNew.length; u++) {
    		if (lyricNew[u].text === '') lyricNew[u].text = '  ';
    	}

    	if (lyricNew.length > 0) {
    		if (lyricNew[0].time > 5) {
    			lyricNew.splice(0, 0, { time: 0, text: '  ' });
    		}
    	}

    	for (let i = lyricNew.length - 1; i > 0; i--) {
    		if (lyricNew[i].time - lyricNew[i - 1].time < 2 && lyricNew[i - 1].text === '  ') {
    			lyricNew.splice(i - 1, 1);
    		}
    	}

    	for (let d = lyricNew.length - 1; d > 0; d--) {
    		if (lyricNew[d - 1].time === lyricNew[d].time) {
    			lyricNew[d - 1].text = lyricNew[d - 1].text + ' ' + lyricNew[d].text;
    			lyricNew.splice(d, 1);
    		}
    	}

    	// 
    	if (lyricNew.length > 1 && lyricNew[0].time === lyricNew[1].time) {
    		lyricNew[0].text = lyricNew[0].text + ' ' + lyricNew[1].text;
    		lyricNew.splice(1, 1);
    	}

    	//  
    	for (let q = 0; q < lyricNew.length; q++) {
    		if (lyricNew[q].text.substring(lyricNew[q].text.length - 5) === '  ' && lyricNew[q].text != '  ') {
    			lyricNew[q].text = lyricNew[q].text.substr(0, lyricNew[q].text.length - 5);
    		}
    	}

    	lyricNew.sort(sortRule); //

    	return lyricNew.length === 0
    	? [
    			{
    				time: 0,
    				text: '',
    				start: 0,
    				end: 20
    			}
    		]
    	: lyricNew;
    }

    function timeAdd(arr) {
    	for (let t = 0; t < arr.length - 1; t++) {
    		arr[t].start = arr[t].time;
    		arr[t].end = arr[t + 1].time;
    	}

    	arr[arr.length - 1].start = arr[arr.length - 1].time;
    	return arr;
    }

    function sortRule(a, b) {
    	//
    	return a.time - b.time;
    }

    function textSize(fontSize, text) {
    	let div = document.createElement('div');
    	let result = {};
    	result.width = div.offsetWidth;
    	result.height = div.offsetHeight;
    	div.style.visibility = 'hidden';
    	div.style.fontSize = fontSize;

    	// div.style.fontFamily =
    	//   '"PingFang SC", "Lantinghei SC", "Microsoft YaHei", "HanHei SC","Helvetica Neue", "Open Sans", Arial, "Hiragino Sans GB", "",STHeiti, "WenQuanYi Micro Hei", SimSun, sans-serif';
    	div.style.padding = '20px';

    	div.style.wordWrap = 'break-word';
    	div.style.fontWeight = 'bold';
    	div.style.textAlign = 'justify';
    	document.body.appendChild(div);

    	if (typeof div.textContent != 'undefined') {
    		div.textContent = text;
    	} else {
    		div.innerText = text;
    	}

    	result.width = parseFloat(window.getComputedStyle(div).width) - result.width;
    	result.height = parseFloat(window.getComputedStyle(div).height) - result.height;
    	div.style.display = 'none';
    	return result;
    }

    function touchMove(e) {
    	
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let lyric;
    	let tlyric;
    	let lyricArr;
    	let tlyricArr;
    	let lyricArrStartAndEnd;
    	let currentIndex;
    	let itemHeightList;
    	let isBlue;
    	let $currentTimeStore;
    	let $currentLyricStore;
    	let $isShowTranslateStore;
    	validate_store(currentTimeStore, 'currentTimeStore');
    	component_subscribe($$self, currentTimeStore, $$value => $$invalidate(16, $currentTimeStore = $$value));
    	validate_store(currentLyricStore, 'currentLyricStore');
    	component_subscribe($$self, currentLyricStore, $$value => $$invalidate(9, $currentLyricStore = $$value));
    	validate_store(isShowTranslateStore, 'isShowTranslateStore');
    	component_subscribe($$self, isShowTranslateStore, $$value => $$invalidate(10, $isShowTranslateStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lyric', slots, []);
    	let { maxHeight = '' } = $$props;
    	let boxDom;
    	let scrollTimer = null;

    	onMount(() => {
    		//
    		$$invalidate(4, lyricArr = formatLyric(lyric));

    		//
    		if (tlyric.slice(1, 3) === 'by') {
    			$$invalidate(5, tlyric = tlyric.slice(tlyric.indexOf('\n') + 1));
    		}

    		//
    		if (tlyric.slice(0, 1) !== '[') {
    			$$invalidate(5, tlyric = '');
    		}

    		//
    		let textArr = tlyric.split('\n');

    		let isAllNull = false;

    		for (let t = 0; t < textArr.length; t++) {
    			if (textArr[t].substring(textArr[t].length - 1) != ']') {
    				isAllNull = false;
    			} else {
    				isAllNull = true;
    			}
    		}

    		if (isAllNull) $$invalidate(5, tlyric = '');
    		if (tlyric.trim() !== '') tlyricArr = formatLyric(tlyric);

    		if (tlyric.trim() !== '') {
    			if (lyricArr[0].time !== 0) {
    				lyricArr.unshift({ time: 0, text: '  ' });
    			}

    			if (tlyricArr[0].time !== 0) {
    				tlyricArr.unshift({ time: 0, text: '  ' });
    			}

    			for (let e = 0; e < lyricArr.length; e++) {
    				for (let r = 0; r < tlyricArr.length; r++) {
    					if (lyricArr[e].time === tlyricArr[r].time) $$invalidate(4, lyricArr[e].text_t = tlyricArr[r].text, lyricArr);
    					if (lyricArr[e].text_t === undefined) $$invalidate(4, lyricArr[e].text_t = '  ', lyricArr);
    				}
    			}

    			lyricArrStartAndEnd = lyricArr.length > 0 ? timeAdd(lyricArr) : [];

    			for (let r = 0; r < lyricArr.length; r++) {
    				itemHeightList.push(40 + textSize('28px', lyricArr[r].text).height + textSize('16px', lyricArr[r].text_t).height);
    			}
    		} else {
    			lyricArrStartAndEnd = lyricArr.length > 0 ? timeAdd(lyricArr) : [];

    			for (let r = 0; r < lyricArrStartAndEnd.length; r++) {
    				itemHeightList.push(textSize('28px', lyricArrStartAndEnd[r].text).height + 40);
    			}
    		}

    		autoScrollFun();
    	});

    	//
    	function autoScrollFun() {
    		scrollTimer = setInterval(
    			() => {
    				if (boxDom) {
    					for (let y = 0; y < lyricArrStartAndEnd.length - 1; y++) {
    						if (Math.ceil($currentTimeStore) >= lyricArrStartAndEnd[lyricArrStartAndEnd.length - 1].start) {
    							$$invalidate(3, currentIndex = lyricArrStartAndEnd.length - 1);
    							$$invalidate(1, boxDom.scrollTop = boxDom.scrollHeight - boxDom.clientHeight, boxDom);
    						}

    						if (Math.ceil($currentTimeStore) >= lyricArrStartAndEnd[y].start && Math.ceil($currentTimeStore) < lyricArrStartAndEnd[y].end) {
    							$$invalidate(3, currentIndex = y);
    							boxDom.scrollIntoView({ block: 'start', behavior: 'smooth' });

    							if (currentIndex === 0) {
    								if ('scrollBehavior' in boxDom.style) {
    									$$invalidate(1, boxDom.scrollTop = 0, boxDom);
    								} else {
    									scrollSmoothTo(boxDom, 0);
    								}
    							} else {
    								if ('scrollBehavior' in boxDom.style) {
    									$$invalidate(1, boxDom.scrollTop = sum(itemHeightList.slice(0, currentIndex - 1)), boxDom);
    								} else {
    									scrollSmoothTo(boxDom, sum(itemHeightList.slice(0, currentIndex - 1)));
    								}
    							}
    						}
    					}
    				}
    			},
    			1000
    		);
    	}

    	function touchStart(e) {
    		$$invalidate(2, isBlue = false);
    		if (scrollTimer) clearInterval(scrollTimer);
    		scrollTimer = null;
    	}

    	function touchEnd(e) {
    		$$invalidate(2, isBlue = true);
    		if (scrollTimer) clearInterval(scrollTimer);
    		scrollTimer = null;
    		autoScrollFun();
    	}

    	//iOS
    	function myScrollTo(dom, position, timeout) {
    		let scrollTop = dom.scrollTop;
    		let direction = position - scrollTop > 0 ? 1 : -1;
    		let distance = Math.abs(position - scrollTop);
    		let split = distance / 50;
    		let _timeout;

    		if (position !== scrollTop) {
    			timeout = timeout || 1000;
    			split *= direction;

    			_timeout = setInterval(
    				function () {
    					if (!isBlue) {
    						if (_timeout) clearInterval(_timeout);
    						_timeout = null;
    					}

    					scrollTop += split;
    					distance -= Math.abs(split);

    					if (0 >= distance) {
    						dom.scrollTo(0, position);
    						clearInterval(_timeout);
    						_timeout = null;
    					} else {
    						dom.scrollTo(0, scrollTop);
    					}
    				},
    				timeout / 100
    			);
    		}
    	}

    	const writable_props = ['maxHeight'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lyric> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			boxDom = $$value;
    			$$invalidate(1, boxDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('maxHeight' in $$props) $$invalidate(0, maxHeight = $$props.maxHeight);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		currentTimeStore,
    		currentLyricStore,
    		isShowTranslateStore,
    		scrollSmoothTo,
    		maxHeight,
    		boxDom,
    		scrollTimer,
    		autoScrollFun,
    		sum,
    		formatLyric,
    		timeAdd,
    		sortRule,
    		textSize,
    		touchStart,
    		touchMove,
    		touchEnd,
    		myScrollTo,
    		isBlue,
    		currentIndex,
    		itemHeightList,
    		lyricArrStartAndEnd,
    		lyricArr,
    		tlyricArr,
    		tlyric,
    		lyric,
    		$currentTimeStore,
    		$currentLyricStore,
    		$isShowTranslateStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('maxHeight' in $$props) $$invalidate(0, maxHeight = $$props.maxHeight);
    		if ('boxDom' in $$props) $$invalidate(1, boxDom = $$props.boxDom);
    		if ('scrollTimer' in $$props) scrollTimer = $$props.scrollTimer;
    		if ('isBlue' in $$props) $$invalidate(2, isBlue = $$props.isBlue);
    		if ('currentIndex' in $$props) $$invalidate(3, currentIndex = $$props.currentIndex);
    		if ('itemHeightList' in $$props) itemHeightList = $$props.itemHeightList;
    		if ('lyricArrStartAndEnd' in $$props) lyricArrStartAndEnd = $$props.lyricArrStartAndEnd;
    		if ('lyricArr' in $$props) $$invalidate(4, lyricArr = $$props.lyricArr);
    		if ('tlyricArr' in $$props) tlyricArr = $$props.tlyricArr;
    		if ('tlyric' in $$props) $$invalidate(5, tlyric = $$props.tlyric);
    		if ('lyric' in $$props) $$invalidate(6, lyric = $$props.lyric);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$currentLyricStore*/ 512) {
    			$$invalidate(6, lyric = $currentLyricStore.lyric);
    		}

    		if ($$self.$$.dirty & /*$isShowTranslateStore, $currentLyricStore*/ 1536) {
    			$$invalidate(5, tlyric = $isShowTranslateStore ? $currentLyricStore.tlyric : '');
    		}
    	};

    	$$invalidate(4, lyricArr = []);
    	tlyricArr = [];
    	lyricArrStartAndEnd = [];
    	$$invalidate(3, currentIndex = 0);
    	itemHeightList = [];
    	$$invalidate(2, isBlue = true);

    	return [
    		maxHeight,
    		boxDom,
    		isBlue,
    		currentIndex,
    		lyricArr,
    		tlyric,
    		lyric,
    		touchStart,
    		touchEnd,
    		$currentLyricStore,
    		$isShowTranslateStore,
    		div0_binding
    	];
    }

    class Lyric extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { maxHeight: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lyric",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get maxHeight() {
    		throw new Error("<Lyric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxHeight(value) {
    		throw new Error("<Lyric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* node_modules\svelte-lazy\src\components\Placeholder.svelte generated by Svelte v3.46.4 */

    const file$y = "node_modules\\svelte-lazy\\src\\components\\Placeholder.svelte";

    // (1:0) {#if placeholder}
    function create_if_block$j(ctx) {
    	let div;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_1$f, create_if_block_2$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*placeholder*/ 1) show_if = null;
    		if (typeof /*placeholder*/ ctx[0] === 'string') return 0;
    		if (show_if == null) show_if = !!['function', 'object'].includes(typeof /*placeholder*/ ctx[0]);
    		if (show_if) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx, -1))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", placeholderClass);
    			add_location(div, file$y, 1, 2, 20);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(1:0) {#if placeholder}",
    		ctx
    	});

    	return block;
    }

    // (5:66) 
    function create_if_block_2$9(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*placeholderProps*/ ctx[1]];
    	var switch_value = /*placeholder*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*placeholderProps*/ 2)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*placeholderProps*/ ctx[1])])
    			: {};

    			if (switch_value !== (switch_value = /*placeholder*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(5:66) ",
    		ctx
    	});

    	return block;
    }

    // (3:4) {#if typeof placeholder === 'string'}
    function create_if_block_1$f(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*placeholder*/ ctx[0]);
    			add_location(div, file$y, 3, 6, 99);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*placeholder*/ 1) set_data_dev(t, /*placeholder*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(3:4) {#if typeof placeholder === 'string'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*placeholder*/ ctx[0] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*placeholder*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*placeholder*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const placeholderClass = 'svelte-lazy-placeholder';

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Placeholder', slots, []);
    	let { placeholder = null } = $$props;
    	let { placeholderProps = null } = $$props;
    	const writable_props = ['placeholder', 'placeholderProps'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Placeholder> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
    		if ('placeholderProps' in $$props) $$invalidate(1, placeholderProps = $$props.placeholderProps);
    	};

    	$$self.$capture_state = () => ({
    		placeholder,
    		placeholderProps,
    		placeholderClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
    		if ('placeholderProps' in $$props) $$invalidate(1, placeholderProps = $$props.placeholderProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [placeholder, placeholderProps];
    }

    class Placeholder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { placeholder: 0, placeholderProps: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Placeholder",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get placeholder() {
    		throw new Error("<Placeholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Placeholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholderProps() {
    		throw new Error("<Placeholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholderProps(value) {
    		throw new Error("<Placeholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-lazy\src\index.svelte generated by Svelte v3.46.4 */
    const file$x = "node_modules\\svelte-lazy\\src\\index.svelte";

    // (13:24) 
    function create_if_block_2$8(ctx) {
    	let placeholder_1;
    	let current;

    	placeholder_1 = new Placeholder({
    			props: {
    				placeholder: /*placeholder*/ ctx[1],
    				placeholderProps: /*placeholderProps*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(placeholder_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(placeholder_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const placeholder_1_changes = {};
    			if (dirty & /*placeholder*/ 2) placeholder_1_changes.placeholder = /*placeholder*/ ctx[1];
    			if (dirty & /*placeholderProps*/ 4) placeholder_1_changes.placeholderProps = /*placeholderProps*/ ctx[2];
    			placeholder_1.$set(placeholder_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(placeholder_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(placeholder_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(placeholder_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(13:24) ",
    		ctx
    	});

    	return block;
    }

    // (2:2) {#if loaded}
    function create_if_block$i(ctx) {
    	let div;
    	let div_intro;
    	let t;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);
    	let if_block = !/*contentShow*/ ctx[3] && /*placeholder*/ ctx[1] && create_if_block_1$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "class", contentClass);
    			attr_dev(div, "style", /*contentStyle*/ ctx[5]);
    			add_location(div, file$x, 2, 4, 88);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*contentStyle*/ 32) {
    				attr_dev(div, "style", /*contentStyle*/ ctx[5]);
    			}

    			if (!/*contentShow*/ ctx[3] && /*placeholder*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*contentShow, placeholder*/ 10) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);

    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, /*fadeOption*/ ctx[0] || {});
    					div_intro.start();
    				});
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(2:2) {#if loaded}",
    		ctx
    	});

    	return block;
    }

    // (8:12) Lazy load content
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Lazy load content");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(8:12) Lazy load content",
    		ctx
    	});

    	return block;
    }

    // (10:4) {#if !contentShow && placeholder}
    function create_if_block_1$e(ctx) {
    	let placeholder_1;
    	let current;

    	placeholder_1 = new Placeholder({
    			props: {
    				placeholder: /*placeholder*/ ctx[1],
    				placeholderProps: /*placeholderProps*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(placeholder_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(placeholder_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const placeholder_1_changes = {};
    			if (dirty & /*placeholder*/ 2) placeholder_1_changes.placeholder = /*placeholder*/ ctx[1];
    			if (dirty & /*placeholderProps*/ 4) placeholder_1_changes.placeholderProps = /*placeholderProps*/ ctx[2];
    			placeholder_1.$set(placeholder_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(placeholder_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(placeholder_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(placeholder_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(10:4) {#if !contentShow && placeholder}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$i, create_if_block_2$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*loaded*/ ctx[4]) return 0;
    		if (/*placeholder*/ ctx[1]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", /*rootClass*/ ctx[6]);
    			set_style(div, "height", /*rootInitialHeight*/ ctx[7]);
    			add_location(div, file$x, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*load*/ ctx[8].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const contentClass = 'svelte-lazy-content';

    function addListeners(handler) {
    	document.addEventListener('scroll', handler, true);
    	window.addEventListener('resize', handler);
    }

    function removeListeners(handler) {
    	document.removeEventListener('scroll', handler, true);
    	window.removeEventListener('resize', handler);
    }

    function getContainerHeight(e) {
    	if (e && e.target && e.target.getBoundingClientRect) {
    		return e.target.getBoundingClientRect().bottom;
    	} else {
    		return window.innerHeight;
    	}
    }

    // From underscore souce code
    function throttle(func, wait, options) {
    	let context, args, result;
    	let timeout = null;
    	let previous = 0;
    	if (!options) options = {};

    	const later = function () {
    		previous = options.leading === false ? 0 : new Date();
    		timeout = null;
    		result = func.apply(context, args);
    		if (!timeout) context = args = null;
    	};

    	return function (event) {
    		const now = new Date();
    		if (!previous && options.leading === false) previous = now;
    		const remaining = wait - (now - previous);
    		context = this;
    		args = arguments;

    		if (remaining <= 0 || remaining > wait) {
    			if (timeout) {
    				clearTimeout(timeout);
    				timeout = null;
    			}

    			previous = now;
    			result = func.apply(context, args);
    			if (!timeout) context = args = null;
    		} else if (!timeout && options.trailing !== false) {
    			timeout = setTimeout(later, remaining);
    		}

    		return result;
    	};
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let contentStyle;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Src', slots, ['default']);
    	let { height = 0 } = $$props;
    	let { offset = 150 } = $$props;
    	let { fadeOption = { delay: 0, duration: 400 } } = $$props;
    	let { resetHeightDelay = 0 } = $$props;
    	let { onload = null } = $$props;
    	let { placeholder = null } = $$props;
    	let { placeholderProps = null } = $$props;
    	let { class: className = '' } = $$props;
    	const rootClass = 'svelte-lazy' + (className ? ' ' + className : '');
    	const rootInitialHeight = getStyleHeight();
    	let loaded = false;
    	let contentShow = true;

    	function load(node) {
    		setHeight(node);

    		const loadHandler = throttle(
    			e => {
    				const nodeTop = node.getBoundingClientRect().top;
    				const expectedTop = getContainerHeight(e) + offset;

    				if (nodeTop <= expectedTop) {
    					$$invalidate(4, loaded = true);
    					resetHeight(node);
    					onload && onload(node);
    					removeListeners(loadHandler);
    				}
    			},
    			200
    		);

    		addListeners(loadHandler);

    		setTimeout(() => {
    			loadHandler();
    		});

    		return {
    			destroy: () => {
    				removeListeners(loadHandler);
    			}
    		};
    	}

    	function getStyleHeight() {
    		return typeof height === 'number' ? height + 'px' : height;
    	}

    	function setHeight(node) {
    		if (height) {
    			node.style.height = getStyleHeight();
    		}
    	}

    	function resetHeight(node) {
    		setTimeout(
    			() => {
    				const isLoading = checkImgLoadingStatus(node); // Add a delay to wait for remote resources like images to load

    				if (!isLoading) {
    					node.style.height = 'auto';
    				}
    			},
    			resetHeightDelay
    		); // Add a delay to wait for remote resources like images to load
    	}

    	function checkImgLoadingStatus(node) {
    		const img = node.querySelector('img');

    		if (!img) {
    			return false;
    		}

    		if (!img.complete) {
    			$$invalidate(3, contentShow = false);

    			node.addEventListener(
    				'load',
    				() => {
    					// Use auto height if loading successfully
    					$$invalidate(3, contentShow = true);

    					node.style.height = 'auto';
    				},
    				{ capture: true, once: true }
    			);

    			node.addEventListener(
    				'error',
    				() => {
    					// Show content with fixed height if there is error
    					$$invalidate(3, contentShow = true);
    				},
    				{ capture: true, once: true }
    			);

    			return true;
    		}

    		if (img.naturalHeight === 0) {
    			// Use fixed height if img has zero height
    			return true;
    		}

    		return false;
    	}

    	const writable_props = [
    		'height',
    		'offset',
    		'fadeOption',
    		'resetHeightDelay',
    		'onload',
    		'placeholder',
    		'placeholderProps',
    		'class'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Src> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('height' in $$props) $$invalidate(9, height = $$props.height);
    		if ('offset' in $$props) $$invalidate(10, offset = $$props.offset);
    		if ('fadeOption' in $$props) $$invalidate(0, fadeOption = $$props.fadeOption);
    		if ('resetHeightDelay' in $$props) $$invalidate(11, resetHeightDelay = $$props.resetHeightDelay);
    		if ('onload' in $$props) $$invalidate(12, onload = $$props.onload);
    		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ('placeholderProps' in $$props) $$invalidate(2, placeholderProps = $$props.placeholderProps);
    		if ('class' in $$props) $$invalidate(13, className = $$props.class);
    		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Placeholder,
    		height,
    		offset,
    		fadeOption,
    		resetHeightDelay,
    		onload,
    		placeholder,
    		placeholderProps,
    		className,
    		rootClass,
    		contentClass,
    		rootInitialHeight,
    		loaded,
    		contentShow,
    		load,
    		addListeners,
    		removeListeners,
    		getStyleHeight,
    		setHeight,
    		resetHeight,
    		checkImgLoadingStatus,
    		getContainerHeight,
    		throttle,
    		contentStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ('height' in $$props) $$invalidate(9, height = $$props.height);
    		if ('offset' in $$props) $$invalidate(10, offset = $$props.offset);
    		if ('fadeOption' in $$props) $$invalidate(0, fadeOption = $$props.fadeOption);
    		if ('resetHeightDelay' in $$props) $$invalidate(11, resetHeightDelay = $$props.resetHeightDelay);
    		if ('onload' in $$props) $$invalidate(12, onload = $$props.onload);
    		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ('placeholderProps' in $$props) $$invalidate(2, placeholderProps = $$props.placeholderProps);
    		if ('className' in $$props) $$invalidate(13, className = $$props.className);
    		if ('loaded' in $$props) $$invalidate(4, loaded = $$props.loaded);
    		if ('contentShow' in $$props) $$invalidate(3, contentShow = $$props.contentShow);
    		if ('contentStyle' in $$props) $$invalidate(5, contentStyle = $$props.contentStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*contentShow*/ 8) {
    			$$invalidate(5, contentStyle = !contentShow ? 'display: none' : '');
    		}
    	};

    	return [
    		fadeOption,
    		placeholder,
    		placeholderProps,
    		contentShow,
    		loaded,
    		contentStyle,
    		rootClass,
    		rootInitialHeight,
    		load,
    		height,
    		offset,
    		resetHeightDelay,
    		onload,
    		className,
    		$$scope,
    		slots
    	];
    }

    class Src extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			height: 9,
    			offset: 10,
    			fadeOption: 0,
    			resetHeightDelay: 11,
    			onload: 12,
    			placeholder: 1,
    			placeholderProps: 2,
    			class: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Src",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get height() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get offset() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set offset(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fadeOption() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fadeOption(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resetHeightDelay() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resetHeightDelay(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onload() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onload(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholderProps() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholderProps(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    //
    const userInfoStore = writable(
      JSON.parse(localStorage.getItem("isLogin"))
        ? JSON.parse(localStorage.getItem("userInfo"))
        : {}
    );

    //IDs
    const userLikeSongIdsStore = writable(
      JSON.parse(localStorage.getItem("useLoveSongIds"))
        ? JSON.parse(localStorage.getItem("useLoveSongIds"))
        : []
    );
    //ID
    const userLikeListIdStore = writable(
      JSON.parse(localStorage.getItem("userLikeListId"))
        ? JSON.parse(localStorage.getItem("userLikeListId"))
        : ''
    );

    /* src\components\Song.svelte generated by Svelte v3.46.4 */
    const file$w = "src\\components\\Song.svelte";

    // (45:4) {#if $isLoginStore && $userLikeSongIdsStore.includes(song.id)}
    function create_if_block_2$7(ctx) {
    	let heartfill;
    	let current;

    	heartfill = new HeartFill({
    			props: {
    				size: "16",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(heartfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(heartfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heartfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heartfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(heartfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(45:4) {#if $isLoginStore && $userLikeSongIdsStore.includes(song.id)}",
    		ctx
    	});

    	return block;
    }

    // (50:4) <Lazy height={46}>
    function create_default_slot$i(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "img-song svelte-d1ubox");

    			if (!src_url_equal(img.src, img_src_value = /*customCoverUrl*/ ctx[2]
    			? /*customCoverUrl*/ ctx[2]
    			: /*song*/ ctx[0].al.picUrl.replace(/^http:/, 'https:') + '?param=100y100')) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", "");
    			add_location(img, file$w, 50, 6, 1332);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*customCoverUrl, song*/ 5 && !src_url_equal(img.src, img_src_value = /*customCoverUrl*/ ctx[2]
    			? /*customCoverUrl*/ ctx[2]
    			: /*song*/ ctx[0].al.picUrl.replace(/^http:/, 'https:') + '?param=100y100')) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(50:4) <Lazy height={46}>",
    		ctx
    	});

    	return block;
    }

    // (57:4) {#if song.id === $currentSongStore.id && $playStatusStore}
    function create_if_block_1$d(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", "pull_down pull_down1 svelte-d1ubox");
    			add_location(div0, file$w, 58, 8, 1617);
    			attr_dev(div1, "class", "pull_down pull_down2 svelte-d1ubox");
    			add_location(div1, file$w, 59, 8, 1663);
    			attr_dev(div2, "class", "pull_down pull_down3 svelte-d1ubox");
    			add_location(div2, file$w, 60, 8, 1709);
    			attr_dev(div3, "class", "pull_down pull_down4 svelte-d1ubox");
    			add_location(div3, file$w, 61, 8, 1755);
    			attr_dev(div4, "class", "song-play svelte-d1ubox");
    			add_location(div4, file$w, 57, 6, 1584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(57:4) {#if song.id === $currentSongStore.id && $playStatusStore}",
    		ctx
    	});

    	return block;
    }

    // (65:4) {#if song.id === $currentSongStore.id && !$playStatusStore}
    function create_if_block$h(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", "no_pull_down svelte-d1ubox");
    			add_location(div0, file$w, 66, 8, 1925);
    			attr_dev(div1, "class", "no_pull_down svelte-d1ubox");
    			add_location(div1, file$w, 67, 8, 1963);
    			attr_dev(div2, "class", "no_pull_down svelte-d1ubox");
    			add_location(div2, file$w, 68, 8, 2001);
    			attr_dev(div3, "class", "no_pull_down svelte-d1ubox");
    			add_location(div3, file$w, 69, 8, 2039);
    			attr_dev(div4, "class", "song-no-play svelte-d1ubox");
    			add_location(div4, file$w, 65, 6, 1889);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(65:4) {#if song.id === $currentSongStore.id && !$playStatusStore}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div5;
    	let div0;
    	let show_if = /*$isLoginStore*/ ctx[5] && /*$userLikeSongIdsStore*/ ctx[6].includes(/*song*/ ctx[0].id);
    	let t0;
    	let div1;
    	let lazy;
    	let t1;
    	let t2;
    	let t3;
    	let div4;
    	let div2;
    	let t4_value = /*song*/ ctx[0].name + "";
    	let t4;
    	let t5;
    	let span0;

    	let t6_value = (/*song*/ ctx[0].alia && /*song*/ ctx[0].alia.length > 0
    	? `(${/*song*/ ctx[0].alia[0]})`
    	: '') + "";

    	let t6;
    	let t7;
    	let div3;
    	let t8_value = songerListToStr(/*song*/ ctx[0].ar) + "";
    	let t8;
    	let t9;
    	let span1;

    	let t10_value = (/*song*/ ctx[0].al.name === ''
    	? ''
    	: `- ${/*song*/ ctx[0].al.name}`) + "";

    	let t10;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if && create_if_block_2$7(ctx);

    	lazy = new Src({
    			props: {
    				height: 46,
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*song*/ ctx[0].id === /*$currentSongStore*/ ctx[4].id && /*$playStatusStore*/ ctx[7] && create_if_block_1$d(ctx);
    	let if_block2 = /*song*/ ctx[0].id === /*$currentSongStore*/ ctx[4].id && !/*$playStatusStore*/ ctx[7] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			create_component(lazy.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			span0 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			span1 = element("span");
    			t10 = text(t10_value);
    			attr_dev(div0, "class", "love-span svelte-d1ubox");
    			add_location(div0, file$w, 43, 2, 1098);
    			attr_dev(div1, "class", "song-cover svelte-d1ubox");
    			add_location(div1, file$w, 48, 2, 1276);
    			attr_dev(span0, "class", "alia");
    			add_location(span0, file$w, 76, 6, 2247);
    			attr_dev(div2, "class", "song-name svelte-d1ubox");
    			add_location(div2, file$w, 74, 4, 2197);
    			add_location(span1, file$w, 82, 6, 2438);
    			attr_dev(div3, "class", "song-songer svelte-d1ubox");
    			add_location(div3, file$w, 80, 4, 2371);
    			attr_dev(div4, "class", "song-info svelte-d1ubox");
    			set_style(div4, "max-width", localStorage.getItem('fullWidth') - 72 + "px");
    			add_location(div4, file$w, 73, 2, 2106);
    			attr_dev(div5, "class", "song svelte-d1ubox");
    			add_location(div5, file$w, 30, 0, 731);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div5, t0);
    			append_dev(div5, div1);
    			mount_component(lazy, div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, t4);
    			append_dev(div2, t5);
    			append_dev(div2, span0);
    			append_dev(span0, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, t8);
    			append_dev(div3, t9);
    			append_dev(div3, span1);
    			append_dev(span1, t10);
    			/*div5_binding*/ ctx[10](div5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div5, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$isLoginStore, $userLikeSongIdsStore, song*/ 97) show_if = /*$isLoginStore*/ ctx[5] && /*$userLikeSongIdsStore*/ ctx[6].includes(/*song*/ ctx[0].id);

    			if (show_if) {
    				if (if_block0) {
    					if (dirty & /*$isLoginStore, $userLikeSongIdsStore, song*/ 97) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const lazy_changes = {};

    			if (dirty & /*$$scope, customCoverUrl, song*/ 4101) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);

    			if (/*song*/ ctx[0].id === /*$currentSongStore*/ ctx[4].id && /*$playStatusStore*/ ctx[7]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$d(ctx);
    					if_block1.c();
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*song*/ ctx[0].id === /*$currentSongStore*/ ctx[4].id && !/*$playStatusStore*/ ctx[7]) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$h(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((!current || dirty & /*song*/ 1) && t4_value !== (t4_value = /*song*/ ctx[0].name + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*song*/ 1) && t6_value !== (t6_value = (/*song*/ ctx[0].alia && /*song*/ ctx[0].alia.length > 0
    			? `(${/*song*/ ctx[0].alia[0]})`
    			: '') + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty & /*song*/ 1) && t8_value !== (t8_value = songerListToStr(/*song*/ ctx[0].ar) + "")) set_data_dev(t8, t8_value);

    			if ((!current || dirty & /*song*/ 1) && t10_value !== (t10_value = (/*song*/ ctx[0].al.name === ''
    			? ''
    			: `- ${/*song*/ ctx[0].al.name}`) + "")) set_data_dev(t10, t10_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(lazy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(lazy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			destroy_component(lazy);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*div5_binding*/ ctx[10](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $currentSongStore;
    	let $isLoginStore;
    	let $userLikeSongIdsStore;
    	let $playStatusStore;
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(4, $currentSongStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(5, $isLoginStore = $$value));
    	validate_store(userLikeSongIdsStore, 'userLikeSongIdsStore');
    	component_subscribe($$self, userLikeSongIdsStore, $$value => $$invalidate(6, $userLikeSongIdsStore = $$value));
    	validate_store(playStatusStore, 'playStatusStore');
    	component_subscribe($$self, playStatusStore, $$value => $$invalidate(7, $playStatusStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Song', slots, []);
    	const dispatch = createEventDispatcher();

    	function setSongClick(index) {
    		dispatch('songClick', { index });
    	}

    	let { song = {} } = $$props;
    	let { index = 0 } = $$props;
    	let { customCoverUrl = null } = $$props;
    	let songDom;

    	onMount(() => {
    		if (songDom) {
    			ripple(songDom);
    		}
    	});

    	const writable_props = ['song', 'index', 'customCoverUrl'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Song> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		if (song.id === $currentSongStore.id) {
    			window.audioDOM.play();
    			playStatusStore.set(true);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    		} else {
    			setSongClick(index);
    		}
    	};

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			songDom = $$value;
    			$$invalidate(3, songDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('song' in $$props) $$invalidate(0, song = $$props.song);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    		if ('customCoverUrl' in $$props) $$invalidate(2, customCoverUrl = $$props.customCoverUrl);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		Lazy: Src,
    		HeartFill,
    		isLoginStore,
    		userLikeSongIdsStore,
    		currentSongStore,
    		playStatusStore,
    		ripple,
    		songerListToStr,
    		Toast: Toast$1,
    		dispatch,
    		setSongClick,
    		song,
    		index,
    		customCoverUrl,
    		songDom,
    		$currentSongStore,
    		$isLoginStore,
    		$userLikeSongIdsStore,
    		$playStatusStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('song' in $$props) $$invalidate(0, song = $$props.song);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    		if ('customCoverUrl' in $$props) $$invalidate(2, customCoverUrl = $$props.customCoverUrl);
    		if ('songDom' in $$props) $$invalidate(3, songDom = $$props.songDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		song,
    		index,
    		customCoverUrl,
    		songDom,
    		$currentSongStore,
    		$isLoginStore,
    		$userLikeSongIdsStore,
    		$playStatusStore,
    		setSongClick,
    		click_handler,
    		div5_binding
    	];
    }

    class Song extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { song: 0, index: 1, customCoverUrl: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Song",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get song() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set song(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customCoverUrl() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customCoverUrl(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    var defaults = {

      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },

      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      var context = this || defaults_1;
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    var name = "axios";
    var version = "0.21.4";
    var description = "Promise based HTTP client for the browser and node.js";
    var main = "index.js";
    var scripts = {
    	test: "grunt test",
    	start: "node ./sandbox/server.js",
    	build: "NODE_ENV=production grunt build",
    	preversion: "npm test",
    	version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    	postversion: "git push && git push --tags",
    	examples: "node ./examples/server.js",
    	coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    	fix: "eslint --fix lib/**/*.js"
    };
    var repository = {
    	type: "git",
    	url: "https://github.com/axios/axios.git"
    };
    var keywords = [
    	"xhr",
    	"http",
    	"ajax",
    	"promise",
    	"node"
    ];
    var author = "Matt Zabriskie";
    var license = "MIT";
    var bugs = {
    	url: "https://github.com/axios/axios/issues"
    };
    var homepage = "https://axios-http.com";
    var devDependencies = {
    	coveralls: "^3.0.0",
    	"es6-promise": "^4.2.4",
    	grunt: "^1.3.0",
    	"grunt-banner": "^0.6.0",
    	"grunt-cli": "^1.2.0",
    	"grunt-contrib-clean": "^1.1.0",
    	"grunt-contrib-watch": "^1.0.0",
    	"grunt-eslint": "^23.0.0",
    	"grunt-karma": "^4.0.0",
    	"grunt-mocha-test": "^0.13.3",
    	"grunt-ts": "^6.0.0-beta.19",
    	"grunt-webpack": "^4.0.2",
    	"istanbul-instrumenter-loader": "^1.0.0",
    	"jasmine-core": "^2.4.1",
    	karma: "^6.3.2",
    	"karma-chrome-launcher": "^3.1.0",
    	"karma-firefox-launcher": "^2.1.0",
    	"karma-jasmine": "^1.1.1",
    	"karma-jasmine-ajax": "^0.1.13",
    	"karma-safari-launcher": "^1.0.0",
    	"karma-sauce-launcher": "^4.3.6",
    	"karma-sinon": "^1.0.5",
    	"karma-sourcemap-loader": "^0.3.8",
    	"karma-webpack": "^4.0.2",
    	"load-grunt-tasks": "^3.5.2",
    	minimist: "^1.2.0",
    	mocha: "^8.2.1",
    	sinon: "^4.5.0",
    	"terser-webpack-plugin": "^4.2.3",
    	typescript: "^4.0.5",
    	"url-search-params": "^0.10.0",
    	webpack: "^4.44.2",
    	"webpack-dev-server": "^3.11.0"
    };
    var browser = {
    	"./lib/adapters/http.js": "./lib/adapters/xhr.js"
    };
    var jsdelivr = "dist/axios.min.js";
    var unpkg = "dist/axios.min.js";
    var typings = "./index.d.ts";
    var dependencies = {
    	"follow-redirects": "^1.14.0"
    };
    var bundlesize = [
    	{
    		path: "./dist/axios.min.js",
    		threshold: "5kB"
    	}
    ];
    var _package = {
    	name: name,
    	version: version,
    	description: description,
    	main: main,
    	scripts: scripts,
    	repository: repository,
    	keywords: keywords,
    	author: author,
    	license: license,
    	bugs: bugs,
    	homepage: homepage,
    	devDependencies: devDependencies,
    	browser: browser,
    	jsdelivr: jsdelivr,
    	unpkg: unpkg,
    	typings: typings,
    	dependencies: dependencies,
    	bundlesize: bundlesize
    };

    var _package$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        name: name,
        version: version,
        description: description,
        main: main,
        scripts: scripts,
        repository: repository,
        keywords: keywords,
        author: author,
        license: license,
        bugs: bugs,
        homepage: homepage,
        devDependencies: devDependencies,
        browser: browser,
        jsdelivr: jsdelivr,
        unpkg: unpkg,
        typings: typings,
        dependencies: dependencies,
        bundlesize: bundlesize,
        'default': _package
    });

    var pkg = getCjsExportFromNamespace(_package$1);

    var validators$1 = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split('.');

    /**
     * Compare package versions
     * @param {string} version
     * @param {string?} thanVersion
     * @returns {boolean}
     */
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
      var destVer = version.split('.');
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }

    /**
     * Transitional option validator
     * @param {function|boolean?} validator
     * @param {string?} version
     * @param {string} message
     * @returns {function}
     */
    validators$1.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);

      function formatMessage(opt, desc) {
        return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed in ' + version));
        }

        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }

    var validator = {
      isOlderVersion: isOlderVersion,
      assertOptions: assertOptions,
      validators: validators$1
    };

    var validators = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      var transitional = config.transitional;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
        }, false);
      }

      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      var promise;

      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];

        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);

        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      }


      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }

      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios$1 = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios$1.Axios = Axios_1;

    // Factory for creating new instances
    axios$1.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios$1.Cancel = Cancel_1;
    axios$1.CancelToken = CancelToken_1;
    axios$1.isCancel = isCancel;

    // Expose all/spread
    axios$1.all = function all(promises) {
      return Promise.all(promises);
    };
    axios$1.spread = spread;

    // Expose isAxiosError
    axios$1.isAxiosError = isAxiosError;

    var axios_1 = axios$1;

    // Allow use of default import syntax in TypeScript
    var _default = axios$1;
    axios_1.default = _default;

    var axios = axios_1;

    let baseURL = 'http://code.zhangdong.site:3001/' ;

    const service = axios.create({
      baseURL,
      withCredentials: true,
      timeout: 15000,
    });

    service.interceptors.request.use(function (config) {
      if (!config.params) config.params = {};
      //cookie301
      if (config.params.cookie) {
        config.params.cookie = config.params.cookie;
      } else if (baseURL[0] !== '/') {
        config.params.cookie = `MUSIC_U=${js_cookie.get('MUSIC_U')};`;
      }
      if (!config.isHideLoading) {
        if (!get_store_value(isLoadingStore)) {
          isLoadingStore.set(true);
        }
      }
      return config;
    });

    service.interceptors.response.use(
      response => {
        isLoadingStore.set(false);
        const res = response.data;
        if (res.code === 200) {
          return res;
        } else if (res.code === 800) {
          return res;
        } else if (res.code === 801) {
          return res;
        } else if (res.code === 802) {
          return res;
        } else if (res.code === 803) {
          return res;
        } else {
          if (res.code) {
            Alert(
              response.config.url + '-' + res.code + '' + (res.message ? res.message : res.msg ? res.msg : '')
            );
            return res;
          } else {
            Alert(response + '' + response);
            return res;
          }
        }
      },
      error => {
        isLoadingStore.set(false);
        //
        if (error.response.config.url != '/daily_signin') {
          Alert(
            error.response.data.code +
              '' +
              (error.response.data.message
                ? error.response.data.message
                : error.response.data.msg
                ? error.response.data.msg
                : '')
          );
          return  error.response.data;
         
          // Promise.then(error => {
          //   console.log(333, error);
          // });
          // return Promise.reject(error);
        }
      }
    );

    /**
     *  url
     *  :  ,  id,  url, ,  id(  ,  ),  url,
     * !!!()
     * @param {string} id -  id id=405998841,33894312
     */
    function getSongUrl(id) {
      let br = 128000;
      switch (localStorage.getItem('musicQuality')) {
        case '0':
          br = 128000;
          break;
        case '1':
          br = 192000;
          break;
        case '2':
          br = 320000;
          break;
        case '3':
          br = 999000;
          break;
        default:
          br = 128000;
          break;
      }
      return service({
        url: '/song/url',
        method: 'get',
        params: {
          id,
          br,
        },
        isHideLoading: true,
      });
    }

    /**
     * 
     *  :  ,  id( id,  , ), (:)
     * @param {string} ids -  id,  ids=405998841,33894312
     */
    function getSongDetail(ids) {
      if (typeof ids === 'string') ids = ids.replace(/,,/, ',');
      return service({
        url: '/song/detail',
        method: 'get',
        params: {
          ids,
          timestamp: new Date().getTime(),
        },
      });
    }
    /**
     * 
     *  :  ,  id, 
     * @param {string} id-  id,  ids=405998841,33894312
     */
    function getSimiSong(id) {
      return service({
        url: '/simi/song',
        method: 'get',
        params: {
          id,
        },
      });
    }
    /**
     *  FM(  )
     *
     */
    function personalFM() {
      return service({
        url: '/personal_fm',
        method: 'get',
        params: {
          timestamp: new Date().getTime(),
        },
      });
    }
    /**
     * 
     *  :  ,  id, 
     * - id -  id
     * - like -  true  ,  false, 
     * @param {Object} params
     * @param {number} params.id
     * @param {boolean=} [params.like]
     */
    function likeThisSong(params) {
      params.timestamp = new Date().getTime();
      return service({
        url: '/like',
        method: 'get',
        params,
      });
    }

    // :  ,  id,  FM 
    function fmTrash(id) {
      return service({
        url: '/fm_trash',
        method: 'post',
        params: {
          timestamp: new Date().getTime(),
          id,
        },
      });
    }

    /**
     * 
     *  :  ,  id  (  )
     * @param {number} id -  id
     */
    function getLyric(id) {
      return service({
        url: '/lyric',
        method: 'get',
        params: {
          id,
        },
      });
    }

    /**
     * 
     *  :  ,  type,  id  (  )
     *  : id :  id
     * type:  ,  ,  , mv,  ,  , , 
     * 0: ;1: mv;2: ;3: ;4: ;5: 
     *  : limit:  ,  20
     * offset:  ,  ,  :(  -1)*20,  20  limit 
     * before: , time (5000)
     *  : /comment/hot
     *  : /comment/hot?id=186016&type=0
     * @param {number} id
     * @param {number} type
     * @param {number} limit
     * @param {number} offset
     * @returns
     */
    function getHotComment(id, offset = 0, type = 0, limit = 20) {
      return service({
        url: '/comment/hot',
        method: 'get',
        params: {
          id,
          type,
          limit,
          offset,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     :  ,  type,  id,  id cid   t   (  )
     : id :  id,  id,mv id
    cid :  id
    t :  ,1  ,0 
    type:  ,  ,  , mv,  ,  , , 
    */
    function likeComment(id, cid, type = 0, t) {
      return service({
        url: '/comment/like',
        method: 'get',
        params: {
          id,
          cid,
          type,
          t,
          timestamp: new Date().getTime(),
        },
      });
    }

    /* src\components\SongList.svelte generated by Svelte v3.46.4 */
    const file$v = "src\\components\\SongList.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (90:2) {#each songList as song, i}
    function create_each_block$9(ctx) {
    	let song;
    	let current;

    	song = new Song({
    			props: {
    				song: /*song*/ ctx[7],
    				index: /*i*/ ctx[9]
    			},
    			$$inline: true
    		});

    	song.$on("songClick", /*getSongClick*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(song.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(song, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const song_changes = {};
    			if (dirty & /*songList*/ 1) song_changes.song = /*song*/ ctx[7];
    			song.$set(song_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(song.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(song.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(song, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(90:2) {#each songList as song, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div;
    	let current;
    	let each_value = /*songList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$v, 88, 0, 3220);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*songList, getSongClick*/ 3) {
    				each_value = /*songList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(3, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(4, $currentPlayListStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongList', slots, []);
    	let { songList = [] } = $$props;
    	let { isPlayList = false } = $$props;

    	function playListFun(index) {
    		if (isPlayList) {
    			playRepeatModelStore.set('repeat');
    			isFMPlayStore.set(false);
    			localStorage.setItem('isFMPlay', '0');
    			currentPlayListStore.set(songList);
    			let ids = [];

    			for (let r = 0; r < songList.length; r++) {
    				ids.push(songList[r].id);
    			}

    			localStorage.setItem('localPlayList', JSON.stringify(ids));
    			currentSongIndexStore.set(index);
    			getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    		} else {
    			isFMPlayStore.set(false);
    			localStorage.setItem('isFMPlay', '0');
    			let newcurrentPlayList = $currentPlayListStore;
    			let newPlayListIds = [];

    			for (let r = 0; r < newcurrentPlayList.length; r++) {
    				newPlayListIds.push(newcurrentPlayList[r].id);
    			}

    			if (newPlayListIds.includes(songList[index].id)) {
    				currentSongIndexStore.set(newPlayListIds.indexOf(songList[index].id));
    				getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    			} else {
    				newcurrentPlayList.splice($currentSongIndexStore + 1, 0, songList[index]);
    				currentPlayListStore.set(newcurrentPlayList);
    				let ids = [];

    				for (let r = 0; r < newcurrentPlayList.length; r++) {
    					ids.push(newcurrentPlayList[r].id);
    				}

    				localStorage.setItem('localPlayList', JSON.stringify(ids));
    				currentSongIndexStore.set($currentSongIndexStore + 1);
    				getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    			}
    		}
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	function getSongClick(event) {
    		playListFun(event.detail.index);
    	}

    	const writable_props = ['songList', 'isPlayList'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('songList' in $$props) $$invalidate(0, songList = $$props.songList);
    		if ('isPlayList' in $$props) $$invalidate(2, isPlayList = $$props.isPlayList);
    	};

    	$$self.$capture_state = () => ({
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		Song,
    		getSongUrl,
    		Toast: Toast$1,
    		songList,
    		isPlayList,
    		playListFun,
    		getSongUrlFun,
    		getSongClick,
    		$currentSongIndexStore,
    		$currentPlayListStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('songList' in $$props) $$invalidate(0, songList = $$props.songList);
    		if ('isPlayList' in $$props) $$invalidate(2, isPlayList = $$props.isPlayList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [songList, getSongClick, isPlayList];
    }

    class SongList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { songList: 0, isPlayList: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongList",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get songList() {
    		throw new Error("<SongList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set songList(value) {
    		throw new Error("<SongList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isPlayList() {
    		throw new Error("<SongList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isPlayList(value) {
    		throw new Error("<SongList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Play.svelte generated by Svelte v3.46.4 */
    const file$u = "src\\components\\Play.svelte";

    // (467:72) 
    function create_if_block_19(ctx) {
    	let div;
    	let songlist;
    	let current;

    	songlist = new SongList({
    			props: {
    				songList: /*$currentPlayListStore*/ ctx[26]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(songlist.$$.fragment);
    			attr_dev(div, "class", "song-list-box svelte-1c6ptft");
    			add_location(div, file$u, 467, 16, 19069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(songlist, div, null);
    			/*div_binding*/ ctx[52](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songlist_changes = {};
    			if (dirty[0] & /*$currentPlayListStore*/ 67108864) songlist_changes.songList = /*$currentPlayListStore*/ ctx[26];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(songlist);
    			/*div_binding*/ ctx[52](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(467:72) ",
    		ctx
    	});

    	return block;
    }

    // (463:54) 
    function create_if_block_18(ctx) {
    	let div;
    	let lyric;
    	let current;
    	let mounted;
    	let dispose;

    	lyric = new Lyric({
    			props: { maxHeight: "54vh" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(lyric.$$.fragment);
    			attr_dev(div, "class", "lyric-cover");
    			add_location(div, file$u, 463, 16, 18855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(lyric, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*lyricClickFun*/ ctx[45], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lyric.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lyric.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(lyric);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(463:54) ",
    		ctx
    	});

    	return block;
    }

    // (445:12) {#if $mainCoverTypeStore === 'cover'}
    function create_if_block_17(ctx) {
    	let div1;
    	let div0;
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			img = element("img");
    			set_style(img, "width", /*$playStatusStore*/ ctx[31] ? '280px' : '240px');
    			set_style(img, "height", /*$playStatusStore*/ ctx[31] ? '280px' : '240px');
    			if (!src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "cover-img svelte-1c6ptft");
    			add_location(img, file$u, 454, 24, 18375);
    			set_style(div0, "position", "relative");

    			set_style(div0, "display", /*$showVisualizerStore*/ ctx[30] === '1'
    			? 'none'
    			: 'block');

    			add_location(div0, file$u, 453, 20, 18258);
    			attr_dev(div1, "class", "cover svelte-1c6ptft");
    			add_location(div1, file$u, 445, 16, 17955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, img);
    			/*div1_binding*/ ctx[51](div1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*handleDown*/ ctx[37], false, false, false),
    					listen_dev(div1, "touchstart", /*touchStart*/ ctx[47], false, false, false),
    					listen_dev(div1, "touchend", /*touchEnd*/ ctx[48], false, false, false),
    					listen_dev(div1, "touchmove", /*touchMove*/ ctx[49], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$playStatusStore*/ 1) {
    				set_style(img, "width", /*$playStatusStore*/ ctx[31] ? '280px' : '240px');
    			}

    			if (dirty[1] & /*$playStatusStore*/ 1) {
    				set_style(img, "height", /*$playStatusStore*/ ctx[31] ? '280px' : '240px');
    			}

    			if (dirty[0] & /*$currentSongStore*/ 8 && !src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty[0] & /*$showVisualizerStore*/ 1073741824) {
    				set_style(div0, "display", /*$showVisualizerStore*/ ctx[30] === '1'
    				? 'none'
    				: 'block');
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*div1_binding*/ ctx[51](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(445:12) {#if $mainCoverTypeStore === 'cover'}",
    		ctx
    	});

    	return block;
    }

    // (544:20) {:else}
    function create_else_block_7(ctx) {
    	let chatquoteline;
    	let current;

    	chatquoteline = new ChatQuoteLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatquoteline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatquoteline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatquoteline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatquoteline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatquoteline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_7.name,
    		type: "else",
    		source: "(544:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (542:62) 
    function create_if_block_16(ctx) {
    	let chatquotefill;
    	let current;

    	chatquotefill = new ChatQuoteFill({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatquotefill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatquotefill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatquotefill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatquotefill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatquotefill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(542:62) ",
    		ctx
    	});

    	return block;
    }

    // (538:20) {#if lyricLoading}
    function create_if_block_15(ctx) {
    	let span;
    	let embed;
    	let embed_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			embed = element("embed");
    			attr_dev(embed, "width", "24");
    			attr_dev(embed, "height", "24");
    			if (!src_url_equal(embed.src, embed_src_value = "/images/Ripple.svg")) attr_dev(embed, "src", embed_src_value);
    			attr_dev(embed, "type", "image/svg+xml");
    			add_location(embed, file$u, 539, 28, 22761);
    			set_style(span, "line-height", "30px");
    			add_location(span, file$u, 538, 24, 22698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, embed);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(538:20) {#if lyricLoading}",
    		ctx
    	});

    	return block;
    }

    // (548:16) {#if !$isFMPlayStore}
    function create_if_block_13(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_14, create_else_block_6];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$mainCoverTypeStore*/ ctx[27] === 'list') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "tool-item list svelte-1c6ptft");
    			add_location(div, file$u, 549, 20, 23280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding_1*/ ctx[56](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*changeListFun*/ ctx[43], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding_1*/ ctx[56](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(548:16) {#if !$isFMPlayStore}",
    		ctx
    	});

    	return block;
    }

    // (553:24) {:else}
    function create_else_block_6(ctx) {
    	let playlistline;
    	let current;

    	playlistline = new PlayListLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(playlistline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(553:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (551:24) {#if $mainCoverTypeStore === 'list'}
    function create_if_block_14(ctx) {
    	let playlistfill;
    	let current;

    	playlistfill = new PlayListFill({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(playlistfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playlistfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playlistfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(551:24) {#if $mainCoverTypeStore === 'list'}",
    		ctx
    	});

    	return block;
    }

    // (558:16) {#if $isFMPlayStore && $isLoginStore}
    function create_if_block_11(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_12, create_else_block_5];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*noLikeLoading*/ ctx[18]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "tool-item list svelte-1c6ptft");
    			add_location(div, file$u, 559, 20, 23818);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding_2*/ ctx[57](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*handleFMNoLoveFun*/ ctx[41], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding_2*/ ctx[57](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(558:16) {#if $isFMPlayStore && $isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (565:24) {:else}
    function create_else_block_5(ctx) {
    	let dislikeline;
    	let current;

    	dislikeline = new DislikeLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dislikeline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dislikeline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dislikeline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dislikeline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dislikeline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(565:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (561:24) {#if noLikeLoading}
    function create_if_block_12(ctx) {
    	let span;
    	let embed;
    	let embed_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			embed = element("embed");
    			attr_dev(embed, "width", "24");
    			attr_dev(embed, "height", "24");
    			if (!src_url_equal(embed.src, embed_src_value = "/images/Ripple.svg")) attr_dev(embed, "src", embed_src_value);
    			attr_dev(embed, "type", "image/svg+xml");
    			add_location(embed, file$u, 562, 32, 24040);
    			set_style(span, "line-height", "30px");
    			add_location(span, file$u, 561, 28, 23973);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, embed);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(561:24) {#if noLikeLoading}",
    		ctx
    	});

    	return block;
    }

    // (570:16) {#if $isLoginStore}
    function create_if_block_8(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_9, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*likeLoading*/ ctx[19]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "tool-item love svelte-1c6ptft");
    			add_location(div, file$u, 571, 20, 24448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding_3*/ ctx[58](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*handleLoveFun*/ ctx[40], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding_3*/ ctx[58](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(570:16) {#if $isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (577:24) {:else}
    function create_else_block_3(ctx) {
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_10, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (/*isLikeCurrentSong*/ ctx[20]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_5(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();

    			set_style(span, "color", /*isLikeCurrentSong*/ ctx[20]
    			? 'var(--primary-text-color)'
    			: '#fff');

    			add_location(span, file$u, 577, 28, 24839);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_blocks[current_block_type_index].m(span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}

    			if (!current || dirty[0] & /*isLikeCurrentSong*/ 1048576) {
    				set_style(span, "color", /*isLikeCurrentSong*/ ctx[20]
    				? 'var(--primary-text-color)'
    				: '#fff');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(577:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (573:24) {#if likeLoading}
    function create_if_block_9(ctx) {
    	let span;
    	let embed;
    	let embed_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			embed = element("embed");
    			attr_dev(embed, "width", "24");
    			attr_dev(embed, "height", "24");
    			if (!src_url_equal(embed.src, embed_src_value = "/images/Ripple.svg")) attr_dev(embed, "src", embed_src_value);
    			attr_dev(embed, "type", "image/svg+xml");
    			add_location(embed, file$u, 574, 32, 24661);
    			set_style(span, "line-height", "30px");
    			add_location(span, file$u, 573, 28, 24594);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, embed);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(573:24) {#if likeLoading}",
    		ctx
    	});

    	return block;
    }

    // (581:32) {:else}
    function create_else_block_4(ctx) {
    	let heart2line;
    	let current;

    	heart2line = new Heart2Line({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(heart2line.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(heart2line, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heart2line.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heart2line.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(heart2line, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(581:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (579:32) {#if isLikeCurrentSong}
    function create_if_block_10(ctx) {
    	let heart2fill;
    	let current;

    	heart2fill = new Heart2Fill({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(heart2fill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(heart2fill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heart2fill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heart2fill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(heart2fill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(579:32) {#if isLikeCurrentSong}",
    		ctx
    	});

    	return block;
    }

    // (588:16) {#if !$isFMPlayStore}
    function create_if_block_4$4(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_5$4, create_if_block_6$1, create_if_block_7$1, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_6(ctx, dirty) {
    		if (/*$playRepeatModelStore*/ ctx[25] === 'repeat') return 0;
    		if (/*$playRepeatModelStore*/ ctx[25] === 'repeatOnce') return 1;
    		if (/*$playRepeatModelStore*/ ctx[25] === 'heart') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_6(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "tool-item mode svelte-1c6ptft");
    			add_location(div, file$u, 589, 20, 25456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding_4*/ ctx[60](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_2*/ ctx[59], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_6(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding_4*/ ctx[60](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(588:16) {#if !$isFMPlayStore}",
    		ctx
    	});

    	return block;
    }

    // (599:24) {:else}
    function create_else_block_2$1(ctx) {
    	let shuffleline;
    	let current;

    	shuffleline = new ShuffleLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(shuffleline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(shuffleline, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shuffleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shuffleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(shuffleline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(599:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (595:68) 
    function create_if_block_7$1(ctx) {
    	let span;
    	let heartpulseline;
    	let current;

    	heartpulseline = new HeartPulseLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(heartpulseline.$$.fragment);
    			attr_dev(span, "class", "svelte-1c6ptft");
    			toggle_class(span, "heart-beat", /*$playStatusStore*/ ctx[31]);
    			add_location(span, file$u, 595, 28, 25953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(heartpulseline, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*$playStatusStore*/ 1) {
    				toggle_class(span, "heart-beat", /*$playStatusStore*/ ctx[31]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heartpulseline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heartpulseline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(heartpulseline);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(595:68) ",
    		ctx
    	});

    	return block;
    }

    // (593:73) 
    function create_if_block_6$1(ctx) {
    	let repeatoneline;
    	let current;

    	repeatoneline = new RepeatOneLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(repeatoneline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(repeatoneline, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(repeatoneline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(repeatoneline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(repeatoneline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(593:73) ",
    		ctx
    	});

    	return block;
    }

    // (591:24) {#if $playRepeatModelStore === 'repeat'}
    function create_if_block_5$4(ctx) {
    	let sortdesc;
    	let current;

    	sortdesc = new SortDesc({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(sortdesc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(sortdesc, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sortdesc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sortdesc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sortdesc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(591:24) {#if $playRepeatModelStore === 'repeat'}",
    		ctx
    	});

    	return block;
    }

    // (605:16) {#if $isShowCommentStore != '0'}
    function create_if_block_3$6(ctx) {
    	let div;
    	let message2line;
    	let current;
    	let mounted;
    	let dispose;

    	message2line = new Message2Line({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(message2line.$$.fragment);
    			attr_dev(div, "class", "tool-item comment svelte-1c6ptft");
    			add_location(div, file$u, 605, 20, 26427);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(message2line, div, null);
    			/*div_binding_5*/ ctx[61](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*toCommentFun*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message2line.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message2line.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(message2line);
    			/*div_binding_5*/ ctx[61](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(605:16) {#if $isShowCommentStore != '0'}",
    		ctx
    	});

    	return block;
    }

    // (621:20) {:else}
    function create_else_block_1$2(ctx) {
    	let skipbackfill;
    	let current;

    	skipbackfill = new SkipBackFill({
    			props: {
    				size: "40px",
    				style: "vertical-align: middle;height:80px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(skipbackfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(skipbackfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skipbackfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skipbackfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(skipbackfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(621:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (619:20) {#if $isFMPlayStore}
    function create_if_block_2$6(ctx) {
    	let radioline;
    	let current;

    	radioline = new RadioLine({
    			props: {
    				size: "24px",
    				style: "vertical-align: middle;;height:80px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(radioline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(radioline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radioline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radioline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radioline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(619:20) {#if $isFMPlayStore}",
    		ctx
    	});

    	return block;
    }

    // (649:20) {:else}
    function create_else_block$8(ctx) {
    	let playfill;
    	let current;

    	playfill = new PlayFill({
    			props: {
    				size: "80px",
    				style: "vertical-align: middle;height:80px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(playfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(649:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (647:20) {#if $playStatusStore}
    function create_if_block_1$c(ctx) {
    	let pausefill;
    	let current;

    	pausefill = new PauseFill({
    			props: {
    				size: "80px",
    				style: "vertical-align: middle;height:80px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pausefill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pausefill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pausefill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pausefill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pausefill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(647:20) {#if $playStatusStore}",
    		ctx
    	});

    	return block;
    }

    // (660:0) {#if $playIsMaxStore && 0 < parseFloat($maxPlayToTopStore) < window.screen.height - 40}
    function create_if_block$g(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "play-mask svelte-1c6ptft");
    			set_style(div, "background-color", "rgba(0, 0, 0, " + (0.9 - parseFloat(/*$maxPlayToTopStore*/ ctx[29]) / window.screen.height) + ")");
    			add_location(div, file$u, 660, 4, 29244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$maxPlayToTopStore*/ 536870912) {
    				set_style(div, "background-color", "rgba(0, 0, 0, " + (0.9 - parseFloat(/*$maxPlayToTopStore*/ ctx[29]) / window.screen.height) + ")");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(660:0) {#if $playIsMaxStore && 0 < parseFloat($maxPlayToTopStore) < window.screen.height - 40}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div22;
    	let div21;
    	let div3;
    	let div1;
    	let div0;
    	let t0;
    	let div2;
    	let canvas;
    	let t1;
    	let img;
    	let img_src_value;
    	let t2;
    	let current_block_type_index;
    	let if_block0;
    	let t3;
    	let div20;
    	let div13;
    	let div6;
    	let div4;
    	let t4_value = /*$currentSongStore*/ ctx[3].name + "";
    	let t4;
    	let t5;
    	let span0;

    	let t6_value = (/*$currentSongStore*/ ctx[3].alia && /*$currentSongStore*/ ctx[3].alia.length > 0
    	? `(${/*$currentSongStore*/ ctx[3].alia[0]})`
    	: '') + "";

    	let t6;
    	let t7;
    	let div5;
    	let t8_value = songerListToStr(/*$currentSongStore*/ ctx[3].ar) + "";
    	let t8;
    	let t9;
    	let span1;

    	let t10_value = (/*$currentSongStore*/ ctx[3].al.name === ''
    	? ''
    	: `- ${/*$currentSongStore*/ ctx[3].al.name}`) + "";

    	let t10;
    	let t11;
    	let div12;
    	let div7;
    	let progress;
    	let t12;
    	let div11;
    	let div8;
    	let t13;
    	let t14;
    	let div9;
    	let span2;

    	let t15_value = (/*$currentSongQualityStore*/ ctx[32] === 'FLAC' || /*$currentSongQualityStore*/ ctx[32] === ''
    	? /*$currentSongQualityStore*/ ctx[32]
    	: /*$currentSongQualityStore*/ ctx[32].toString().substring(0, /*$currentSongQualityStore*/ ctx[32].toString().length - 3) + 'K') + "";

    	let t15;
    	let t16;
    	let div10;
    	let t17;
    	let t18;
    	let div15;
    	let div14;
    	let current_block_type_index_1;
    	let if_block1;
    	let t19;
    	let t20;
    	let t21;
    	let t22;
    	let t23;
    	let t24;
    	let div19;
    	let div16;
    	let current_block_type_index_2;
    	let if_block7;
    	let t25;
    	let div17;
    	let current_block_type_index_3;
    	let if_block8;
    	let t26;
    	let div18;
    	let skipforwardfill;
    	let t27;
    	let show_if = /*$playIsMaxStore*/ ctx[34] && 0 < parseFloat(/*$maxPlayToTopStore*/ ctx[29]) < window.screen.height - 40;
    	let t28;
    	let picker;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_17, create_if_block_18, create_if_block_19];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$mainCoverTypeStore*/ ctx[27] === 'cover') return 0;
    		if (/*$mainCoverTypeStore*/ ctx[27] === 'lyric') return 1;
    		if (!/*$isFMPlayStore*/ ctx[28] && /*$mainCoverTypeStore*/ ctx[27] === 'list') return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	progress = new Progress({
    			props: { current: /*currentTimeLong*/ ctx[1] },
    			$$inline: true
    		});

    	progress.$on("setCurrent", /*getCurrent*/ ctx[35]);
    	progress.$on("setTimeCurrent", /*getTimeCurrent*/ ctx[36]);
    	const if_block_creators_1 = [create_if_block_15, create_if_block_16, create_else_block_7];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*lyricLoading*/ ctx[17]) return 0;
    		if (/*$mainCoverTypeStore*/ ctx[27] === 'lyric') return 1;
    		return 2;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	let if_block2 = !/*$isFMPlayStore*/ ctx[28] && create_if_block_13(ctx);
    	let if_block3 = /*$isFMPlayStore*/ ctx[28] && /*$isLoginStore*/ ctx[4] && create_if_block_11(ctx);
    	let if_block4 = /*$isLoginStore*/ ctx[4] && create_if_block_8(ctx);
    	let if_block5 = !/*$isFMPlayStore*/ ctx[28] && create_if_block_4$4(ctx);
    	let if_block6 = /*$isShowCommentStore*/ ctx[33] != '0' && create_if_block_3$6(ctx);
    	const if_block_creators_2 = [create_if_block_2$6, create_else_block_1$2];
    	const if_blocks_2 = [];

    	function select_block_type_7(ctx, dirty) {
    		if (/*$isFMPlayStore*/ ctx[28]) return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_7(ctx);
    	if_block7 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    	const if_block_creators_3 = [create_if_block_1$c, create_else_block$8];
    	const if_blocks_3 = [];

    	function select_block_type_8(ctx, dirty) {
    		if (/*$playStatusStore*/ ctx[31]) return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_8(ctx);
    	if_block8 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	skipforwardfill = new SkipForwardFill({
    			props: {
    				size: "40px",
    				style: "vertical-align: middle;height:80px"
    			},
    			$$inline: true
    		});

    	let if_block9 = show_if && create_if_block$g(ctx);

    	picker = new Picker({
    			props: {
    				isShow: /*PickerShow*/ ctx[22],
    				title: "",
    				list: /*songers*/ ctx[21]
    			},
    			$$inline: true
    		});

    	picker.$on("ChangeShow", /*ChangeShow_handler*/ ctx[68]);
    	picker.$on("PickerClick", /*PickerClick_handler*/ ctx[69]);

    	const block = {
    		c: function create() {
    			div22 = element("div");
    			div21 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			canvas = element("canvas");
    			t1 = space();
    			img = element("img");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			div20 = element("div");
    			div13 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			span0 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div5 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			span1 = element("span");
    			t10 = text(t10_value);
    			t11 = space();
    			div12 = element("div");
    			div7 = element("div");
    			create_component(progress.$$.fragment);
    			t12 = space();
    			div11 = element("div");
    			div8 = element("div");
    			t13 = text(/*currentTime*/ ctx[0]);
    			t14 = space();
    			div9 = element("div");
    			span2 = element("span");
    			t15 = text(t15_value);
    			t16 = space();
    			div10 = element("div");
    			t17 = text(/*endTime*/ ctx[2]);
    			t18 = space();
    			div15 = element("div");
    			div14 = element("div");
    			if_block1.c();
    			t19 = space();
    			if (if_block2) if_block2.c();
    			t20 = space();
    			if (if_block3) if_block3.c();
    			t21 = space();
    			if (if_block4) if_block4.c();
    			t22 = space();
    			if (if_block5) if_block5.c();
    			t23 = space();
    			if (if_block6) if_block6.c();
    			t24 = space();
    			div19 = element("div");
    			div16 = element("div");
    			if_block7.c();
    			t25 = space();
    			div17 = element("div");
    			if_block8.c();
    			t26 = space();
    			div18 = element("div");
    			create_component(skipforwardfill.$$.fragment);
    			t27 = space();
    			if (if_block9) if_block9.c();
    			t28 = space();
    			create_component(picker.$$.fragment);
    			attr_dev(div0, "class", "down-line svelte-1c6ptft");
    			add_location(div0, file$u, 425, 16, 16983);
    			attr_dev(div1, "class", "down svelte-1c6ptft");
    			add_location(div1, file$u, 424, 12, 16850);
    			attr_dev(canvas, "id", "playgroundCanvas");
    			attr_dev(canvas, "height", "720");
    			attr_dev(canvas, "width", "720");
    			set_style(canvas, "position", "absolute");
    			set_style(canvas, "top", "-180px");
    			set_style(canvas, "transform", "scale(0.5)");
    			add_location(canvas, file$u, 434, 16, 17376);
    			set_style(img, "width", "170px");
    			set_style(img, "height", "170px");
    			set_style(img, "border-radius", "50%");
    			set_style(img, "position", "absolute");
    			set_style(img, "top", "95px");
    			if (!src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "id", "playgroundImg");
    			attr_dev(img, "class", "cover-img cover-img-rotate svelte-1c6ptft");
    			add_location(img, file$u, 435, 16, 17512);
    			set_style(div2, "height", "54vh");
    			set_style(div2, "position", "relative");
    			set_style(div2, "justify-content", "center");
    			set_style(div2, "align-content", "center");

    			set_style(div2, "display", /*$mainCoverTypeStore*/ ctx[27] === 'cover' && /*$showVisualizerStore*/ ctx[30] === '1'
    			? 'flex'
    			: 'none');

    			add_location(div2, file$u, 427, 12, 17042);
    			attr_dev(div3, "class", "top-box svelte-1c6ptft");
    			add_location(div3, file$u, 423, 8, 16815);
    			attr_dev(span0, "class", "alia svelte-1c6ptft");
    			add_location(span0, file$u, 477, 24, 19465);
    			attr_dev(div4, "class", "name svelte-1c6ptft");
    			add_location(div4, file$u, 475, 20, 19371);
    			add_location(span1, file$u, 499, 24, 20631);
    			attr_dev(div5, "class", "songer svelte-1c6ptft");
    			add_location(div5, file$u, 481, 20, 19698);
    			attr_dev(div6, "class", "song svelte-1c6ptft");
    			add_location(div6, file$u, 474, 16, 19331);
    			attr_dev(div7, "class", "line svelte-1c6ptft");
    			add_location(div7, file$u, 505, 20, 20888);
    			attr_dev(div8, "class", "time-item start svelte-1c6ptft");
    			add_location(div8, file$u, 510, 24, 21161);
    			attr_dev(span2, "class", "quality-span svelte-1c6ptft");
    			add_location(span2, file$u, 523, 28, 21888);
    			attr_dev(div9, "class", "time-item quality svelte-1c6ptft");
    			add_location(div9, file$u, 511, 24, 21235);
    			attr_dev(div10, "class", "time-item end svelte-1c6ptft");
    			add_location(div10, file$u, 530, 24, 22363);
    			attr_dev(div11, "class", "time svelte-1c6ptft");
    			add_location(div11, file$u, 509, 20, 21117);
    			attr_dev(div12, "class", "progress");
    			add_location(div12, file$u, 504, 16, 20844);
    			attr_dev(div13, "class", "info svelte-1c6ptft");
    			add_location(div13, file$u, 473, 12, 19295);
    			attr_dev(div14, "class", "tool-item lyric svelte-1c6ptft");
    			add_location(div14, file$u, 536, 16, 22556);
    			attr_dev(div15, "class", "tool svelte-1c6ptft");
    			add_location(div15, file$u, 534, 12, 22491);
    			attr_dev(div16, "class", "con-item pre svelte-1c6ptft");
    			add_location(div16, file$u, 611, 16, 26712);
    			attr_dev(div17, "class", "con-item pause svelte-1c6ptft");
    			add_location(div17, file$u, 624, 16, 27272);
    			attr_dev(div18, "class", "con-item next svelte-1c6ptft");
    			add_location(div18, file$u, 652, 16, 28903);
    			attr_dev(div19, "class", "control svelte-1c6ptft");
    			add_location(div19, file$u, 610, 12, 26673);
    			attr_dev(div20, "class", "control-box svelte-1c6ptft");
    			add_location(div20, file$u, 472, 8, 19256);
    			attr_dev(div21, "class", "play svelte-1c6ptft");
    			add_location(div21, file$u, 422, 4, 16787);
    			attr_dev(div22, "class", "play-bg svelte-1c6ptft");
    			set_style(div22, "background", "url(" + (/*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800') + ")");
    			set_style(div22, "top", /*$maxPlayToTopStore*/ ctx[29]);
    			add_location(div22, file$u, 417, 0, 16594);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div22, anchor);
    			append_dev(div22, div21);
    			append_dev(div21, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, canvas);
    			append_dev(div2, t1);
    			append_dev(div2, img);
    			append_dev(div3, t2);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div3, null);
    			}

    			append_dev(div21, t3);
    			append_dev(div21, div20);
    			append_dev(div20, div13);
    			append_dev(div13, div6);
    			append_dev(div6, div4);
    			append_dev(div4, t4);
    			append_dev(div4, t5);
    			append_dev(div4, span0);
    			append_dev(span0, t6);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div5, t8);
    			append_dev(div5, t9);
    			append_dev(div5, span1);
    			append_dev(span1, t10);
    			append_dev(div13, t11);
    			append_dev(div13, div12);
    			append_dev(div12, div7);
    			mount_component(progress, div7, null);
    			append_dev(div12, t12);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, t13);
    			append_dev(div11, t14);
    			append_dev(div11, div9);
    			append_dev(div9, span2);
    			append_dev(span2, t15);
    			append_dev(div11, t16);
    			append_dev(div11, div10);
    			append_dev(div10, t17);
    			append_dev(div20, t18);
    			append_dev(div20, div15);
    			append_dev(div15, div14);
    			if_blocks_1[current_block_type_index_1].m(div14, null);
    			/*div14_binding*/ ctx[55](div14);
    			append_dev(div15, t19);
    			if (if_block2) if_block2.m(div15, null);
    			append_dev(div15, t20);
    			if (if_block3) if_block3.m(div15, null);
    			append_dev(div15, t21);
    			if (if_block4) if_block4.m(div15, null);
    			append_dev(div15, t22);
    			if (if_block5) if_block5.m(div15, null);
    			append_dev(div15, t23);
    			if (if_block6) if_block6.m(div15, null);
    			append_dev(div20, t24);
    			append_dev(div20, div19);
    			append_dev(div19, div16);
    			if_blocks_2[current_block_type_index_2].m(div16, null);
    			/*div16_binding*/ ctx[63](div16);
    			append_dev(div19, t25);
    			append_dev(div19, div17);
    			if_blocks_3[current_block_type_index_3].m(div17, null);
    			/*div17_binding*/ ctx[64](div17);
    			append_dev(div19, t26);
    			append_dev(div19, div18);
    			mount_component(skipforwardfill, div18, null);
    			/*div18_binding*/ ctx[66](div18);
    			/*div22_binding*/ ctx[67](div22);
    			insert_dev(target, t27, anchor);
    			if (if_block9) if_block9.m(target, anchor);
    			insert_dev(target, t28, anchor);
    			mount_component(picker, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*handleDown*/ ctx[37], false, false, false),
    					listen_dev(div1, "touchstart", /*touchStart*/ ctx[47], false, false, false),
    					listen_dev(div1, "touchend", /*touchEnd*/ ctx[48], false, false, false),
    					listen_dev(div1, "touchmove", /*touchMove*/ ctx[49], false, false, false),
    					listen_dev(div2, "click", /*handleDown*/ ctx[37], false, false, false),
    					listen_dev(div5, "click", /*click_handler*/ ctx[53], false, false, false),
    					listen_dev(div9, "click", /*click_handler_1*/ ctx[54], false, false, false),
    					listen_dev(div14, "click", /*changeLyricFun*/ ctx[42], false, false, false),
    					listen_dev(div16, "click", /*click_handler_3*/ ctx[62], false, false, false),
    					listen_dev(div17, "click", /*click_handler_4*/ ctx[65], false, false, false),
    					listen_dev(div18, "click", /*playNextFun*/ ctx[38], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$currentSongStore*/ 8 && !src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty[0] & /*$mainCoverTypeStore, $showVisualizerStore*/ 1207959552) {
    				set_style(div2, "display", /*$mainCoverTypeStore*/ ctx[27] === 'cover' && /*$showVisualizerStore*/ ctx[30] === '1'
    				? 'flex'
    				: 'none');
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(div3, null);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if ((!current || dirty[0] & /*$currentSongStore*/ 8) && t4_value !== (t4_value = /*$currentSongStore*/ ctx[3].name + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty[0] & /*$currentSongStore*/ 8) && t6_value !== (t6_value = (/*$currentSongStore*/ ctx[3].alia && /*$currentSongStore*/ ctx[3].alia.length > 0
    			? `(${/*$currentSongStore*/ ctx[3].alia[0]})`
    			: '') + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty[0] & /*$currentSongStore*/ 8) && t8_value !== (t8_value = songerListToStr(/*$currentSongStore*/ ctx[3].ar) + "")) set_data_dev(t8, t8_value);

    			if ((!current || dirty[0] & /*$currentSongStore*/ 8) && t10_value !== (t10_value = (/*$currentSongStore*/ ctx[3].al.name === ''
    			? ''
    			: `- ${/*$currentSongStore*/ ctx[3].al.name}`) + "")) set_data_dev(t10, t10_value);

    			const progress_changes = {};
    			if (dirty[0] & /*currentTimeLong*/ 2) progress_changes.current = /*currentTimeLong*/ ctx[1];
    			progress.$set(progress_changes);
    			if (!current || dirty[0] & /*currentTime*/ 1) set_data_dev(t13, /*currentTime*/ ctx[0]);

    			if ((!current || dirty[1] & /*$currentSongQualityStore*/ 2) && t15_value !== (t15_value = (/*$currentSongQualityStore*/ ctx[32] === 'FLAC' || /*$currentSongQualityStore*/ ctx[32] === ''
    			? /*$currentSongQualityStore*/ ctx[32]
    			: /*$currentSongQualityStore*/ ctx[32].toString().substring(0, /*$currentSongQualityStore*/ ctx[32].toString().length - 3) + 'K') + "")) set_data_dev(t15, t15_value);

    			if (!current || dirty[0] & /*endTime*/ 4) set_data_dev(t17, /*endTime*/ ctx[2]);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks_1[current_block_type_index_1];

    				if (!if_block1) {
    					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div14, null);
    			}

    			if (!/*$isFMPlayStore*/ ctx[28]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*$isFMPlayStore*/ 268435456) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_13(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div15, t20);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$isFMPlayStore*/ ctx[28] && /*$isLoginStore*/ ctx[4]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*$isFMPlayStore, $isLoginStore*/ 268435472) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_11(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div15, t21);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$isLoginStore*/ ctx[4]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*$isLoginStore*/ 16) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_8(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div15, t22);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!/*$isFMPlayStore*/ ctx[28]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*$isFMPlayStore*/ 268435456) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_4$4(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div15, t23);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*$isShowCommentStore*/ ctx[33] != '0') {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*$isShowCommentStore*/ 4) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_3$6(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div15, null);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_7(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block7 = if_blocks_2[current_block_type_index_2];

    				if (!if_block7) {
    					if_block7 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block7.c();
    				}

    				transition_in(if_block7, 1);
    				if_block7.m(div16, null);
    			}

    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_8(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block8 = if_blocks_3[current_block_type_index_3];

    				if (!if_block8) {
    					if_block8 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block8.c();
    				}

    				transition_in(if_block8, 1);
    				if_block8.m(div17, null);
    			}

    			if (!current || dirty[0] & /*$currentSongStore*/ 8) {
    				set_style(div22, "background", "url(" + (/*$currentSongStore*/ ctx[3].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800') + ")");
    			}

    			if (!current || dirty[0] & /*$maxPlayToTopStore*/ 536870912) {
    				set_style(div22, "top", /*$maxPlayToTopStore*/ ctx[29]);
    			}

    			if (dirty[0] & /*$maxPlayToTopStore*/ 536870912 | dirty[1] & /*$playIsMaxStore*/ 8) show_if = /*$playIsMaxStore*/ ctx[34] && 0 < parseFloat(/*$maxPlayToTopStore*/ ctx[29]) < window.screen.height - 40;

    			if (show_if) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block$g(ctx);
    					if_block9.c();
    					if_block9.m(t28.parentNode, t28);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			const picker_changes = {};
    			if (dirty[0] & /*PickerShow*/ 4194304) picker_changes.isShow = /*PickerShow*/ ctx[22];
    			if (dirty[0] & /*songers*/ 2097152) picker_changes.list = /*songers*/ ctx[21];
    			picker.$set(picker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(progress.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			transition_in(skipforwardfill.$$.fragment, local);
    			transition_in(picker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(progress.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			transition_out(skipforwardfill.$$.fragment, local);
    			transition_out(picker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div22);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			destroy_component(progress);
    			if_blocks_1[current_block_type_index_1].d();
    			/*div14_binding*/ ctx[55](null);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if_blocks_2[current_block_type_index_2].d();
    			/*div16_binding*/ ctx[63](null);
    			if_blocks_3[current_block_type_index_3].d();
    			/*div17_binding*/ ctx[64](null);
    			destroy_component(skipforwardfill);
    			/*div18_binding*/ ctx[66](null);
    			/*div22_binding*/ ctx[67](null);
    			if (detaching) detach_dev(t27);
    			if (if_block9) if_block9.d(detaching);
    			if (detaching) detach_dev(t28);
    			destroy_component(picker, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let isLikeCurrentSong;
    	let likeLoading;
    	let noLikeLoading;
    	let lyricLoading;
    	let PickerShow;
    	let songers;
    	let $isHomePageStore;
    	let $location;
    	let $playRepeatModelStore;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $mainCoverTypeStore;
    	let $currentSongStore;
    	let $currentLyricStore;
    	let $isLoginStore;
    	let $FMPlayStore;
    	let $isFMPlayStore;
    	let $FMPlayNextStore;
    	let $userLikeSongIdsStore;
    	let $maxPlayToTopStore;
    	let $showVisualizerStore;
    	let $playStatusStore;
    	let $currentSongQualityStore;
    	let $isShowCommentStore;
    	let $playIsMaxStore;
    	validate_store(isHomePageStore, 'isHomePageStore');
    	component_subscribe($$self, isHomePageStore, $$value => $$invalidate(23, $isHomePageStore = $$value));
    	validate_store(location$1, 'location');
    	component_subscribe($$self, location$1, $$value => $$invalidate(24, $location = $$value));
    	validate_store(playRepeatModelStore, 'playRepeatModelStore');
    	component_subscribe($$self, playRepeatModelStore, $$value => $$invalidate(25, $playRepeatModelStore = $$value));
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(75, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(26, $currentPlayListStore = $$value));
    	validate_store(mainCoverTypeStore, 'mainCoverTypeStore');
    	component_subscribe($$self, mainCoverTypeStore, $$value => $$invalidate(27, $mainCoverTypeStore = $$value));
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(3, $currentSongStore = $$value));
    	validate_store(currentLyricStore, 'currentLyricStore');
    	component_subscribe($$self, currentLyricStore, $$value => $$invalidate(76, $currentLyricStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(4, $isLoginStore = $$value));
    	validate_store(FMPlayStore, 'FMPlayStore');
    	component_subscribe($$self, FMPlayStore, $$value => $$invalidate(77, $FMPlayStore = $$value));
    	validate_store(isFMPlayStore, 'isFMPlayStore');
    	component_subscribe($$self, isFMPlayStore, $$value => $$invalidate(28, $isFMPlayStore = $$value));
    	validate_store(FMPlayNextStore, 'FMPlayNextStore');
    	component_subscribe($$self, FMPlayNextStore, $$value => $$invalidate(78, $FMPlayNextStore = $$value));
    	validate_store(userLikeSongIdsStore, 'userLikeSongIdsStore');
    	component_subscribe($$self, userLikeSongIdsStore, $$value => $$invalidate(50, $userLikeSongIdsStore = $$value));
    	validate_store(maxPlayToTopStore, 'maxPlayToTopStore');
    	component_subscribe($$self, maxPlayToTopStore, $$value => $$invalidate(29, $maxPlayToTopStore = $$value));
    	validate_store(showVisualizerStore, 'showVisualizerStore');
    	component_subscribe($$self, showVisualizerStore, $$value => $$invalidate(30, $showVisualizerStore = $$value));
    	validate_store(playStatusStore, 'playStatusStore');
    	component_subscribe($$self, playStatusStore, $$value => $$invalidate(31, $playStatusStore = $$value));
    	validate_store(currentSongQualityStore, 'currentSongQualityStore');
    	component_subscribe($$self, currentSongQualityStore, $$value => $$invalidate(32, $currentSongQualityStore = $$value));
    	validate_store(isShowCommentStore, 'isShowCommentStore');
    	component_subscribe($$self, isShowCommentStore, $$value => $$invalidate(33, $isShowCommentStore = $$value));
    	validate_store(playIsMaxStore, 'playIsMaxStore');
    	component_subscribe($$self, playIsMaxStore, $$value => $$invalidate(34, $playIsMaxStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Play', slots, []);
    	let { currentTime = '0:00' } = $$props;
    	let { currentTimeLong = 0 } = $$props;
    	let { endTime = 0 } = $$props;
    	let lyricDom;
    	let listDom;
    	let loveDom;
    	let disloveDom;
    	let repeatDom;
    	let commentDom;
    	let preDom;
    	let playDom;
    	let nextDom;
    	let coverDom;
    	let playBgDom;
    	let touchMoveToTop = 0; //
    	let touchStartY; //Y
    	let touchEndY; //Y
    	let touchStartTime = 0; //
    	let touchEndTime = 0; //
    	let playListDom;

    	onMount(() => {
    		maxPlayToTopStore.set(window.screen.height + 'px');
    		playIsMaxStore.set(false);
    		mainCoverTypeStore.set('cover');
    		let wave = new bundle_cjs();

    		wave.fromElement('audioDom', 'playgroundCanvas', {
    			type: 'shine',
    			colors: ['white', 'red', 'blue']
    		});

    		if (lyricDom) ripple(lyricDom);
    		if (listDom) ripple(listDom);
    		if (loveDom) ripple(loveDom);
    		if (disloveDom) ripple(disloveDom);
    		if (repeatDom) ripple(repeatDom);
    		if (commentDom) ripple(commentDom);
    		if (preDom) ripple(preDom);
    		if (playDom) ripple(playDom);
    		if (nextDom) ripple(nextDom);
    		if (coverDom) ripple(coverDom);
    	});

    	//ProgresssetCurrentevent.detail.current
    	function getCurrent(event) {
    		window.audioDOM.currentTime = event.detail.current / 100 * window.audioDOM.duration;
    		$$invalidate(0, currentTime = timeToMinute(window.audioDOM.currentTime));
    		$$invalidate(1, currentTimeLong = window.audioDOM.currentTime / window.audioDOM.duration * 100);
    		$$invalidate(2, endTime = '-' + timeToMinute(window.audioDOM.duration - window.audioDOM.currentTime));
    		window.audioDOM.play();
    		playStatusStore.set(true);
    		if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    	}

    	//ProgresssetTimeCurrentevent.detail.timeCurrent 
    	function getTimeCurrent(event) {
    		window.audioDOM.currentTime = event.detail.timeCurrent / 100 * window.audioDOM.duration;
    		$$invalidate(0, currentTime = timeToMinute(window.audioDOM.currentTime));
    		$$invalidate(1, currentTimeLong = window.audioDOM.currentTime / window.audioDOM.duration * 100);
    		$$invalidate(2, endTime = '-' + timeToMinute(window.audioDOM.duration - window.audioDOM.currentTime));
    	}

    	function handleDown() {
    		maxPlayToTopStore.set(window.screen.height + 'px');
    		playIsMaxStore.set(false);
    		mainCoverTypeStore.set('cover');
    	}

    	//
    	function playNextFun() {
    		if ($isFMPlayStore) {
    			//FM
    			getSongUrlFun($FMPlayNextStore, 'next');

    			mainCoverTypeStore.set('cover');
    		} else {
    			if ($currentSongIndexStore === $currentPlayListStore.length - 1) {
    				Toast$1('');
    			} else {
    				if ($mainCoverTypeStore === 'lyric') mainCoverTypeStore.set('cover');

    				//
    				if ($playRepeatModelStore === 'shuffle') {
    					// Math.floor(Math.random() * 21);
    					let index = Math.floor(Math.random() * ($currentPlayListStore.length - 1));

    					getSongUrlFun($currentPlayListStore[index], 'shuffle', index);
    				} else {
    					currentSongIndexStore.set($currentSongIndexStore + 1);
    					getSongUrlFun($currentPlayListStore[$currentSongIndexStore], 'next');
    				}
    			}
    		}
    	}

    	//
    	function playPreFun() {
    		if ($currentSongIndexStore === 0) {
    			Toast$1('');
    		} else {
    			if ($mainCoverTypeStore === 'lyric') mainCoverTypeStore.set('cover');
    			getSongUrlFun($currentPlayListStore[$currentSongIndexStore - 1], 'pre');
    		}
    	}

    	//url
    	async function getSongUrlFun(song, type, index) {
    		const res = await getSongUrl(song.id);

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';

    				if ($isFMPlayStore) {
    					//FM
    					personalFMFun();

    					FMPlayStore.set(song);
    					currentSongStore.set(song);
    					currentPlayListStore.set([$FMPlayStore]);
    					currentSongIndexStore.set(0);
    					localStorage.setItem('currentSong', JSON.stringify(song));
    				} else {
    					//
    					if (type === 'next') {
    						if ($currentSongIndexStore !== $currentPlayListStore.length - 1) {
    							getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    						}
    					} else if (type === 'shuffle') {
    						//
    						if ($currentSongIndexStore !== $currentPlayListStore.length - 1) {
    							currentSongIndexStore.set(index);
    						}
    					} else {
    						//
    						currentSongIndexStore.set($currentSongIndexStore - 1);
    					}
    				}
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	//FM
    	async function personalFMFun() {
    		const res = await personalFM();

    		if (res.code === 200) {
    			res.data[0].al = res.data[0].album;
    			res.data[0].ar = res.data[0].artists;
    			res.data[0].alia = res.data[0].alias;
    			FMPlayNextStore.set(res.data[0]);
    			getSongUrl(res.data[0].id);
    		}
    	}

    	//
    	async function handleLoveFun() {
    		if ($isLoginStore) {
    			$$invalidate(19, likeLoading = true);

    			const res = await likeThisSong({
    				id: $currentSongStore.id,
    				like: !isLikeCurrentSong
    			});

    			if (res.code === 200) {
    				const ids = JSON.parse(localStorage.getItem('useLoveSongIds'));

    				if (isLikeCurrentSong) {
    					let i = ids.indexOf($currentSongStore.id);
    					ids.splice(i, 1);
    				} else {
    					ids.unshift($currentSongStore.id);
    				}

    				$$invalidate(19, likeLoading = false);
    				userLikeSongIdsStore.set(JSON.stringify(ids));
    				localStorage.setItem('useLoveSongIds', JSON.stringify(ids));
    			} else {
    				$$invalidate(19, likeLoading = false);
    			}
    		} else {
    			Toast$1('');
    		}
    	}

    	//FM 
    	async function handleFMNoLoveFun() {
    		$$invalidate(18, noLikeLoading = true);
    		const res = await fmTrash($currentSongStore.id);

    		if (res.code === 200) {
    			$$invalidate(18, noLikeLoading = false);
    			playNextFun();
    		}
    	}

    	//
    	function changeLyricFun() {
    		if ($mainCoverTypeStore !== 'lyric') {
    			getlyricFun();
    		} else {
    			mainCoverTypeStore.set('cover');
    		}
    	}

    	//
    	async function getlyricFun() {
    		if ($currentLyricStore.songId === $currentSongStore.id) {
    			mainCoverTypeStore.set('lyric');
    		} else {
    			$$invalidate(17, lyricLoading = true);
    			const res = await getLyric($currentSongStore.id);

    			if (res.code === 200) {
    				$$invalidate(17, lyricLoading = false);

    				if (res.nolyric || res.needDesc || res.lrc.lyric === '') {
    					Toast$1('!!');
    					currentLyricStore.set({ songId: null, lyric: null, tlyric: null });
    					localStorage.setItem('currentLyric', JSON.stringify({ songId: null, lyric: null, tlyric: null }));
    				} else {
    					currentLyricStore.set({
    						songId: $currentSongStore.id,
    						lyric: res.lrc.lyric,
    						tlyric: res.tlyric.lyric
    					});

    					localStorage.setItem('currentLyric', JSON.stringify({
    						songId: $currentSongStore.id,
    						lyric: res.lrc.lyric,
    						tlyric: res.tlyric.lyric
    					}));

    					mainCoverTypeStore.set('lyric');
    				}
    			} else {
    				$$invalidate(17, lyricLoading = false);
    			}
    		}
    	}

    	//
    	function changeListFun() {
    		if ($mainCoverTypeStore !== 'list') {
    			if ($currentSongIndexStore > 200) {
    				let r = confirm(' 200');

    				if (r === true) {
    					if ($currentPlayListStore.length > 200) {
    						Toast$1('...', 1000, () => {
    							mainCoverTypeStore.set('list');

    							setTimeout(
    								() => {
    									$$invalidate(16, playListDom.scrollTop = 60 * $currentSongIndexStore, playListDom);
    								},
    								100
    							); //DOM
    						});
    					} else {
    						mainCoverTypeStore.set('list');

    						setTimeout(
    							() => {
    								$$invalidate(16, playListDom.scrollTop = 60 * $currentSongIndexStore, playListDom);
    							},
    							100
    						); //DOM
    					}
    				}
    			} else {
    				if ($currentPlayListStore.length > 200) {
    					Toast$1('...', 1000, () => {
    						mainCoverTypeStore.set('list');

    						setTimeout(
    							() => {
    								$$invalidate(16, playListDom.scrollTop = 60 * $currentSongIndexStore, playListDom);
    							},
    							100
    						); //DOM
    					});
    				} else {
    					mainCoverTypeStore.set('list');

    					setTimeout(
    						() => {
    							$$invalidate(16, playListDom.scrollTop = 60 * $currentSongIndexStore, playListDom);
    						},
    						100
    					); //DOM
    				}
    			}
    		} else {
    			mainCoverTypeStore.set('cover');
    		}
    	}

    	// 
    	function changeRrpeatFun(e) {
    		if ($playRepeatModelStore === 'heart') {
    			Toast$1('');
    		} else {
    			if ($playRepeatModelStore === 'repeat') {
    				playRepeatModelStore.set('shuffle');
    			} else if ($playRepeatModelStore === 'shuffle') {
    				playRepeatModelStore.set('repeatOnce');
    			} else {
    				playRepeatModelStore.set('repeat');
    			}
    		}
    	}

    	//
    	function lyricClickFun() {
    		mainCoverTypeStore.set('cover');
    	}

    	//
    	function toCommentFun() {
    		mainCoverTypeStore.set('cover');
    		maxPlayToTopStore.set(window.screen.height + 'px');
    		playIsMaxStore.set(false);

    		if (!($location === '/musicComment')) {
    			if ($isHomePageStore) isHomePageStore.set(false);
    			push('/musicComment');
    		}
    	}

    	//
    	function touchStart(e) {
    		touchStartTime = new Date().getTime();
    		touchStartY = e.changedTouches[0].clientY;
    		touchMoveToTop = 0;
    		maxPlayToTopStore.set(touchMoveToTop + 'px');
    	}

    	//
    	function touchEnd(e) {
    		touchEndTime = new Date().getTime();
    		touchEndY = e.changedTouches[0].clientY;

    		// 100
    		// 
    		// 1000.8
    		// 0.30.3-0.8250250
    		if (touchMoveToTop >= window.screen.height / 2) {
    			//
    			maxPlayToTopStore.set(window.screen.height + 'px');

    			playIsMaxStore.set(false);
    			mainCoverTypeStore.set('cover');
    		} else if (touchEndY - touchStartY <= 100) {
    			maxPlayToTopStore.set('0px');
    		} else if (touchEndY - touchStartY > 100 && (touchEndY - touchStartY) / (touchEndTime - touchStartTime) >= 0.8) {
    			maxPlayToTopStore.set(window.screen.height + 'px');
    			playIsMaxStore.set(false);
    			mainCoverTypeStore.set('cover');
    		} else if (touchEndY - touchStartY > 100 && (touchEndY - touchStartY) / (touchEndTime - touchStartTime) <= 0.3) {
    			maxPlayToTopStore.set('0px');
    		} else if (0.3 < (touchEndY - touchStartY) / (touchEndTime - touchStartTime) < 0.8 && touchEndY - touchStartY > 250) {
    			maxPlayToTopStore.set(window.screen.height + 'px');
    			playIsMaxStore.set(false);
    			mainCoverTypeStore.set('cover');
    		} else {
    			maxPlayToTopStore.set('0px');
    		}
    	}

    	//
    	function touchMove(e) {
    		//
    		e.preventDefault();

    		e.stopPropagation();

    		if (parseFloat(playBgDom.style['top']) >= 0) {
    			touchMoveToTop = e.changedTouches[0].clientY - touchStartY;
    			maxPlayToTopStore.set(touchMoveToTop + 'px');
    		}
    	}

    	const writable_props = ['currentTime', 'currentTimeLong', 'endTime'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Play> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			coverDom = $$value;
    			$$invalidate(14, coverDom);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playListDom = $$value;
    			$$invalidate(16, playListDom);
    		});
    	}

    	const click_handler = () => {
    		if (songers.length === 1) {
    			if (songers[0].id != 0) {
    				mainCoverTypeStore.set('cover');
    				maxPlayToTopStore.set(window.screen.height + 'px');
    				playIsMaxStore.set(false);
    				isHomePageStore.set(false);
    				currentDetailSongerIdStore.set(songers[0].id);
    				push('/songerDetail');
    			}
    		} else {
    			$$invalidate(22, PickerShow = true);
    		}
    	};

    	const click_handler_1 = () => {
    		mainCoverTypeStore.set('cover');
    		maxPlayToTopStore.set(window.screen.height + 'px');
    		playIsMaxStore.set(false);

    		if (!($location === '/brSelect')) {
    			if ($isHomePageStore) isHomePageStore.set(false);
    			push('/brSelect');
    		}
    	};

    	function div14_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			lyricDom = $$value;
    			$$invalidate(5, lyricDom);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			listDom = $$value;
    			$$invalidate(6, listDom);
    		});
    	}

    	function div_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			disloveDom = $$value;
    			$$invalidate(8, disloveDom);
    		});
    	}

    	function div_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			loveDom = $$value;
    			$$invalidate(7, loveDom);
    		});
    	}

    	const click_handler_2 = e => changeRrpeatFun();

    	function div_binding_4($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			repeatDom = $$value;
    			$$invalidate(9, repeatDom);
    		});
    	}

    	function div_binding_5($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			commentDom = $$value;
    			$$invalidate(10, commentDom);
    		});
    	}

    	const click_handler_3 = () => {
    		if (!$isFMPlayStore) playPreFun();
    	};

    	function div16_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			preDom = $$value;
    			$$invalidate(11, preDom);
    		});
    	}

    	function div17_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playDom = $$value;
    			$$invalidate(12, playDom);
    		});
    	}

    	const click_handler_4 = () => {
    		if ($playStatusStore) {
    			window.audioDOM.pause();
    			playStatusStore.set(false);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'paused';
    			localStorage.setItem('pauseTimes', new Date().getTime());
    		} else {
    			//URL(30)
    			if ((new Date().getTime() - Number(localStorage.getItem('pauseTimes'))) / 1000 / 60 > 30) {
    				window.audioDOM.src = `https://music.163.com/song/media/outer/url?id=${$currentSongStore.id}.mp3`;
    			}

    			window.audioDOM.play();
    			playStatusStore.set(true);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    		}
    	};

    	function div18_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			nextDom = $$value;
    			$$invalidate(13, nextDom);
    		});
    	}

    	function div22_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playBgDom = $$value;
    			$$invalidate(15, playBgDom);
    		});
    	}

    	const ChangeShow_handler = e => {
    		$$invalidate(22, PickerShow = e.detail.isShow);
    	};

    	const PickerClick_handler = e => {
    		if (e.detail.item.id != 0) {
    			mainCoverTypeStore.set('cover');
    			maxPlayToTopStore.set(window.screen.height + 'px');
    			playIsMaxStore.set(false);
    			isHomePageStore.set(false);
    			currentDetailSongerIdStore.set(e.detail.item.id);
    			push('/songerDetail');
    		}
    	};

    	$$self.$$set = $$props => {
    		if ('currentTime' in $$props) $$invalidate(0, currentTime = $$props.currentTime);
    		if ('currentTimeLong' in $$props) $$invalidate(1, currentTimeLong = $$props.currentTimeLong);
    		if ('endTime' in $$props) $$invalidate(2, endTime = $$props.endTime);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		push,
    		location: location$1,
    		SkipBackFill,
    		SkipForwardFill,
    		PlayFill,
    		PauseFill,
    		ChatQuoteLine,
    		ChatQuoteFill,
    		Message2Line,
    		RadioLine,
    		Heart2Line,
    		Heart2Fill,
    		DislikeLine,
    		RepeatOneLine,
    		ShuffleLine,
    		PlayListLine,
    		PlayListFill,
    		SortDesc,
    		HeartPulseLine,
    		Wave: bundle_cjs,
    		Picker,
    		Progress,
    		Lyric,
    		SongList,
    		getSongUrl,
    		personalFM,
    		likeThisSong,
    		getLyric,
    		fmTrash,
    		playStatusStore,
    		currentSongStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		maxPlayToTopStore,
    		playIsMaxStore,
    		isFMPlayStore,
    		FMPlayNextStore,
    		FMPlayStore,
    		currentLyricStore,
    		mainCoverTypeStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		isLoginStore,
    		isHomePageStore,
    		currentDetailSongerIdStore,
    		isShowCommentStore,
    		userLikeSongIdsStore,
    		showVisualizerStore,
    		timeToMinute,
    		songerListToStr,
    		Toast: Toast$1,
    		ripple,
    		currentTime,
    		currentTimeLong,
    		endTime,
    		lyricDom,
    		listDom,
    		loveDom,
    		disloveDom,
    		repeatDom,
    		commentDom,
    		preDom,
    		playDom,
    		nextDom,
    		coverDom,
    		playBgDom,
    		touchMoveToTop,
    		touchStartY,
    		touchEndY,
    		touchStartTime,
    		touchEndTime,
    		playListDom,
    		getCurrent,
    		getTimeCurrent,
    		handleDown,
    		playNextFun,
    		playPreFun,
    		getSongUrlFun,
    		personalFMFun,
    		handleLoveFun,
    		handleFMNoLoveFun,
    		changeLyricFun,
    		getlyricFun,
    		changeListFun,
    		changeRrpeatFun,
    		lyricClickFun,
    		toCommentFun,
    		touchStart,
    		touchEnd,
    		touchMove,
    		lyricLoading,
    		noLikeLoading,
    		likeLoading,
    		isLikeCurrentSong,
    		songers,
    		PickerShow,
    		$isHomePageStore,
    		$location,
    		$playRepeatModelStore,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$mainCoverTypeStore,
    		$currentSongStore,
    		$currentLyricStore,
    		$isLoginStore,
    		$FMPlayStore,
    		$isFMPlayStore,
    		$FMPlayNextStore,
    		$userLikeSongIdsStore,
    		$maxPlayToTopStore,
    		$showVisualizerStore,
    		$playStatusStore,
    		$currentSongQualityStore,
    		$isShowCommentStore,
    		$playIsMaxStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentTime' in $$props) $$invalidate(0, currentTime = $$props.currentTime);
    		if ('currentTimeLong' in $$props) $$invalidate(1, currentTimeLong = $$props.currentTimeLong);
    		if ('endTime' in $$props) $$invalidate(2, endTime = $$props.endTime);
    		if ('lyricDom' in $$props) $$invalidate(5, lyricDom = $$props.lyricDom);
    		if ('listDom' in $$props) $$invalidate(6, listDom = $$props.listDom);
    		if ('loveDom' in $$props) $$invalidate(7, loveDom = $$props.loveDom);
    		if ('disloveDom' in $$props) $$invalidate(8, disloveDom = $$props.disloveDom);
    		if ('repeatDom' in $$props) $$invalidate(9, repeatDom = $$props.repeatDom);
    		if ('commentDom' in $$props) $$invalidate(10, commentDom = $$props.commentDom);
    		if ('preDom' in $$props) $$invalidate(11, preDom = $$props.preDom);
    		if ('playDom' in $$props) $$invalidate(12, playDom = $$props.playDom);
    		if ('nextDom' in $$props) $$invalidate(13, nextDom = $$props.nextDom);
    		if ('coverDom' in $$props) $$invalidate(14, coverDom = $$props.coverDom);
    		if ('playBgDom' in $$props) $$invalidate(15, playBgDom = $$props.playBgDom);
    		if ('touchMoveToTop' in $$props) touchMoveToTop = $$props.touchMoveToTop;
    		if ('touchStartY' in $$props) touchStartY = $$props.touchStartY;
    		if ('touchEndY' in $$props) touchEndY = $$props.touchEndY;
    		if ('touchStartTime' in $$props) touchStartTime = $$props.touchStartTime;
    		if ('touchEndTime' in $$props) touchEndTime = $$props.touchEndTime;
    		if ('playListDom' in $$props) $$invalidate(16, playListDom = $$props.playListDom);
    		if ('lyricLoading' in $$props) $$invalidate(17, lyricLoading = $$props.lyricLoading);
    		if ('noLikeLoading' in $$props) $$invalidate(18, noLikeLoading = $$props.noLikeLoading);
    		if ('likeLoading' in $$props) $$invalidate(19, likeLoading = $$props.likeLoading);
    		if ('isLikeCurrentSong' in $$props) $$invalidate(20, isLikeCurrentSong = $$props.isLikeCurrentSong);
    		if ('songers' in $$props) $$invalidate(21, songers = $$props.songers);
    		if ('PickerShow' in $$props) $$invalidate(22, PickerShow = $$props.PickerShow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$isLoginStore, $currentSongStore*/ 24 | $$self.$$.dirty[1] & /*$userLikeSongIdsStore*/ 524288) {
    			$$invalidate(20, isLikeCurrentSong = $isLoginStore
    			? $userLikeSongIdsStore.includes($currentSongStore.id)
    			: false); //
    		}

    		if ($$self.$$.dirty[0] & /*$currentSongStore*/ 8) {
    			$$invalidate(21, songers = $currentSongStore.ar);
    		}
    	};

    	$$invalidate(19, likeLoading = false); //loading
    	$$invalidate(18, noLikeLoading = false); //FMloading
    	$$invalidate(17, lyricLoading = false); //loading
    	$$invalidate(22, PickerShow = false);

    	return [
    		currentTime,
    		currentTimeLong,
    		endTime,
    		$currentSongStore,
    		$isLoginStore,
    		lyricDom,
    		listDom,
    		loveDom,
    		disloveDom,
    		repeatDom,
    		commentDom,
    		preDom,
    		playDom,
    		nextDom,
    		coverDom,
    		playBgDom,
    		playListDom,
    		lyricLoading,
    		noLikeLoading,
    		likeLoading,
    		isLikeCurrentSong,
    		songers,
    		PickerShow,
    		$isHomePageStore,
    		$location,
    		$playRepeatModelStore,
    		$currentPlayListStore,
    		$mainCoverTypeStore,
    		$isFMPlayStore,
    		$maxPlayToTopStore,
    		$showVisualizerStore,
    		$playStatusStore,
    		$currentSongQualityStore,
    		$isShowCommentStore,
    		$playIsMaxStore,
    		getCurrent,
    		getTimeCurrent,
    		handleDown,
    		playNextFun,
    		playPreFun,
    		handleLoveFun,
    		handleFMNoLoveFun,
    		changeLyricFun,
    		changeListFun,
    		changeRrpeatFun,
    		lyricClickFun,
    		toCommentFun,
    		touchStart,
    		touchEnd,
    		touchMove,
    		$userLikeSongIdsStore,
    		div1_binding,
    		div_binding,
    		click_handler,
    		click_handler_1,
    		div14_binding,
    		div_binding_1,
    		div_binding_2,
    		div_binding_3,
    		click_handler_2,
    		div_binding_4,
    		div_binding_5,
    		click_handler_3,
    		div16_binding,
    		div17_binding,
    		click_handler_4,
    		div18_binding,
    		div22_binding,
    		ChangeShow_handler,
    		PickerClick_handler
    	];
    }

    class Play extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$u,
    			create_fragment$u,
    			safe_not_equal,
    			{
    				currentTime: 0,
    				currentTimeLong: 1,
    				endTime: 2
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Play",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get currentTime() {
    		throw new Error("<Play>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentTime(value) {
    		throw new Error("<Play>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentTimeLong() {
    		throw new Error("<Play>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentTimeLong(value) {
    		throw new Error("<Play>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get endTime() {
    		throw new Error("<Play>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set endTime(value) {
    		throw new Error("<Play>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\MiniPlay.svelte generated by Svelte v3.46.4 */
    const file$t = "src\\components\\MiniPlay.svelte";

    // (186:4) <Lazy height={50}>
    function create_default_slot$h(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[4].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-11g8v3x");
    			add_location(img, file$t, 186, 6, 6176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentSongStore*/ 16 && !src_url_equal(img.src, img_src_value = /*$currentSongStore*/ ctx[4].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800')) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(186:4) <Lazy height={50}>",
    		ctx
    	});

    	return block;
    }

    // (207:4) {:else}
    function create_else_block$7(ctx) {
    	let playfill;
    	let current;

    	playfill = new PlayFill({
    			props: {
    				size: "40",
    				style: "vertical-align: middle;height:57px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(playfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(207:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (205:4) {#if $playStatusStore}
    function create_if_block$f(ctx) {
    	let pausefill;
    	let current;

    	pausefill = new PauseFill({
    			props: {
    				size: "40",
    				style: "vertical-align: middle;height:57px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pausefill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pausefill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pausefill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pausefill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pausefill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(205:4) {#if $playStatusStore}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div7;
    	let div0;
    	let t0;
    	let div1;
    	let lazy;
    	let t1;
    	let div4;
    	let div2;
    	let t2_value = /*$currentSongStore*/ ctx[4].name + "";
    	let t2;
    	let t3;
    	let span0;

    	let t4_value = (/*$currentSongStore*/ ctx[4].alia && /*$currentSongStore*/ ctx[4].alia.length > 0
    	? `(${/*$currentSongStore*/ ctx[4].alia[0]})`
    	: '') + "";

    	let t4;
    	let t5;
    	let div3;
    	let t6_value = songerListToStr(/*$currentSongStore*/ ctx[4].ar) + "";
    	let t6;
    	let t7;
    	let span1;

    	let t8_value = (/*$currentSongStore*/ ctx[4].al.name === ''
    	? ''
    	: `- ${/*$currentSongStore*/ ctx[4].al.name}`) + "";

    	let t8;
    	let t9;
    	let div5;
    	let current_block_type_index;
    	let if_block;
    	let t10;
    	let div6;
    	let skipforwardminifill;
    	let current;
    	let mounted;
    	let dispose;

    	lazy = new Src({
    			props: {
    				height: 50,
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$f, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$playStatusStore*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	skipforwardminifill = new SkipForwardMiniFill({
    			props: {
    				size: "40",
    				style: "vertical-align: middle;height:57px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			create_component(lazy.$$.fragment);
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			span0 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			span1 = element("span");
    			t8 = text(t8_value);
    			t9 = space();
    			div5 = element("div");
    			if_block.c();
    			t10 = space();
    			div6 = element("div");
    			create_component(skipforwardminifill.$$.fragment);
    			attr_dev(div0, "class", "progress svelte-11g8v3x");
    			set_style(div0, "width", /*currentTimeLong*/ ctx[0] / 100 * window.screen.width + "px");
    			add_location(div0, file$t, 183, 2, 5964);
    			attr_dev(div1, "class", "cover svelte-11g8v3x");
    			set_style(div1, "left", /*moveLong*/ ctx[3] + "px");
    			add_location(div1, file$t, 184, 2, 6078);
    			attr_dev(span0, "class", "alia svelte-11g8v3x");
    			add_location(span0, file$t, 192, 6, 6427);
    			attr_dev(div2, "class", "name svelte-11g8v3x");
    			add_location(div2, file$t, 190, 4, 6369);
    			add_location(span1, file$t, 198, 6, 6665);
    			attr_dev(div3, "class", "songer svelte-11g8v3x");
    			add_location(div3, file$t, 196, 4, 6590);
    			attr_dev(div4, "class", "info svelte-11g8v3x");
    			set_style(div4, "left", /*moveLong*/ ctx[3] + "px");
    			add_location(div4, file$t, 189, 2, 6298);
    			attr_dev(div5, "class", "pause svelte-11g8v3x");
    			add_location(div5, file$t, 203, 2, 6796);
    			attr_dev(div6, "class", "next svelte-11g8v3x");
    			add_location(div6, file$t, 210, 2, 7072);
    			attr_dev(div7, "class", "play secondary svelte-11g8v3x");
    			set_style(div7, "bottom", (/*$isHomePageStore*/ ctx[6] ? 56 : 0) + "px");
    			add_location(div7, file$t, 176, 0, 5794);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div7, t0);
    			append_dev(div7, div1);
    			mount_component(lazy, div1, null);
    			append_dev(div7, t1);
    			append_dev(div7, div4);
    			append_dev(div4, div2);
    			append_dev(div2, t2);
    			append_dev(div2, t3);
    			append_dev(div2, span0);
    			append_dev(span0, t4);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, t6);
    			append_dev(div3, t7);
    			append_dev(div3, span1);
    			append_dev(span1, t8);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			if_blocks[current_block_type_index].m(div5, null);
    			/*div5_binding*/ ctx[13](div5);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			mount_component(skipforwardminifill, div6, null);
    			/*div6_binding*/ ctx[14](div6);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleMax*/ ctx[7], false, false, false),
    					listen_dev(div1, "click", /*handleMax*/ ctx[7], false, false, false),
    					listen_dev(div4, "click", /*handleMax*/ ctx[7], false, false, false),
    					listen_dev(div5, "click", /*miniPlayFun*/ ctx[8], false, false, false),
    					listen_dev(div6, "click", /*miniNextFun*/ ctx[9], false, false, false),
    					listen_dev(div7, "touchstart", /*touchStart*/ ctx[10], false, false, false),
    					listen_dev(div7, "touchend", /*touchEnd*/ ctx[11], false, false, false),
    					listen_dev(div7, "touchmove", /*touchMove*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*currentTimeLong*/ 1) {
    				set_style(div0, "width", /*currentTimeLong*/ ctx[0] / 100 * window.screen.width + "px");
    			}

    			const lazy_changes = {};

    			if (dirty & /*$$scope, $currentSongStore*/ 268435472) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);

    			if (!current || dirty & /*moveLong*/ 8) {
    				set_style(div1, "left", /*moveLong*/ ctx[3] + "px");
    			}

    			if ((!current || dirty & /*$currentSongStore*/ 16) && t2_value !== (t2_value = /*$currentSongStore*/ ctx[4].name + "")) set_data_dev(t2, t2_value);

    			if ((!current || dirty & /*$currentSongStore*/ 16) && t4_value !== (t4_value = (/*$currentSongStore*/ ctx[4].alia && /*$currentSongStore*/ ctx[4].alia.length > 0
    			? `(${/*$currentSongStore*/ ctx[4].alia[0]})`
    			: '') + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*$currentSongStore*/ 16) && t6_value !== (t6_value = songerListToStr(/*$currentSongStore*/ ctx[4].ar) + "")) set_data_dev(t6, t6_value);

    			if ((!current || dirty & /*$currentSongStore*/ 16) && t8_value !== (t8_value = (/*$currentSongStore*/ ctx[4].al.name === ''
    			? ''
    			: `- ${/*$currentSongStore*/ ctx[4].al.name}`) + "")) set_data_dev(t8, t8_value);

    			if (!current || dirty & /*moveLong*/ 8) {
    				set_style(div4, "left", /*moveLong*/ ctx[3] + "px");
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div5, null);
    			}

    			if (!current || dirty & /*$isHomePageStore*/ 64) {
    				set_style(div7, "bottom", (/*$isHomePageStore*/ ctx[6] ? 56 : 0) + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(skipforwardminifill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(skipforwardminifill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(lazy);
    			if_blocks[current_block_type_index].d();
    			/*div5_binding*/ ctx[13](null);
    			destroy_component(skipforwardminifill);
    			/*div6_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let moveLong;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $FMPlayStore;
    	let $isFMPlayStore;
    	let $playRepeatModelStore;
    	let $FMPlayNextStore;
    	let $currentSongStore;
    	let $playStatusStore;
    	let $isHomePageStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(19, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(20, $currentPlayListStore = $$value));
    	validate_store(FMPlayStore, 'FMPlayStore');
    	component_subscribe($$self, FMPlayStore, $$value => $$invalidate(21, $FMPlayStore = $$value));
    	validate_store(isFMPlayStore, 'isFMPlayStore');
    	component_subscribe($$self, isFMPlayStore, $$value => $$invalidate(22, $isFMPlayStore = $$value));
    	validate_store(playRepeatModelStore, 'playRepeatModelStore');
    	component_subscribe($$self, playRepeatModelStore, $$value => $$invalidate(23, $playRepeatModelStore = $$value));
    	validate_store(FMPlayNextStore, 'FMPlayNextStore');
    	component_subscribe($$self, FMPlayNextStore, $$value => $$invalidate(24, $FMPlayNextStore = $$value));
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(4, $currentSongStore = $$value));
    	validate_store(playStatusStore, 'playStatusStore');
    	component_subscribe($$self, playStatusStore, $$value => $$invalidate(5, $playStatusStore = $$value));
    	validate_store(isHomePageStore, 'isHomePageStore');
    	component_subscribe($$self, isHomePageStore, $$value => $$invalidate(6, $isHomePageStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MiniPlay', slots, []);
    	let { currentTimeLong = window.audioDOM.currentTime / window.audioDOM.duration } = $$props;
    	let pauseDom;
    	let nextDom;
    	let touchStartX; //Y
    	let touchEndX; //Y
    	let touchStartTime = 0; //
    	let touchEndTime = 0; //

    	onMount(() => {
    		if (pauseDom) ripple(pauseDom);
    		if (nextDom) ripple(nextDom);
    	});

    	function handleMax() {
    		playIsMaxStore.set(true);
    		maxPlayToTopStore.set('0px');
    	}

    	function miniPlayFun() {
    		if ($playStatusStore) {
    			window.audioDOM.pause();
    			playStatusStore.set(false);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'paused';
    			localStorage.setItem('pauseTimes', new Date().getTime());
    		} else {
    			//URL(30)
    			if ((new Date().getTime() - Number(localStorage.getItem('pauseTimes'))) / 1000 / 60 > 30) {
    				window.audioDOM.src = `https://music.163.com/song/media/outer/url?id=${$currentSongStore.id}.mp3`;
    			}

    			window.audioDOM.play();
    			playStatusStore.set(true);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    		}
    	}

    	function miniNextFun() {
    		if ($isFMPlayStore) {
    			//FM
    			getSongUrlFun($FMPlayNextStore, 'fm');
    		} else {
    			if ($currentSongIndexStore === $currentPlayListStore.length - 1) {
    				Toast$1('');
    			} else {
    				//
    				if ($playRepeatModelStore === 'shuffle') {
    					let index = Math.floor(Math.random() * ($currentPlayListStore.length - 1));
    					getSongUrlFun($currentPlayListStore[index], 'shuffle', index);
    				} else {
    					currentSongIndexStore.set($currentSongIndexStore + 1);
    					getSongUrlFun($currentPlayListStore[$currentSongIndexStore], 'next');
    				}
    			}
    		}
    	}

    	//URL
    	async function getSongUrlFun(song, type, index) {
    		const res = await getSongUrl(song.id);

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';

    				if ($isFMPlayStore) {
    					//FM
    					personalFMFun();

    					FMPlayStore.set(song);
    					currentSongStore.set(song);
    					currentPlayListStore.set([$FMPlayStore]);
    					currentSongIndexStore.set(0);
    					localStorage.setItem('currentSong', JSON.stringify(song));
    				} else {
    					if (type === 'shuffle') {
    						//
    						currentSongStore.set(song);

    						localStorage.setItem('currentSong', JSON.stringify(song));
    						currentSongIndexStore.set(index);
    					} else {
    						currentSongStore.set(song);
    						localStorage.setItem('currentSong', JSON.stringify(song));

    						if ($currentSongIndexStore !== $currentPlayListStore.length - 1) {
    							getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    						}
    					}
    				}
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	//FM
    	async function personalFMFun() {
    		const res = await personalFM();

    		if (res.code === 200) {
    			res.data[0].al = res.data[0].album;
    			res.data[0].ar = res.data[0].artists;
    			res.data[0].alia = res.data[0].alias;
    			FMPlayNextStore.set(res.data[0]);
    		}
    	}

    	//FM
    	function playFMFun() {
    		getSongUrlFun(FMSong);
    		isFMPlayStore.set(true);
    		localStorage.setItem('isFMPlay', '1');
    		localStorage.setItem('FMPlay', JSON.stringify(FMSong));
    		personalFMFun();
    	}

    	//
    	function touchStart(e) {
    		touchStartTime = new Date().getTime();
    		touchStartX = e.changedTouches[0].clientX;
    	}

    	//
    	function touchEnd(e) {
    		$$invalidate(3, moveLong = 0);
    		touchEndTime = new Date().getTime();
    		touchEndX = e.changedTouches[0].clientX;

    		// 100
    		// 1000.5
    		// 
    		if (touchStartX - touchEndX > 100) {
    			miniNextFun();
    		} else if (touchStartX - touchEndX <= 100 && (touchStartX - touchEndX) / (touchEndTime - touchStartTime) >= 0.5) {
    			miniNextFun();
    		} else ;
    	}

    	//
    	function touchMove(e) {
    		//
    		e.preventDefault();

    		e.stopPropagation();

    		if (e.changedTouches[0].clientX - touchStartX < 0) {
    			$$invalidate(3, moveLong = e.changedTouches[0].clientX - touchStartX);
    		}
    	}

    	const writable_props = ['currentTimeLong'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MiniPlay> was created with unknown prop '${key}'`);
    	});

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			pauseDom = $$value;
    			$$invalidate(1, pauseDom);
    		});
    	}

    	function div6_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			nextDom = $$value;
    			$$invalidate(2, nextDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('currentTimeLong' in $$props) $$invalidate(0, currentTimeLong = $$props.currentTimeLong);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		PlayFill,
    		PauseFill,
    		SkipForwardMiniFill,
    		playIsMaxStore,
    		playStatusStore,
    		currentSongStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		maxPlayToTopStore,
    		isFMPlayStore,
    		FMPlayNextStore,
    		FMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		isHomePageStore,
    		getSongUrl,
    		personalFM,
    		ripple,
    		songerListToStr,
    		Toast: Toast$1,
    		currentTimeLong,
    		pauseDom,
    		nextDom,
    		touchStartX,
    		touchEndX,
    		touchStartTime,
    		touchEndTime,
    		handleMax,
    		miniPlayFun,
    		miniNextFun,
    		getSongUrlFun,
    		personalFMFun,
    		playFMFun,
    		touchStart,
    		touchEnd,
    		touchMove,
    		moveLong,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$FMPlayStore,
    		$isFMPlayStore,
    		$playRepeatModelStore,
    		$FMPlayNextStore,
    		$currentSongStore,
    		$playStatusStore,
    		$isHomePageStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentTimeLong' in $$props) $$invalidate(0, currentTimeLong = $$props.currentTimeLong);
    		if ('pauseDom' in $$props) $$invalidate(1, pauseDom = $$props.pauseDom);
    		if ('nextDom' in $$props) $$invalidate(2, nextDom = $$props.nextDom);
    		if ('touchStartX' in $$props) touchStartX = $$props.touchStartX;
    		if ('touchEndX' in $$props) touchEndX = $$props.touchEndX;
    		if ('touchStartTime' in $$props) touchStartTime = $$props.touchStartTime;
    		if ('touchEndTime' in $$props) touchEndTime = $$props.touchEndTime;
    		if ('moveLong' in $$props) $$invalidate(3, moveLong = $$props.moveLong);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(3, moveLong = 0); //

    	return [
    		currentTimeLong,
    		pauseDom,
    		nextDom,
    		moveLong,
    		$currentSongStore,
    		$playStatusStore,
    		$isHomePageStore,
    		handleMax,
    		miniPlayFun,
    		miniNextFun,
    		touchStart,
    		touchEnd,
    		touchMove,
    		div5_binding,
    		div6_binding
    	];
    }

    class MiniPlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { currentTimeLong: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MiniPlay",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get currentTimeLong() {
    		throw new Error("<MiniPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentTimeLong(value) {
    		throw new Error("<MiniPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Loading.svelte generated by Svelte v3.46.4 */

    const file$s = "src\\components\\Loading.svelte";

    function create_fragment$s(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;
    	let t3;
    	let div4;
    	let t4;
    	let div5;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			t3 = space();
    			div4 = element("div");
    			t4 = space();
    			div5 = element("div");
    			attr_dev(div0, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div0, file$s, 2, 4, 48);
    			attr_dev(div1, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div1, file$s, 3, 4, 82);
    			attr_dev(div2, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div2, file$s, 4, 4, 116);
    			attr_dev(div3, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div3, file$s, 5, 4, 150);
    			attr_dev(div4, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div4, file$s, 6, 4, 184);
    			attr_dev(div5, "class", "sk-chase-dot svelte-xii8w4");
    			add_location(div5, file$s, 7, 4, 218);
    			attr_dev(div6, "class", "sk-chase svelte-xii8w4");
    			add_location(div6, file$s, 1, 2, 20);
    			attr_dev(div7, "class", "bg svelte-xii8w4");
    			add_location(div7, file$s, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			append_dev(div6, t0);
    			append_dev(div6, div1);
    			append_dev(div6, t1);
    			append_dev(div6, div2);
    			append_dev(div6, t2);
    			append_dev(div6, div3);
    			append_dev(div6, t3);
    			append_dev(div6, div4);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loading', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loading> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Loading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loading",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    // import { getCookies } from "../utils/common";

    /**
     * 
     :  ,, 
     : phone: 
     : ctcode: ,86
     : /captcha/sent
     : /captcha/sent?phone=13xxx} uid 
     * 
     */
    function sendSmsCode(phone) {
      return service({
        url: '/captcha/sent',
        method: 'get',
        params: {
          phone,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     *  :  ,
     */
    function userAccount(cookie) {
      return service({
        url: '/user/account',
        method: 'get',
        params: {
          cookie,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     *  :  ,  id, 
     * - uid :  id
     * - limit :  ,  30
     * - offset :  ,  :(  -1)*30,  30  limit  ,  0
     * @param {Object} params
     * @param {number} params.uid
     * @param {number} params.limit
     * @param {number=} params.offset
     */
    function userPlaylist(params) {
      params.timestamp = new Date().getTime();
      return service({
        url: '/user/playlist',
        method: 'get',
        params,
      });
    }

    /**
     * 
     *  :  , 
     */
    function logout() {
      return service({
        url: '/logout',
        method: 'post',
      });
    }

    /**
     * 
     *  :  ,  id, id(id)
     * - uid:  id
     * @param {number} uid
     */
    function userLikedSongsIDs(uid) {
      return service({
        url: '/likelist',
        method: 'get',
        params: {
          uid,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     *  :  ,  (  ,  ),  (  ),  3  , web/PC  2 
     * -  type:  ,  0,  0  ,1  web/PC 
     * @param {number} type
     */
    function dailySignin(type = 0) {
      return service({
        url: '/daily_signin',
        method: 'post',
        params: {
          type,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     *  : 
     */
    function likedArtists(params) {
      return service({
        url: '/artist/sublist',
        method: 'get',
        params: {
          limit: params.limit,
          timestamp: new Date().getTime(),
        },
      });
    }

    /* src\components\TopTitle.svelte generated by Svelte v3.46.4 */
    const file$r = "src\\components\\TopTitle.svelte";

    // (38:2) {#if topTitleRightList}
    function create_if_block$e(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_1$b, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*topTitleRightList*/ ctx[3].type === 'icon') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "right svelte-f8uv3r");
    			add_location(div, file$r, 38, 4, 815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[8](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(38:2) {#if topTitleRightList}",
    		ctx
    	});

    	return block;
    }

    // (44:6) {:else}
    function create_else_block$6(ctx) {
    	let span;
    	let t_value = /*topTitleRightList*/ ctx[3].text + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "right-text svelte-f8uv3r");
    			add_location(span, file$r, 44, 8, 1092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_1*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*topTitleRightList*/ 8 && t_value !== (t_value = /*topTitleRightList*/ ctx[3].text + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(44:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:6) {#if topTitleRightList.type === 'icon'}
    function create_if_block_1$b(ctx) {
    	let span;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*topTitleRightList*/ ctx[3].path;

    	function switch_props(ctx) {
    		return { props: { size: "24" }, $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(span, "class", "svelte-f8uv3r");
    			toggle_class(span, "rotate-icon", /*isRefresh*/ ctx[2]);
    			add_location(span, file$r, 40, 8, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*topTitleRightList*/ ctx[3].path)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, span, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (dirty & /*isRefresh*/ 4) {
    				toggle_class(span, "rotate-icon", /*isRefresh*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(40:6) {#if topTitleRightList.type === 'icon'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div1;
    	let div0;
    	let h1;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block = /*topTitleRightList*/ ctx[3] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(/*title*/ ctx[0]);
    			span = element("span");
    			t1 = text("");
    			t2 = text(/*desc*/ ctx[1]);
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "desc svelte-f8uv3r");
    			add_location(span, file$r, 35, 15, 717);
    			attr_dev(h1, "class", "svelte-f8uv3r");
    			add_location(h1, file$r, 35, 4, 706);
    			attr_dev(div0, "class", "title");
    			add_location(div0, file$r, 34, 2, 681);
    			attr_dev(div1, "class", "top-title svelte-f8uv3r");
    			add_location(div1, file$r, 33, 0, 654);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(h1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(div1, t3);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);
    			if (!current || dirty & /*desc*/ 2) set_data_dev(t2, /*desc*/ ctx[1]);

    			if (/*topTitleRightList*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*topTitleRightList*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TopTitle', slots, []);
    	let { title = '' } = $$props;
    	let { desc = '' } = $$props;
    	let { isRefresh = false } = $$props;
    	let { topTitleRightList = {} } = $$props;
    	const dispatch = createEventDispatcher();

    	function setClick(index) {
    		dispatch('IconClick', { index });
    	}

    	let rightDoms;

    	onMount(() => {
    		if (rightDoms) {
    			ripple(rightDoms);
    		}

    		return () => {
    			$$invalidate(4, rightDoms = null);
    		};
    	});

    	afterUpdate(() => {
    		if (rightDoms) {
    			ripple(rightDoms);
    		}
    	});

    	const writable_props = ['title', 'desc', 'isRefresh', 'topTitleRightList'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TopTitle> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setClick(0);
    	const click_handler_1 = () => setClick(0);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			rightDoms = $$value;
    			$$invalidate(4, rightDoms);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('desc' in $$props) $$invalidate(1, desc = $$props.desc);
    		if ('isRefresh' in $$props) $$invalidate(2, isRefresh = $$props.isRefresh);
    		if ('topTitleRightList' in $$props) $$invalidate(3, topTitleRightList = $$props.topTitleRightList);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		ripple,
    		title,
    		desc,
    		isRefresh,
    		topTitleRightList,
    		dispatch,
    		setClick,
    		rightDoms
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('desc' in $$props) $$invalidate(1, desc = $$props.desc);
    		if ('isRefresh' in $$props) $$invalidate(2, isRefresh = $$props.isRefresh);
    		if ('topTitleRightList' in $$props) $$invalidate(3, topTitleRightList = $$props.topTitleRightList);
    		if ('rightDoms' in $$props) $$invalidate(4, rightDoms = $$props.rightDoms);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		desc,
    		isRefresh,
    		topTitleRightList,
    		rightDoms,
    		setClick,
    		click_handler,
    		click_handler_1,
    		div_binding
    	];
    }

    class TopTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			title: 0,
    			desc: 1,
    			isRefresh: 2,
    			topTitleRightList: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TopTitle",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get title() {
    		throw new Error("<TopTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<TopTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get desc() {
    		throw new Error("<TopTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set desc(value) {
    		throw new Error("<TopTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isRefresh() {
    		throw new Error("<TopTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isRefresh(value) {
    		throw new Error("<TopTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topTitleRightList() {
    		throw new Error("<TopTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topTitleRightList(value) {
    		throw new Error("<TopTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    //ID
    const playListIdStore = writable("");

    //
    const playListDetailStore = writable({});

    //
    const todayListStore = writable([]);

    /* src\components\PlayListCover.svelte generated by Svelte v3.46.4 */
    const file$q = "src\\components\\PlayListCover.svelte";

    // (42:4) <Lazy height={220}>
    function create_default_slot$g(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[0].replace(/^http:/, 'https:') + '?param=600y600')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-1pe4nfx");
    			add_location(img, file$q, 42, 6, 1076);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coverImgUrl*/ 1 && !src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[0].replace(/^http:/, 'https:') + '?param=600y600')) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(42:4) <Lazy height={220}>",
    		ctx
    	});

    	return block;
    }

    // (52:2) {#if copywriter && copywriter !== null && copywriter !== ''}
    function create_if_block$d(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*copywriter*/ ctx[2]);
    			attr_dev(div, "class", "copywriter svelte-1pe4nfx");
    			add_location(div, file$q, 52, 4, 1425);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*copywriter*/ 4) set_data_dev(t, /*copywriter*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(52:2) {#if copywriter && copywriter !== null && copywriter !== ''}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div3;
    	let div0;
    	let lazy;
    	let t0;
    	let div1;
    	let span;
    	let playminiline;
    	let t1;
    	let t2_value = tranNumber(/*playCount*/ ctx[1]) + "";
    	let t2;
    	let t3;
    	let div2;
    	let t4;
    	let t5;
    	let current;
    	let mounted;
    	let dispose;

    	lazy = new Src({
    			props: {
    				height: 220,
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	playminiline = new PlayMiniLine({ $$inline: true });
    	let if_block = /*copywriter*/ ctx[2] && /*copywriter*/ ctx[2] !== null && /*copywriter*/ ctx[2] !== '' && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(lazy.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(playminiline.$$.fragment);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(/*name*/ ctx[3]);
    			t5 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "cover-img svelte-1pe4nfx");
    			add_location(div0, file$q, 40, 2, 1020);
    			set_style(span, "position", "relative");
    			set_style(span, "top", "1px");
    			add_location(span, file$q, 46, 4, 1210);
    			attr_dev(div1, "class", "play-num svelte-1pe4nfx");
    			add_location(div1, file$q, 45, 2, 1182);
    			attr_dev(div2, "class", "name svelte-1pe4nfx");
    			add_location(div2, file$q, 50, 2, 1325);
    			attr_dev(div3, "class", "cover svelte-1pe4nfx");
    			add_location(div3, file$q, 39, 0, 954);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(lazy, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div1, span);
    			mount_component(playminiline, span, null);
    			append_dev(span, t1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, t4);
    			append_dev(div3, t5);
    			if (if_block) if_block.m(div3, null);
    			/*div3_binding*/ ctx[8](div3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div3, "click", /*goToDetail*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const lazy_changes = {};

    			if (dirty & /*$$scope, coverImgUrl*/ 513) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);
    			if ((!current || dirty & /*playCount*/ 2) && t2_value !== (t2_value = tranNumber(/*playCount*/ ctx[1]) + "")) set_data_dev(t2, t2_value);
    			if (!current || dirty & /*name*/ 8) set_data_dev(t4, /*name*/ ctx[3]);

    			if (/*copywriter*/ ctx[2] && /*copywriter*/ ctx[2] !== null && /*copywriter*/ ctx[2] !== '') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy.$$.fragment, local);
    			transition_in(playminiline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy.$$.fragment, local);
    			transition_out(playminiline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(lazy);
    			destroy_component(playminiline);
    			if (if_block) if_block.d();
    			/*div3_binding*/ ctx[8](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayListCover', slots, []);
    	let { coverImgUrl = '' } = $$props;
    	let { playCount = 0 } = $$props;
    	let { copywriter = '' } = $$props;
    	let { name = '' } = $$props;
    	let { id = 0 } = $$props;
    	let { trackCount = 0 } = $$props;
    	let coverDom;

    	onMount(() => {
    		if (coverDom) {
    			ripple(coverDom);
    		}
    	});

    	function goToDetail() {
    		playListIdStore.set(id);
    		isHomePageStore.set(false);

    		if (trackCount > 1000) {
    			Confirm('  ' + trackCount + ' ', async () => {
    				push('/playlistdetail');
    			});
    		} else {
    			push('/playlistdetail');
    		}
    	}

    	const writable_props = ['coverImgUrl', 'playCount', 'copywriter', 'name', 'id', 'trackCount'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayListCover> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			coverDom = $$value;
    			$$invalidate(4, coverDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('coverImgUrl' in $$props) $$invalidate(0, coverImgUrl = $$props.coverImgUrl);
    		if ('playCount' in $$props) $$invalidate(1, playCount = $$props.playCount);
    		if ('copywriter' in $$props) $$invalidate(2, copywriter = $$props.copywriter);
    		if ('name' in $$props) $$invalidate(3, name = $$props.name);
    		if ('id' in $$props) $$invalidate(6, id = $$props.id);
    		if ('trackCount' in $$props) $$invalidate(7, trackCount = $$props.trackCount);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		push,
    		PlayMiniLine,
    		playListIdStore,
    		isHomePageStore,
    		tranNumber,
    		Confirm,
    		ripple,
    		coverImgUrl,
    		playCount,
    		copywriter,
    		name,
    		id,
    		trackCount,
    		coverDom,
    		goToDetail
    	});

    	$$self.$inject_state = $$props => {
    		if ('coverImgUrl' in $$props) $$invalidate(0, coverImgUrl = $$props.coverImgUrl);
    		if ('playCount' in $$props) $$invalidate(1, playCount = $$props.playCount);
    		if ('copywriter' in $$props) $$invalidate(2, copywriter = $$props.copywriter);
    		if ('name' in $$props) $$invalidate(3, name = $$props.name);
    		if ('id' in $$props) $$invalidate(6, id = $$props.id);
    		if ('trackCount' in $$props) $$invalidate(7, trackCount = $$props.trackCount);
    		if ('coverDom' in $$props) $$invalidate(4, coverDom = $$props.coverDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		coverImgUrl,
    		playCount,
    		copywriter,
    		name,
    		coverDom,
    		goToDetail,
    		id,
    		trackCount,
    		div3_binding
    	];
    }

    class PlayListCover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			coverImgUrl: 0,
    			playCount: 1,
    			copywriter: 2,
    			name: 3,
    			id: 6,
    			trackCount: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayListCover",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get coverImgUrl() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set coverImgUrl(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get playCount() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playCount(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get copywriter() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set copywriter(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trackCount() {
    		throw new Error("<PlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trackCount(value) {
    		throw new Error("<PlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\ListGrid.svelte generated by Svelte v3.46.4 */
    const file$p = "src\\components\\ListGrid.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (32:4) {#if isShowMore}
    function create_if_block_1$a(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let span;
    	let arrowrightsline;
    	let current;

    	arrowrightsline = new ArrowRightSLine({
    			props: {
    				size: "24",
    				style: "vertical-align: middle;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*iconText*/ ctx[5]);
    			t1 = space();
    			span = element("span");
    			create_component(arrowrightsline.$$.fragment);
    			attr_dev(span, "class", "title-icon svelte-f5vwj4");
    			add_location(span, file$p, 34, 8, 871);
    			attr_dev(div, "class", "title-right svelte-f5vwj4");
    			add_location(div, file$p, 32, 6, 816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, span);
    			mount_component(arrowrightsline, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*iconText*/ 32) set_data_dev(t0, /*iconText*/ ctx[5]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arrowrightsline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arrowrightsline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(arrowrightsline);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(32:4) {#if isShowMore}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if isShowTip}
    function create_if_block$c(ctx) {
    	let div;
    	let tip;
    	let current;

    	tip = new Tip({
    			props: { tipTextList: /*tipTextList*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tip.$$.fragment);
    			attr_dev(div, "class", "tip svelte-f5vwj4");
    			add_location(div, file$p, 41, 4, 1046);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tip, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tip_changes = {};
    			if (dirty & /*tipTextList*/ 16) tip_changes.tipTextList = /*tipTextList*/ ctx[4];
    			tip.$set(tip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(41:2) {#if isShowTip}",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#each playList as play}
    function create_each_block$8(ctx) {
    	let div;
    	let playlistcover;
    	let t;
    	let current;

    	playlistcover = new PlayListCover({
    			props: {
    				name: /*play*/ ctx[12].name,
    				coverImgUrl: /*play*/ ctx[12].coverImgUrl,
    				id: /*play*/ ctx[12].id,
    				playCount: /*play*/ ctx[12].playCount,
    				copywriter: /*play*/ ctx[12].copywriter
    				? /*play*/ ctx[12].copywriter
    				: '',
    				trackCount: /*play*/ ctx[12].trackCount
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(playlistcover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "item svelte-f5vwj4");
    			add_location(div, file$p, 48, 6, 1185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(playlistcover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const playlistcover_changes = {};
    			if (dirty & /*playList*/ 2) playlistcover_changes.name = /*play*/ ctx[12].name;
    			if (dirty & /*playList*/ 2) playlistcover_changes.coverImgUrl = /*play*/ ctx[12].coverImgUrl;
    			if (dirty & /*playList*/ 2) playlistcover_changes.id = /*play*/ ctx[12].id;
    			if (dirty & /*playList*/ 2) playlistcover_changes.playCount = /*play*/ ctx[12].playCount;

    			if (dirty & /*playList*/ 2) playlistcover_changes.copywriter = /*play*/ ctx[12].copywriter
    			? /*play*/ ctx[12].copywriter
    			: '';

    			if (dirty & /*playList*/ 2) playlistcover_changes.trackCount = /*play*/ ctx[12].trackCount;
    			playlistcover.$set(playlistcover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlistcover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlistcover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(playlistcover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(48:4) {#each playList as play}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isShowMore*/ ctx[2] && create_if_block_1$a(ctx);
    	let if_block1 = /*isShowTip*/ ctx[3] && create_if_block$c(ctx);
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	let each_value = /*playList*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (default_slot) default_slot.c();
    			t4 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "title-left svelte-f5vwj4");
    			add_location(div0, file$p, 30, 4, 749);
    			attr_dev(div1, "class", "title svelte-f5vwj4");
    			add_location(div1, file$p, 29, 2, 678);
    			attr_dev(div2, "class", "list svelte-f5vwj4");
    			add_location(div2, file$p, 46, 2, 1129);
    			attr_dev(div3, "class", "grid svelte-f5vwj4");
    			add_location(div3, file$p, 28, 0, 656);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			/*div1_binding*/ ctx[10](div1);
    			append_dev(div3, t2);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t3);

    			if (default_slot) {
    				default_slot.m(div3, null);
    			}

    			append_dev(div3, t4);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*setTitleClick*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (/*isShowMore*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isShowMore*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isShowTip*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isShowTip*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$c(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			if (dirty & /*playList*/ 2) {
    				each_value = /*playList*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			/*div1_binding*/ ctx[10](null);
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ListGrid', slots, ['default']);
    	let { title = '' } = $$props;
    	let { playList = [] } = $$props;
    	let { isShowMore = true } = $$props;
    	let { isShowTip = false } = $$props;
    	let { tipTextList = '' } = $$props;
    	let { iconText = '' } = $$props;
    	const dispatch = createEventDispatcher();

    	function setTitleClick() {
    		dispatch('titleClick');
    	}

    	let titleDom;

    	onMount(() => {
    		if (titleDom) ripple(titleDom);
    	});

    	const writable_props = ['title', 'playList', 'isShowMore', 'isShowTip', 'tipTextList', 'iconText'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ListGrid> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			titleDom = $$value;
    			$$invalidate(6, titleDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('playList' in $$props) $$invalidate(1, playList = $$props.playList);
    		if ('isShowMore' in $$props) $$invalidate(2, isShowMore = $$props.isShowMore);
    		if ('isShowTip' in $$props) $$invalidate(3, isShowTip = $$props.isShowTip);
    		if ('tipTextList' in $$props) $$invalidate(4, tipTextList = $$props.tipTextList);
    		if ('iconText' in $$props) $$invalidate(5, iconText = $$props.iconText);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		ArrowRightSLine,
    		Tip,
    		PlayListCover,
    		ripple,
    		title,
    		playList,
    		isShowMore,
    		isShowTip,
    		tipTextList,
    		iconText,
    		dispatch,
    		setTitleClick,
    		titleDom
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('playList' in $$props) $$invalidate(1, playList = $$props.playList);
    		if ('isShowMore' in $$props) $$invalidate(2, isShowMore = $$props.isShowMore);
    		if ('isShowTip' in $$props) $$invalidate(3, isShowTip = $$props.isShowTip);
    		if ('tipTextList' in $$props) $$invalidate(4, tipTextList = $$props.tipTextList);
    		if ('iconText' in $$props) $$invalidate(5, iconText = $$props.iconText);
    		if ('titleDom' in $$props) $$invalidate(6, titleDom = $$props.titleDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		playList,
    		isShowMore,
    		isShowTip,
    		tipTextList,
    		iconText,
    		titleDom,
    		setTitleClick,
    		$$scope,
    		slots,
    		div1_binding
    	];
    }

    class ListGrid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			title: 0,
    			playList: 1,
    			isShowMore: 2,
    			isShowTip: 3,
    			tipTextList: 4,
    			iconText: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ListGrid",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get title() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get playList() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playList(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isShowMore() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isShowMore(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isShowTip() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isShowTip(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tipTextList() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tipTextList(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconText() {
    		throw new Error("<ListGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconText(value) {
    		throw new Error("<ListGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Singer.svelte generated by Svelte v3.46.4 */
    const file$o = "src\\components\\Singer.svelte";

    // (28:2) {#if useLoveSongerIds.includes(songer.id)}
    function create_if_block$b(ctx) {
    	let div;
    	let starsfill;
    	let current;

    	starsfill = new StarSFill({
    			props: {
    				size: "14",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(starsfill.$$.fragment);
    			attr_dev(div, "class", "star svelte-1vbvxim");
    			add_location(div, file$o, 28, 4, 834);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(starsfill, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(starsfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(starsfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(starsfill);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(28:2) {#if useLoveSongerIds.includes(songer.id)}",
    		ctx
    	});

    	return block;
    }

    // (34:4) <Lazy height={100}>
    function create_default_slot$f(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*songer*/ ctx[0].img1v1Url.replace(/^http:/, 'https:') + '?param=' + /*coverSize*/ ctx[1] + 'y' + /*coverSize*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-1vbvxim");
    			add_location(img, file$o, 34, 6, 991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*songer, coverSize*/ 3 && !src_url_equal(img.src, img_src_value = /*songer*/ ctx[0].img1v1Url.replace(/^http:/, 'https:') + '?param=' + /*coverSize*/ ctx[1] + 'y' + /*coverSize*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(34:4) <Lazy height={100}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div2;
    	let show_if = /*useLoveSongerIds*/ ctx[3].includes(/*songer*/ ctx[0].id);
    	let t0;
    	let div0;
    	let lazy;
    	let t1;
    	let div1;
    	let t2_value = /*songer*/ ctx[0].name + "";
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = show_if && create_if_block$b(ctx);

    	lazy = new Src({
    			props: {
    				height: 100,
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			create_component(lazy.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			attr_dev(div0, "class", "cover svelte-1vbvxim");
    			add_location(div0, file$o, 32, 2, 939);
    			attr_dev(div1, "class", "name svelte-1vbvxim");
    			add_location(div1, file$o, 37, 2, 1125);
    			attr_dev(div2, "class", "singer svelte-1vbvxim");
    			add_location(div2, file$o, 26, 0, 713);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			mount_component(lazy, div0, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			/*div2_binding*/ ctx[5](div2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", /*toSongerPageFun*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*songer*/ 1) show_if = /*useLoveSongerIds*/ ctx[3].includes(/*songer*/ ctx[0].id);

    			if (show_if) {
    				if (if_block) {
    					if (dirty & /*songer*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const lazy_changes = {};

    			if (dirty & /*$$scope, songer, coverSize*/ 67) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);
    			if ((!current || dirty & /*songer*/ 1) && t2_value !== (t2_value = /*songer*/ ctx[0].name + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(lazy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(lazy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			destroy_component(lazy);
    			/*div2_binding*/ ctx[5](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Singer', slots, []);
    	let { songer = {} } = $$props;
    	let { coverSize = 200 } = $$props;
    	let useLoveSongerIds = JSON.parse(localStorage.getItem('useLoveSongerIds')) || [];
    	let songerDom;

    	onMount(() => {
    		if (songerDom) {
    			ripple(songerDom);
    		}
    	});

    	function toSongerPageFun() {
    		isHomePageStore.set(false);
    		currentDetailSongerIdStore.set(songer.id);
    		push('/songerDetail');
    	}

    	const writable_props = ['songer', 'coverSize'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Singer> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			songerDom = $$value;
    			$$invalidate(2, songerDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('songer' in $$props) $$invalidate(0, songer = $$props.songer);
    		if ('coverSize' in $$props) $$invalidate(1, coverSize = $$props.coverSize);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		push,
    		StarSFill,
    		isHomePageStore,
    		currentDetailSongerIdStore,
    		ripple,
    		songer,
    		coverSize,
    		useLoveSongerIds,
    		songerDom,
    		toSongerPageFun
    	});

    	$$self.$inject_state = $$props => {
    		if ('songer' in $$props) $$invalidate(0, songer = $$props.songer);
    		if ('coverSize' in $$props) $$invalidate(1, coverSize = $$props.coverSize);
    		if ('useLoveSongerIds' in $$props) $$invalidate(3, useLoveSongerIds = $$props.useLoveSongerIds);
    		if ('songerDom' in $$props) $$invalidate(2, songerDom = $$props.songerDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [songer, coverSize, songerDom, useLoveSongerIds, toSongerPageFun, div2_binding];
    }

    class Singer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { songer: 0, coverSize: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Singer",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get songer() {
    		throw new Error("<Singer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set songer(value) {
    		throw new Error("<Singer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get coverSize() {
    		throw new Error("<Singer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set coverSize(value) {
    		throw new Error("<Singer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // import { mapTrackPlayableStatus } from '@/utils/common';

    /**
     *  :  ,  id, 
     * @param {number} id
     * @returns
     */
    function getSimiPlaylist(id) {
      return service({
        url: '/simi/playlist',
        method: 'get',
        params: { id },
      });
    }

    /**
     * /
     *  :  , /  : id :  id
     * pid :  id
     *  : sid :  id
     *  : /playmode/intelligence/list
     *  : /playmode/intelligence/list?id=33894312&pid=24381616 , /playmode/intelligence/list?id=33894312&pid=24381616&sid=36871368
     * @param {object} params
     * @param {number=} params.id
     * @param {number=} params.pid
     * @param {number=} params.sid
     * @returns
     */
    function intelligenceList(params) {
      return service({
        url: '/playmode/intelligence/list',
        method: 'get',
        params,
      });
    }

    /**
     * 
     *  :  ,  (  )
     * @param {Object} params
     * @param {number=} params.limit
     */
    function dailyRecommendPlaylist(params) {
      return service({
        url: '/recommend/resource',
        method: 'get',
        params,
      });
    }
    /**
     * 
     *  : ,  ,  ,  id, (,)
     * trackIdstracks  trackIds  song/detail 
     *  (https://github.com/Binaryify/NeteaseCloudMusicApi/issues/452)
     * - id :  id
     * - s :  s , 8
     * @param {number} id
     * @param {boolean=} noCache
     */
    function getPlaylistDetail(id, noCache = false) {
      let params = { id };
      if (noCache) params.timestamp = new Date().getTime();
      return service({
        url: '/playlist/detail',
        method: 'get',
        params,
      });
    }

    /**
     * 
     * 
     :  , 

     : /playlist/highquality/tags

     : /playlist/highquality/tags} params 
     * @returns 
     */

    function highQualityCat(params) {
      return service({
        url: '/playlist/highquality/tags',
        method: 'get',
        params,
      });
    }

    /**
     * 
     *  :  , 
     * - cat: tag,  "  ""  " "  ""  ",  "", (/playlist/highquality/tags)
     * - limit:  ,  20
     * - before: , updateTime 
     * @param {Object} params
     * @param {string} params.cat
     * @param {number=} params.limit
     * @param {number} params.before
     */
    function highQualityPlaylist(params) {
      return service({
        url: '/top/playlist/highquality',
        method: 'get',
        params,
      });
    }

    /**
     *  (  )
     *  :  , 
     * - order:  'new'  'hot',  ,  'hot'
     * - cat: tag,  "  ""  " "  ""  ",  "",(/playlist/catlist)
     * - limit:  ,  50
     * - offset:  ,  ,  :(  -1)*50,  50  limit 
     * @param {Object} params
     * @param {string} params.order
     * @param {string} params.cat
     * @param {number} params.limit
     * @param {number} params.offset
     */
    function topPlaylist(params) {
      return service({
        url: '/top/playlist',
        method: 'get',
        params,
      });
    }

    /**
     * 
     *  : ,, category 
     */
    function playlistCatlist() {
      return service({
        url: '/playlist/catlist',
        method: 'get',
      });
    }
    /**
     * 
     *  : ,, category 
     */
    function playlistHotCatlist() {
      return service({
        url: '/playlist/hot',
        method: 'get',
      });
    }

    /**
     * 
     *  : ,  : /toplist
     */
    function toplists() {
      return service({
        url: '/toplist',
        method: 'get',
      });
    }

    /**
     * /
     *  : ,  id 
     * - t : ,1:,2:
     * - id :  id
     * @param {Object} params
     * @param {number} params.t
     * @param {number} params.id
     */
    function subscribePlaylist(params) {
      params.timestamp = new Date().getTime();
      return service({
        url: '/playlist/subscribe',
        method: 'post',
        params,
        // needCookie: false,
      });
    }

    /**
     * 
     *  :  ,  (  )
     * @param {Object} params
     * @param {string} params.op
     * @param {string} params.pid
     */
    function dailyRecommendTracks() {
      return service({
        url: '/recommend/songs',
        method: 'get',
        params: { timestamp: new Date().getTime() },
      }).then(result => {
        // result.data.dailySongs = mapTrackPlayableStatus(
        //   result.data.dailySongs,
        //   result.data.privileges
        // );
        return result;
      });
    }

    /**
     * 
     *  :  ,  id, 
     *  : id:  id
     *  : /artist/detail
     *  : /artist/detail?id=11972054 (Billie Eilish)
     */
    function getSongerDetail(id) {
      return service({
        url: '/artist/detail',
        method: 'get',
        params: {
          id,
        },
      });
    }
    /**
     * 
     *  :  ,  id, 
     *  : id:  id
     *  : /artist/desc
     *  : /artist/desc?id=6452 (  )
     */
    function getSongerDesc(id) {
      return service({
        url: '/artist/desc',
        method: 'get',
        params: {
          id,
        },
      });
    }
    /**
     * 50
     *  : ,50
     *  : id:  id
     *  : /artist/top/song
     *  : /artist/top/song?id=6452 (  )
     */
    function getSongerTop(id) {
      return service({
        url: '/artist/top/song',
        method: 'get',
        params: {
          id,
        },
      });
    }

    /**
     * 
     *  :  ,  id, 
     * - id:  id
     * - t: ,1 ,
     * @param {Object} params
     * @param {number} params.id
     * @param {number} params.t
     */
    function followAArtist(params) {
      return service({
        url: '/artist/sub',
        method: 'get',
        params,
      });
    }

    /**
     * 
     *  :  ,  id, 
     * - id:  id
     * @param {number} id
     */
    function similarArtists(id) {
      return service({
        url: '/simi/artist',
        method: 'get',
        params: { id },
      });
    }

    /**
     * 
     *  :  , 
     * -  : limit:  ,  50
     * offset:  ,  ,  :(  -1)*50,  50  limit  ,   0
     *  : /top/artists
     *  : /top/artists?offset=0&limit=30
     */
    function topArtists(limit, offset) {
      return service({
        url: '/top/artists',
        method: 'get',
        params: { limit, offset },
      });
    }

    /**
     * 
     : ,  :
    id :  id
     :
    order : hot ,time 
    limit:  ,  50
    offset:  ,  ,  :(  -1)*50,  50  limit 
     : /artist/songs
     : /artist/songs?id=6452
     */
    function getAllSongs(id, order, limit, offset) {
      return service({
        url: '/artist/songs',
        method: 'get',
        params: { id, order, limit, offset },
      });
    }

    /* src\pages\Love.svelte generated by Svelte v3.46.4 */
    const file$n = "src\\pages\\Love.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    // (388:2) {:else}
    function create_else_block$5(ctx) {
    	let div5;
    	let toptitle;
    	let t0;
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let button0;
    	let t4;
    	let div3;
    	let button1;
    	let current;

    	toptitle = new TopTitle({
    			props: {
    				title: "",
    				desc: "",
    				topTitleRightList: { type: 'text', text: '' }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("BtnClick", /*BtnClick_handler*/ ctx[22]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("BtnClick", /*BtnClick_handler_1*/ ctx[23]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			create_component(toptitle.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "";
    			t3 = space();
    			div2 = element("div");
    			create_component(button0.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			create_component(button1.$$.fragment);
    			attr_dev(img, "class", "login-img svelte-1ff7bb3");
    			if (!src_url_equal(img.src, img_src_value = "/images/login.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$n, 392, 10, 14113);
    			add_location(div0, file$n, 391, 8, 14096);
    			attr_dev(div1, "class", "tip svelte-1ff7bb3");
    			add_location(div1, file$n, 394, 8, 14195);
    			attr_dev(div2, "class", "login-btn");
    			add_location(div2, file$n, 395, 8, 14236);
    			set_style(div3, "margin-top", "40px");
    			add_location(div3, file$n, 406, 8, 14508);
    			attr_dev(div4, "class", "noLogin svelte-1ff7bb3");
    			add_location(div4, file$n, 390, 6, 14065);
    			add_location(div5, file$n, 388, 4, 13962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			mount_component(toptitle, div5, null);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t1);
    			append_dev(div4, div1);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			mount_component(button0, div2, null);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			mount_component(button1, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 256) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 256) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toptitle.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toptitle.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(toptitle);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(388:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (265:2) {#if $isLoginStore}
    function create_if_block$a(ctx) {
    	let div17;
    	let toptitle;
    	let t0;
    	let div16;
    	let div7;
    	let div0;
    	let t1;
    	let div6;
    	let div1;
    	let t3;
    	let div5;
    	let div2;

    	let t4_value = (/*$todayListStore*/ ctx[14].length !== 0
    	? /*$todayListStore*/ ctx[14][0].name
    	: '') + "";

    	let t4;
    	let t5;
    	let div3;

    	let t6_value = (/*$todayListStore*/ ctx[14].length !== 0
    	? songerListToStr(/*$todayListStore*/ ctx[14][0].ar)
    	: '') + "";

    	let t6;
    	let t7;
    	let div4;
    	let span0;
    	let calendar2fill;
    	let t8;
    	let t9_value = `${new Date().getMonth() + 1}${new Date().getDate()}` + "";
    	let t9;
    	let t10;
    	let div14;
    	let div13;
    	let div8;
    	let img;
    	let img_src_value;
    	let t11;
    	let div12;
    	let t12;
    	let div9;

    	let t13_value = (/*$FMPlayStore*/ ctx[11].name
    	? /*$FMPlayStore*/ ctx[11].name
    	: '') + "";

    	let t13;
    	let t14;
    	let span1;

    	let t15_value = (/*$FMPlayStore*/ ctx[11].alia && /*$FMPlayStore*/ ctx[11].alia.length > 0
    	? `(${/*$FMPlayStore*/ ctx[11].alia[0]})`
    	: '') + "";

    	let t15;
    	let t16;
    	let div10;

    	let t17_value = (/*$FMPlayStore*/ ctx[11].artists
    	? songerListToStr(/*$FMPlayStore*/ ctx[11].artists)
    	: '') + "";

    	let t17;
    	let t18;
    	let t19;
    	let div11;
    	let span2;
    	let radiofill;
    	let t20;
    	let t21;
    	let div15;
    	let listgrid;
    	let t22;
    	let t23;
    	let t24;
    	let current;
    	let mounted;
    	let dispose;

    	toptitle = new TopTitle({
    			props: {
    				title: "",
    				desc: "",
    				topTitleRightList: /*topTitleRightList*/ ctx[16],
    				isRefresh: /*isRefresh*/ ctx[9]
    			},
    			$$inline: true
    		});

    	toptitle.$on("IconClick", /*topClickFun*/ ctx[19]);
    	calendar2fill = new Calendar2Fill({ props: { size: "14" }, $$inline: true });
    	let if_block0 = /*$isFMPlayStore*/ ctx[10] && /*$playStatusStore*/ ctx[15] && /*$currentSongStore*/ ctx[12].id === /*$FMPlayStore*/ ctx[11].id && create_if_block_5$3(ctx);
    	let if_block1 = /*$FMPlayStore*/ ctx[11].al && create_if_block_4$3(ctx);
    	radiofill = new RadioFill({ props: { size: "14" }, $$inline: true });

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				isShowMore: false,
    				playList: /*dailyRecommendPlayList*/ ctx[0]
    			},
    			$$inline: true
    		});

    	let if_block2 = /*similarSongs*/ ctx[4].length > 0 && create_if_block_3$5(ctx);
    	let if_block3 = /*similarPlayList*/ ctx[2].length > 0 && create_if_block_2$5(ctx);
    	let if_block4 = /*simiSongers*/ ctx[8].length > 0 && /*simiSonger*/ ctx[7].name && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			div17 = element("div");
    			create_component(toptitle.$$.fragment);
    			t0 = space();
    			div16 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			t1 = space();
    			div6 = element("div");
    			div1 = element("div");
    			div1.textContent = "";
    			t3 = space();
    			div5 = element("div");
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			span0 = element("span");
    			create_component(calendar2fill.$$.fragment);
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div8 = element("div");
    			img = element("img");
    			t11 = space();
    			div12 = element("div");
    			if (if_block0) if_block0.c();
    			t12 = space();
    			div9 = element("div");
    			t13 = text(t13_value);
    			t14 = space();
    			span1 = element("span");
    			t15 = text(t15_value);
    			t16 = space();
    			div10 = element("div");
    			t17 = text(t17_value);
    			t18 = space();
    			if (if_block1) if_block1.c();
    			t19 = space();
    			div11 = element("div");
    			span2 = element("span");
    			create_component(radiofill.$$.fragment);
    			t20 = text("\r\n                 FM");
    			t21 = space();
    			div15 = element("div");
    			create_component(listgrid.$$.fragment);
    			t22 = space();
    			if (if_block2) if_block2.c();
    			t23 = space();
    			if (if_block3) if_block3.c();
    			t24 = space();
    			if (if_block4) if_block4.c();
    			attr_dev(div0, "class", "today-img-box svelte-1ff7bb3");
    			set_style(div0, "width", localStorage.getItem('fullWidth') - 40 + "px");

    			set_style(div0, "background-image", "url(" + (/*$todayListStore*/ ctx[14].length !== 0
    			? /*$todayListStore*/ ctx[14][0].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800'
    			: '/images/defaultCover.png') + ")");

    			add_location(div0, file$n, 269, 10, 9119);
    			attr_dev(div1, "class", "day svelte-1ff7bb3");
    			add_location(div1, file$n, 276, 12, 9480);
    			attr_dev(div2, "class", "name svelte-1ff7bb3");
    			add_location(div2, file$n, 278, 14, 9560);
    			attr_dev(div3, "class", "songer");
    			add_location(div3, file$n, 281, 14, 9695);
    			set_style(span0, "position", "relative");
    			set_style(span0, "top", "2px ");
    			add_location(span0, file$n, 285, 16, 9887);
    			attr_dev(div4, "class", "calendar svelte-1ff7bb3");
    			add_location(div4, file$n, 284, 14, 9847);
    			attr_dev(div5, "class", "name-list svelte-1ff7bb3");
    			add_location(div5, file$n, 277, 12, 9521);
    			attr_dev(div6, "class", "day-box svelte-1ff7bb3");
    			add_location(div6, file$n, 275, 10, 9445);
    			attr_dev(div7, "class", "today svelte-1ff7bb3");
    			add_location(div7, file$n, 268, 8, 9043);
    			attr_dev(img, "class", "fm-cover-img svelte-1ff7bb3");

    			if (!src_url_equal(img.src, img_src_value = /*$FMPlayStore*/ ctx[11].album
    			? /*$FMPlayStore*/ ctx[11].album.blurPicUrl.replace(/^http:/, 'https:') + '?param=240y240'
    			: '')) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", "");
    			add_location(img, file$n, 302, 14, 10489);
    			attr_dev(div8, "class", "fm-cover svelte-1ff7bb3");
    			add_location(div8, file$n, 301, 12, 10451);
    			attr_dev(span1, "class", "alia svelte-1ff7bb3");
    			add_location(span1, file$n, 327, 16, 11661);
    			attr_dev(div9, "class", "fm-name svelte-1ff7bb3");
    			add_location(div9, file$n, 325, 14, 11560);
    			attr_dev(div10, "class", "fm-songer svelte-1ff7bb3");
    			add_location(div10, file$n, 331, 14, 11849);
    			set_style(span2, "position", "relative");
    			set_style(span2, "top", "2px ");
    			add_location(span2, file$n, 349, 16, 12655);
    			attr_dev(div11, "class", "fm-icon svelte-1ff7bb3");
    			add_location(div11, file$n, 348, 14, 12616);
    			attr_dev(div12, "class", "fm-info svelte-1ff7bb3");
    			add_location(div12, file$n, 310, 12, 10771);
    			attr_dev(div13, "class", "fm svelte-1ff7bb3");
    			add_location(div13, file$n, 300, 10, 10421);
    			attr_dev(div14, "class", "fm-box svelte-1ff7bb3");

    			set_style(div14, "background", "url(" + (/*$FMPlayStore*/ ctx[11].album
    			? /*$FMPlayStore*/ ctx[11].album.blurPicUrl.replace(/^http:/, 'https:') + '?param=80y80'
    			: '') + ")");

    			add_location(div14, file$n, 292, 8, 10143);
    			attr_dev(div15, "class", "list-grid svelte-1ff7bb3");
    			add_location(div15, file$n, 357, 8, 12873);
    			attr_dev(div16, "class", "login svelte-1ff7bb3");
    			add_location(div16, file$n, 267, 6, 9014);
    			attr_dev(div17, "class", "login-box svelte-1ff7bb3");
    			add_location(div17, file$n, 265, 4, 8881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div17, anchor);
    			mount_component(toptitle, div17, null);
    			append_dev(div17, t0);
    			append_dev(div17, div16);
    			append_dev(div16, div7);
    			append_dev(div7, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div1);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div2);
    			append_dev(div2, t4);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div3, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, span0);
    			mount_component(calendar2fill, span0, null);
    			append_dev(span0, t8);
    			append_dev(div4, t9);
    			/*div7_binding*/ ctx[20](div7);
    			append_dev(div16, t10);
    			append_dev(div16, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div8);
    			append_dev(div8, img);
    			append_dev(div13, t11);
    			append_dev(div13, div12);
    			if (if_block0) if_block0.m(div12, null);
    			append_dev(div12, t12);
    			append_dev(div12, div9);
    			append_dev(div9, t13);
    			append_dev(div9, t14);
    			append_dev(div9, span1);
    			append_dev(span1, t15);
    			append_dev(div12, t16);
    			append_dev(div12, div10);
    			append_dev(div10, t17);
    			append_dev(div10, t18);
    			if (if_block1) if_block1.m(div10, null);
    			append_dev(div12, t19);
    			append_dev(div12, div11);
    			append_dev(div11, span2);
    			mount_component(radiofill, span2, null);
    			append_dev(div11, t20);
    			/*div14_binding*/ ctx[21](div14);
    			append_dev(div16, t21);
    			append_dev(div16, div15);
    			mount_component(listgrid, div15, null);
    			append_dev(div16, t22);
    			if (if_block2) if_block2.m(div16, null);
    			append_dev(div16, t23);
    			if (if_block3) if_block3.m(div16, null);
    			append_dev(div16, t24);
    			if (if_block4) if_block4.m(div16, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div7, "click", /*playTodayFun*/ ctx[17], false, false, false),
    					listen_dev(div14, "click", /*playFMFun*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const toptitle_changes = {};
    			if (dirty[0] & /*isRefresh*/ 512) toptitle_changes.isRefresh = /*isRefresh*/ ctx[9];
    			toptitle.$set(toptitle_changes);

    			if (!current || dirty[0] & /*$todayListStore*/ 16384) {
    				set_style(div0, "background-image", "url(" + (/*$todayListStore*/ ctx[14].length !== 0
    				? /*$todayListStore*/ ctx[14][0].al.picUrl.replace(/^http:/, 'https:') + '?param=800y800'
    				: '/images/defaultCover.png') + ")");
    			}

    			if ((!current || dirty[0] & /*$todayListStore*/ 16384) && t4_value !== (t4_value = (/*$todayListStore*/ ctx[14].length !== 0
    			? /*$todayListStore*/ ctx[14][0].name
    			: '') + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty[0] & /*$todayListStore*/ 16384) && t6_value !== (t6_value = (/*$todayListStore*/ ctx[14].length !== 0
    			? songerListToStr(/*$todayListStore*/ ctx[14][0].ar)
    			: '') + "")) set_data_dev(t6, t6_value);

    			if (!current || dirty[0] & /*$FMPlayStore*/ 2048 && !src_url_equal(img.src, img_src_value = /*$FMPlayStore*/ ctx[11].album
    			? /*$FMPlayStore*/ ctx[11].album.blurPicUrl.replace(/^http:/, 'https:') + '?param=240y240'
    			: '')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (/*$isFMPlayStore*/ ctx[10] && /*$playStatusStore*/ ctx[15] && /*$currentSongStore*/ ctx[12].id === /*$FMPlayStore*/ ctx[11].id) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_5$3(ctx);
    					if_block0.c();
    					if_block0.m(div12, t12);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty[0] & /*$FMPlayStore*/ 2048) && t13_value !== (t13_value = (/*$FMPlayStore*/ ctx[11].name
    			? /*$FMPlayStore*/ ctx[11].name
    			: '') + "")) set_data_dev(t13, t13_value);

    			if ((!current || dirty[0] & /*$FMPlayStore*/ 2048) && t15_value !== (t15_value = (/*$FMPlayStore*/ ctx[11].alia && /*$FMPlayStore*/ ctx[11].alia.length > 0
    			? `(${/*$FMPlayStore*/ ctx[11].alia[0]})`
    			: '') + "")) set_data_dev(t15, t15_value);

    			if ((!current || dirty[0] & /*$FMPlayStore*/ 2048) && t17_value !== (t17_value = (/*$FMPlayStore*/ ctx[11].artists
    			? songerListToStr(/*$FMPlayStore*/ ctx[11].artists)
    			: '') + "")) set_data_dev(t17, t17_value);

    			if (/*$FMPlayStore*/ ctx[11].al) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$3(ctx);
    					if_block1.c();
    					if_block1.m(div10, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty[0] & /*$FMPlayStore*/ 2048) {
    				set_style(div14, "background", "url(" + (/*$FMPlayStore*/ ctx[11].album
    				? /*$FMPlayStore*/ ctx[11].album.blurPicUrl.replace(/^http:/, 'https:') + '?param=80y80'
    				: '') + ")");
    			}

    			const listgrid_changes = {};
    			if (dirty[0] & /*dailyRecommendPlayList*/ 1) listgrid_changes.playList = /*dailyRecommendPlayList*/ ctx[0];
    			listgrid.$set(listgrid_changes);

    			if (/*similarSongs*/ ctx[4].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*similarSongs*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div16, t23);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*similarPlayList*/ ctx[2].length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*similarPlayList*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div16, t24);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*simiSongers*/ ctx[8].length > 0 && /*simiSonger*/ ctx[7].name) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*simiSongers, simiSonger*/ 384) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div16, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toptitle.$$.fragment, local);
    			transition_in(calendar2fill.$$.fragment, local);
    			transition_in(radiofill.$$.fragment, local);
    			transition_in(listgrid.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toptitle.$$.fragment, local);
    			transition_out(calendar2fill.$$.fragment, local);
    			transition_out(radiofill.$$.fragment, local);
    			transition_out(listgrid.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div17);
    			destroy_component(toptitle);
    			destroy_component(calendar2fill);
    			/*div7_binding*/ ctx[20](null);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(radiofill);
    			/*div14_binding*/ ctx[21](null);
    			destroy_component(listgrid);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(265:2) {#if $isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (397:10) <Button              type="primary"              on:BtnClick={() => {                isHomePageStore.set(false);                push('/login');              }}            >
    function create_default_slot_1$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(397:10) <Button              type=\\\"primary\\\"              on:BtnClick={() => {                isHomePageStore.set(false);                push('/login');              }}            >",
    		ctx
    	});

    	return block;
    }

    // (408:10) <Button              on:BtnClick={() => {                isHomePageStore.set(false);                push('/about');              }}            >
    function create_default_slot$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(408:10) <Button              on:BtnClick={() => {                isHomePageStore.set(false);                push('/about');              }}            >",
    		ctx
    	});

    	return block;
    }

    // (312:14) {#if $isFMPlayStore && $playStatusStore && $currentSongStore.id === $FMPlayStore.id}
    function create_if_block_5$3(ctx) {
    	let div10;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;
    	let t3;
    	let div4;
    	let t4;
    	let div5;
    	let t5;
    	let div6;
    	let t6;
    	let div7;
    	let t7;
    	let div8;
    	let t8;
    	let div9;

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			t3 = space();
    			div4 = element("div");
    			t4 = space();
    			div5 = element("div");
    			t5 = space();
    			div6 = element("div");
    			t6 = space();
    			div7 = element("div");
    			t7 = space();
    			div8 = element("div");
    			t8 = space();
    			div9 = element("div");
    			attr_dev(div0, "class", "pull_down pull_down1 svelte-1ff7bb3");
    			add_location(div0, file$n, 313, 18, 10958);
    			attr_dev(div1, "class", "pull_down pull_down2 svelte-1ff7bb3");
    			add_location(div1, file$n, 314, 18, 11014);
    			attr_dev(div2, "class", "pull_down pull_down3 svelte-1ff7bb3");
    			add_location(div2, file$n, 315, 18, 11070);
    			attr_dev(div3, "class", "pull_down pull_down4 svelte-1ff7bb3");
    			add_location(div3, file$n, 316, 18, 11126);
    			attr_dev(div4, "class", "pull_down pull_down5 svelte-1ff7bb3");
    			add_location(div4, file$n, 317, 18, 11182);
    			attr_dev(div5, "class", "pull_down pull_down6 svelte-1ff7bb3");
    			add_location(div5, file$n, 318, 18, 11238);
    			attr_dev(div6, "class", "pull_down pull_down7 svelte-1ff7bb3");
    			add_location(div6, file$n, 319, 18, 11294);
    			attr_dev(div7, "class", "pull_down pull_down8 svelte-1ff7bb3");
    			add_location(div7, file$n, 320, 18, 11350);
    			attr_dev(div8, "class", "pull_down pull_down9 svelte-1ff7bb3");
    			add_location(div8, file$n, 321, 18, 11406);
    			attr_dev(div9, "class", "pull_down pull_down10 svelte-1ff7bb3");
    			add_location(div9, file$n, 322, 18, 11462);
    			attr_dev(div10, "class", "fm-play-motion svelte-1ff7bb3");
    			add_location(div10, file$n, 312, 16, 10910);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);
    			append_dev(div10, t0);
    			append_dev(div10, div1);
    			append_dev(div10, t1);
    			append_dev(div10, div2);
    			append_dev(div10, t2);
    			append_dev(div10, div3);
    			append_dev(div10, t3);
    			append_dev(div10, div4);
    			append_dev(div10, t4);
    			append_dev(div10, div5);
    			append_dev(div10, t5);
    			append_dev(div10, div6);
    			append_dev(div10, t6);
    			append_dev(div10, div7);
    			append_dev(div10, t7);
    			append_dev(div10, div8);
    			append_dev(div10, t8);
    			append_dev(div10, div9);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(312:14) {#if $isFMPlayStore && $playStatusStore && $currentSongStore.id === $FMPlayStore.id}",
    		ctx
    	});

    	return block;
    }

    // (334:16) {#if $FMPlayStore.al}
    function create_if_block_4$3(ctx) {
    	let span;

    	let t_value = (/*$FMPlayStore*/ ctx[11].al.name === ''
    	? ''
    	: `- ${/*$FMPlayStore*/ ctx[11].al.name}`) + "";

    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$n, 334, 18, 12016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$FMPlayStore*/ 2048 && t_value !== (t_value = (/*$FMPlayStore*/ ctx[11].al.name === ''
    			? ''
    			: `- ${/*$FMPlayStore*/ ctx[11].al.name}`) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(334:16) {#if $FMPlayStore.al}",
    		ctx
    	});

    	return block;
    }

    // (361:8) {#if similarSongs.length > 0}
    function create_if_block_3$5(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let t3_value = /*randomTenLoveSong*/ ctx[3].name + "";
    	let t3;
    	let t4;
    	let t5;
    	let songlist;
    	let current;

    	songlist = new SongList({
    			props: { songList: /*similarSongs*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "";
    			t1 = space();
    			div1 = element("div");
    			t2 = text("");
    			t3 = text(t3_value);
    			t4 = text("");
    			t5 = space();
    			create_component(songlist.$$.fragment);
    			attr_dev(div0, "class", "simiTitle svelte-1ff7bb3");
    			add_location(div0, file$n, 361, 10, 13055);
    			attr_dev(div1, "class", "desc svelte-1ff7bb3");
    			add_location(div1, file$n, 362, 10, 13102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			insert_dev(target, t5, anchor);
    			mount_component(songlist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*randomTenLoveSong*/ 8) && t3_value !== (t3_value = /*randomTenLoveSong*/ ctx[3].name + "")) set_data_dev(t3, t3_value);
    			const songlist_changes = {};
    			if (dirty[0] & /*similarSongs*/ 16) songlist_changes.songList = /*similarSongs*/ ctx[4];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			destroy_component(songlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(361:8) {#if similarSongs.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (366:8) {#if similarPlayList.length > 0}
    function create_if_block_2$5(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				isShowMore: false,
    				isShowTip: true,
    				tipTextList: [`${/*randomLoveSong*/ ctx[1].name}`],
    				playList: /*similarPlayList*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-1ff7bb3");
    			add_location(div, file$n, 366, 10, 13275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};
    			if (dirty[0] & /*randomLoveSong*/ 2) listgrid_changes.tipTextList = [`${/*randomLoveSong*/ ctx[1].name}`];
    			if (dirty[0] & /*similarPlayList*/ 4) listgrid_changes.playList = /*similarPlayList*/ ctx[2];
    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(366:8) {#if similarPlayList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (377:8) {#if simiSongers.length > 0 && simiSonger.name}
    function create_if_block_1$9(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let t3_value = /*simiSonger*/ ctx[7].name + "";
    	let t3;
    	let t4;
    	let t5;
    	let div2;
    	let current;
    	let each_value = /*simiSongers*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "";
    			t1 = space();
    			div1 = element("div");
    			t2 = text("");
    			t3 = text(t3_value);
    			t4 = text("");
    			t5 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "simiTitle svelte-1ff7bb3");
    			add_location(div0, file$n, 377, 10, 13641);
    			attr_dev(div1, "class", "desc svelte-1ff7bb3");
    			add_location(div1, file$n, 378, 10, 13688);
    			attr_dev(div2, "class", "songer-box svelte-1ff7bb3");
    			add_location(div2, file$n, 379, 10, 13747);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*simiSonger*/ 128) && t3_value !== (t3_value = /*simiSonger*/ ctx[7].name + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*simiSongers*/ 256) {
    				each_value = /*simiSongers*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(377:8) {#if simiSongers.length > 0 && simiSonger.name}",
    		ctx
    	});

    	return block;
    }

    // (381:12) {#each simiSongers as songer}
    function create_each_block$7(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[36],
    				coverSize: 330
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty[0] & /*simiSongers*/ 256) songer_changes.songer = /*songer*/ ctx[36];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(381:12) {#each simiSongers as songer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$isLoginStore*/ ctx[13]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "love svelte-1ff7bb3");
    			add_location(div, file$n, 263, 0, 8834);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function distinct(A, B) {
    	let aSet = new Set(A);
    	let bSet = new Set(B);

    	//
    	// let differenceSet = new Set([...aSet].filter(x => !bSet.has(x)));
    	// return Array.from(differenceSet);
    	// ;
    	let intersection = new Set([...aSet].filter(x => bSet.has(x)));

    	return Array.from(intersection);
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let isRefresh;
    	let simiSonger;
    	let simiSongers;
    	let $isFMPlayStore;
    	let $userLikeListIdStore;
    	let $FMPlayStore;
    	let $currentSongStore;
    	let $isLoginStore;
    	let $todayListStore;
    	let $playStatusStore;
    	validate_store(isFMPlayStore, 'isFMPlayStore');
    	component_subscribe($$self, isFMPlayStore, $$value => $$invalidate(10, $isFMPlayStore = $$value));
    	validate_store(userLikeListIdStore, 'userLikeListIdStore');
    	component_subscribe($$self, userLikeListIdStore, $$value => $$invalidate(24, $userLikeListIdStore = $$value));
    	validate_store(FMPlayStore, 'FMPlayStore');
    	component_subscribe($$self, FMPlayStore, $$value => $$invalidate(11, $FMPlayStore = $$value));
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(12, $currentSongStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(13, $isLoginStore = $$value));
    	validate_store(todayListStore, 'todayListStore');
    	component_subscribe($$self, todayListStore, $$value => $$invalidate(14, $todayListStore = $$value));
    	validate_store(playStatusStore, 'playStatusStore');
    	component_subscribe($$self, playStatusStore, $$value => $$invalidate(15, $playStatusStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Love', slots, []);
    	let dailyRecommendPlayList = []; //
    	let randomLoveSong = {}; //
    	let similarPlayList = []; //
    	let randomTenLoveSong = {}; //
    	let similarSongs = []; //
    	let topTitleRightList = { type: 'icon', path: RefreshLine };
    	let FMDom;
    	let todayDom;

    	onMount(() => {
    		if (FMDom) {
    			ripple(FMDom);
    		}

    		if (todayDom) {
    			ripple(todayDom);
    		}

    		allOnMount();
    	});

    	function allOnMount() {
    		if ($isLoginStore) {
    			dailyRecommendPlaylistFun();
    			dailyRecommendTracksFun();
    			personalFMFun(true);
    			let useLoveSongIds = JSON.parse(localStorage.getItem('useLoveSongIds'));
    			let randomIndex = Math.floor(Math.random() * useLoveSongIds.length);
    			getSongDetailFun(useLoveSongIds[randomIndex]);
    			getSimiPlaylistFun(useLoveSongIds[randomIndex]);
    			getPlaylistDetailFun();

    			//
    			const useLoveSongerIds = JSON.parse(localStorage.getItem('useLoveSongerIds')) || [];

    			let index = Math.floor(Math.random() * useLoveSongerIds.length);

    			if (index) {
    				getSongerDetailFun(useLoveSongerIds[index]);
    				similarArtistsFun(useLoveSongerIds[index], useLoveSongerIds);
    			}
    		}
    	}

    	//
    	function playTodayFun() {
    		isHomePageStore.set(false);
    		push('/todayListDetail');
    	}

    	//FM
    	function playFMFun() {
    		if ($FMPlayStore.id === $currentSongStore.id) {
    			window.audioDOM.play();
    			playStatusStore.set(true);
    			if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    			playIsMaxStore.set(true);
    			maxPlayToTopStore.set('0px');
    		} else {
    			isFMPlayStore.set(true);
    			localStorage.setItem('isFMPlay', '1');
    			getSongUrlFun($FMPlayStore);
    		}
    	}

    	//FM
    	async function personalFMFun(first) {
    		//first FM
    		const res = await personalFM();

    		if (res.code === 200) {
    			res.data[0].al = res.data[0].album;
    			res.data[0].ar = res.data[0].artists;
    			res.data[0].alia = res.data[0].alias;
    			res.data[1].al = res.data[1].album;
    			res.data[1].ar = res.data[1].artists;
    			res.data[1].alia = res.data[1].alias;

    			if (first) {
    				FMPlayStore.set(res.data[0]);
    				FMPlayNextStore.set(res.data[1]);
    				localStorage.setItem('FMPlay', JSON.stringify($FMPlayStore));
    			} else {
    				FMPlayStore.set(res.data[0]);
    			}
    		}
    	}

    	//
    	async function dailyRecommendTracksFun() {
    		const res = await dailyRecommendTracks();

    		if (res.code === 200) {
    			todayListStore.set(res.data.dailySongs);
    		}
    	}

    	//
    	async function dailyRecommendPlaylistFun() {
    		const res = await dailyRecommendPlaylist();

    		if (res.code === 200) {
    			let olddailyRecommendPlayList = res.recommend;

    			if (olddailyRecommendPlayList[0].copywriter === '' && olddailyRecommendPlayList[0].name.indexOf('') > -1) {
    				getPlaylistDetailFun(true, olddailyRecommendPlayList);
    			} else {
    				$$invalidate(0, dailyRecommendPlayList = olddailyRecommendPlayList);
    			}
    		}
    	}

    	//
    	async function getSongDetailFun(id) {
    		const res = await getSongDetail(id); //

    		if (res.code === 200) {
    			$$invalidate(1, randomLoveSong = res.songs[0]);
    		}
    	}

    	//
    	async function getSimiPlaylistFun(id) {
    		const res = await getSimiPlaylist(id); //

    		if (res.code === 200) {
    			$$invalidate(2, similarPlayList = res.playlists);
    		}
    	}

    	//
    	async function getSimiSongFun(id) {
    		const res = await getSimiSong(id); //

    		if (res.code === 200) {
    			if (isRefresh) $$invalidate(9, isRefresh = false);

    			for (let t = 0; t < res.songs.length; t++) {
    				res.songs[t].al = res.songs[t].album;
    				res.songs[t].ar = res.songs[t].artists;
    			}

    			$$invalidate(4, similarSongs = res.songs);
    		}
    	}

    	//
    	async function getPlaylistDetailFun(isRadar = false, list) {
    		const res = await getPlaylistDetail(isRadar ? list[0].id : $userLikeListIdStore); //

    		if (res.code === 200) {
    			if (isRadar) {
    				if (list[0].copywriter === '' && list[0].name.indexOf('') > -1) {
    					list[0].copywriter = list[0].name;
    					list[0].picUrl = res.playlist.tracks[0].al.picUrl;
    					list[0].name = `${res.playlist.tracks[0].name}`;
    				}

    				for (let i = 0; i < list.length; i++) {
    					list[i].coverImgUrl = list[i].picUrl;
    					list[i].playCount = list[i].playcount;
    				}

    				$$invalidate(0, dailyRecommendPlayList = list);
    			}

    			let randomIndexTen = Math.round(Math.random() * 20); //20
    			$$invalidate(3, randomTenLoveSong = res.playlist.tracks[randomIndexTen]);
    			if (randomTenLoveSong) getSimiSongFun(randomTenLoveSong.id);
    		}
    	}

    	//URL
    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id);

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';

    				if ($isFMPlayStore) {
    					currentPlayListStore.set([song]);
    					currentSongIndexStore.set(0);
    					currentSongStore.set(song);
    					song.al = song.album;
    					song.ar = song.artists;
    					song.alia = song.alias;
    					FMPlayStore.set(song);
    					localStorage.setItem('currentSong', JSON.stringify(song));
    				}
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	//
    	async function similarArtistsFun(id, useLoveSongerIds) {
    		const res = await similarArtists(id);

    		if (res.code === 200) {
    			let newSongerIds = [];

    			for (let e = 0; e < res.artists.length; e++) {
    				newSongerIds.push(res.artists[e].id);
    			}

    			let artists = distinct(newSongerIds, useLoveSongerIds); //

    			for (let t = 0; t < artists.length; t++) {
    				for (let p = 0; p < res.artists.length; p++) {
    					if (artists[t] === res.artists[p].id) {
    						res.artists.splice(p, 1);
    					}
    				}
    			}

    			$$invalidate(8, simiSongers = res.artists.length > 6
    			? res.artists.slice(0, 6)
    			: res.artists);
    		}
    	}

    	//
    	async function getSongerDetailFun(id) {
    		const res = await getSongerDetail(id);

    		if (res.code === 200) {
    			$$invalidate(7, simiSonger = res.data.artist);
    		}
    	}

    	function topClickFun(event) {
    		if (event.detail.index === 0) {
    			allOnMount();
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Love> was created with unknown prop '${key}'`);
    	});

    	function div7_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			todayDom = $$value;
    			$$invalidate(6, todayDom);
    		});
    	}

    	function div14_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			FMDom = $$value;
    			$$invalidate(5, FMDom);
    		});
    	}

    	const BtnClick_handler = () => {
    		isHomePageStore.set(false);
    		push('/login');
    	};

    	const BtnClick_handler_1 = () => {
    		isHomePageStore.set(false);
    		push('/about');
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		push,
    		RadioFill,
    		RefreshLine,
    		Calendar2Fill,
    		GitRepositoryPrivateLine,
    		TopTitle,
    		Button,
    		ListGrid,
    		SongList,
    		Songer: Singer,
    		isLoginStore,
    		playIsMaxStore,
    		playStatusStore,
    		currentSongStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		maxPlayToTopStore,
    		FMPlayStore,
    		isFMPlayStore,
    		FMPlayNextStore,
    		currentSongQualityStore,
    		isHomePageStore,
    		todayListStore,
    		userLikeListIdStore,
    		dailyRecommendTracks,
    		getSimiPlaylist,
    		dailyRecommendPlaylist,
    		getPlaylistDetail,
    		getSongUrl,
    		personalFM,
    		getSongDetail,
    		getSimiSong,
    		similarArtists,
    		getSongerDetail,
    		songerListToStr,
    		Toast: Toast$1,
    		ripple,
    		dailyRecommendPlayList,
    		randomLoveSong,
    		similarPlayList,
    		randomTenLoveSong,
    		similarSongs,
    		topTitleRightList,
    		FMDom,
    		todayDom,
    		allOnMount,
    		playTodayFun,
    		playFMFun,
    		personalFMFun,
    		dailyRecommendTracksFun,
    		dailyRecommendPlaylistFun,
    		getSongDetailFun,
    		getSimiPlaylistFun,
    		getSimiSongFun,
    		getPlaylistDetailFun,
    		getSongUrlFun,
    		similarArtistsFun,
    		getSongerDetailFun,
    		distinct,
    		topClickFun,
    		simiSonger,
    		simiSongers,
    		isRefresh,
    		$isFMPlayStore,
    		$userLikeListIdStore,
    		$FMPlayStore,
    		$currentSongStore,
    		$isLoginStore,
    		$todayListStore,
    		$playStatusStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('dailyRecommendPlayList' in $$props) $$invalidate(0, dailyRecommendPlayList = $$props.dailyRecommendPlayList);
    		if ('randomLoveSong' in $$props) $$invalidate(1, randomLoveSong = $$props.randomLoveSong);
    		if ('similarPlayList' in $$props) $$invalidate(2, similarPlayList = $$props.similarPlayList);
    		if ('randomTenLoveSong' in $$props) $$invalidate(3, randomTenLoveSong = $$props.randomTenLoveSong);
    		if ('similarSongs' in $$props) $$invalidate(4, similarSongs = $$props.similarSongs);
    		if ('topTitleRightList' in $$props) $$invalidate(16, topTitleRightList = $$props.topTitleRightList);
    		if ('FMDom' in $$props) $$invalidate(5, FMDom = $$props.FMDom);
    		if ('todayDom' in $$props) $$invalidate(6, todayDom = $$props.todayDom);
    		if ('simiSonger' in $$props) $$invalidate(7, simiSonger = $$props.simiSonger);
    		if ('simiSongers' in $$props) $$invalidate(8, simiSongers = $$props.simiSongers);
    		if ('isRefresh' in $$props) $$invalidate(9, isRefresh = $$props.isRefresh);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(9, isRefresh = false);
    	$$invalidate(7, simiSonger = {});
    	$$invalidate(8, simiSongers = []);

    	return [
    		dailyRecommendPlayList,
    		randomLoveSong,
    		similarPlayList,
    		randomTenLoveSong,
    		similarSongs,
    		FMDom,
    		todayDom,
    		simiSonger,
    		simiSongers,
    		isRefresh,
    		$isFMPlayStore,
    		$FMPlayStore,
    		$currentSongStore,
    		$isLoginStore,
    		$todayListStore,
    		$playStatusStore,
    		topTitleRightList,
    		playTodayFun,
    		playFMFun,
    		topClickFun,
    		div7_binding,
    		div14_binding,
    		BtnClick_handler,
    		BtnClick_handler_1
    	];
    }

    class Love extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Love",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src\pages\Discover.svelte generated by Svelte v3.46.4 */
    const file$m = "src\\pages\\Discover.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    // (158:2) {#if topPlayList.length > 0}
    function create_if_block_5$2(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: /*tab2list*/ ctx[5].length > 0
    				? `${/*tab2list*/ ctx[5][/*active2*/ ctx[7]].name} - `
    				: `-`,
    				playList: /*topPlayList*/ ctx[0],
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listgrid.$on("titleClick", /*titleClick_handler*/ ctx[22]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			set_style(div, "margin-top", "10px");
    			add_location(div, file$m, 158, 4, 4152);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};

    			if (dirty[0] & /*tab2list, active2*/ 160) listgrid_changes.title = /*tab2list*/ ctx[5].length > 0
    			? `${/*tab2list*/ ctx[5][/*active2*/ ctx[7]].name} - `
    			: `-`;

    			if (dirty[0] & /*topPlayList*/ 1) listgrid_changes.playList = /*topPlayList*/ ctx[0];

    			if (dirty[0] & /*tab2list, active2, cat, allList, active1, categories*/ 2016 | dirty[1] & /*$$scope*/ 16384) {
    				listgrid_changes.$$scope = { dirty, ctx };
    			}

    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(158:2) {#if topPlayList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (170:12) {#each allList as category}
    function create_each_block_3$1(ctx) {
    	let div;
    	let t0_value = /*categories*/ ctx[10][/*category*/ ctx[42].category] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[20](/*category*/ ctx[42]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "tab1 svelte-zrdaop");
    			toggle_class(div, "tab1-active", /*active1*/ ctx[8] === /*category*/ ctx[42].category);
    			add_location(div, file$m, 170, 14, 4572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*categories, allList*/ 1536 && t0_value !== (t0_value = /*categories*/ ctx[10][/*category*/ ctx[42].category] + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*active1, allList*/ 768) {
    				toggle_class(div, "tab1-active", /*active1*/ ctx[8] === /*category*/ ctx[42].category);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(170:12) {#each allList as category}",
    		ctx
    	});

    	return block;
    }

    // (187:12) {#each tab2list as tab, i}
    function create_each_block_2$1(ctx) {
    	let span;
    	let t_value = /*tab*/ ctx[35].name + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[21](/*i*/ ctx[37], /*tab*/ ctx[35]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "tab2 svelte-zrdaop");
    			toggle_class(span, "tab1-active", /*active2*/ ctx[7] === /*i*/ ctx[37]);
    			add_location(span, file$m, 187, 14, 5214);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*tab2list*/ 32 && t_value !== (t_value = /*tab*/ ctx[35].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*active2*/ 128) {
    				toggle_class(span, "tab1-active", /*active2*/ ctx[7] === /*i*/ ctx[37]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(187:12) {#each tab2list as tab, i}",
    		ctx
    	});

    	return block;
    }

    // (160:6) <ListGrid          title={tab2list.length > 0 ? `${tab2list[active2].name} - ` : `-`}          playList={topPlayList}          on:titleClick={() => {            isHomePageStore.set(false);            push('/moreList?cat=' + cat + '&type=top');          }}        >
    function create_default_slot_2$2(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let t1;
    	let div1;
    	let each_value_3 = /*allList*/ ctx[9];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*tab2list*/ ctx[5];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t0 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "tab-1-box svelte-zrdaop");
    			add_location(div0, file$m, 168, 10, 4492);
    			attr_dev(div1, "class", "mask svelte-zrdaop");
    			add_location(div1, file$m, 199, 12, 5570);
    			attr_dev(div2, "class", "tab-2-box svelte-zrdaop");
    			add_location(div2, file$m, 185, 10, 5135);
    			add_location(div3, file$m, 167, 8, 4475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append_dev(div3, t0);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*active1, allList, tab2list, active2, cat, topPlaylistFun, categories*/ 67552) {
    				each_value_3 = /*allList*/ ctx[9];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty[0] & /*active2, cat, tab2list, topPlaylistFun*/ 65760) {
    				each_value_2 = /*tab2list*/ ctx[5];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, t1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(160:6) <ListGrid          title={tab2list.length > 0 ? `${tab2list[active2].name} - ` : `-`}          playList={topPlayList}          on:titleClick={() => {            isHomePageStore.set(false);            push('/moreList?cat=' + cat + '&type=top');          }}        >",
    		ctx
    	});

    	return block;
    }

    // (206:2) {#if offList.length > 0}
    function create_if_block_4$2(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				playList: /*offList*/ ctx[2]
    			},
    			$$inline: true
    		});

    	listgrid.$on("titleClick", /*titleClick_handler_1*/ ctx[23]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-zrdaop");
    			add_location(div, file$m, 206, 4, 5698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};
    			if (dirty[0] & /*offList*/ 4) listgrid_changes.playList = /*offList*/ ctx[2];
    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(206:2) {#if offList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (218:2) {#if topOrderList.length > 0}
    function create_if_block_3$4(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				isShowMore: false,
    				playList: /*topOrderList*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-zrdaop");
    			add_location(div, file$m, 218, 4, 5978);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};
    			if (dirty[0] & /*topOrderList*/ 8) listgrid_changes.playList = /*topOrderList*/ ctx[3];
    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(218:2) {#if topOrderList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (223:2) {#if hotSongers.length > 0}
    function create_if_block_2$4(ctx) {
    	let title;
    	let t;
    	let div;
    	let current;

    	title = new Title({
    			props: { title: "", isShowRight: true },
    			$$inline: true
    		});

    	title.$on("TitleClick", /*hotSongersFun*/ ctx[18]);
    	let each_value_1 = /*hotSongers*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(title.$$.fragment);
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "songer-box svelte-zrdaop");
    			add_location(div, file$m, 224, 4, 6211);
    		},
    		m: function mount(target, anchor) {
    			mount_component(title, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*hotSongers*/ 16) {
    				each_value_1 = /*hotSongers*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(title, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(223:2) {#if hotSongers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (226:6) {#each hotSongers as songer}
    function create_each_block_1$2(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[38],
    				coverSize: 330
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty[0] & /*hotSongers*/ 16) songer_changes.songer = /*songer*/ ctx[38];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(226:6) {#each hotSongers as songer}",
    		ctx
    	});

    	return block;
    }

    // (231:2) {#if highquality.length > 0}
    function create_if_block_1$8(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: /*heigtab2list*/ ctx[12].length > 0
    				? `${/*heigtab2list*/ ctx[12][/*heigActive*/ ctx[13]]} - `
    				: `-`,
    				playList: /*highquality*/ ctx[1],
    				isShowMore: /*highquality*/ ctx[1].length < 6 ? false : true,
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listgrid.$on("titleClick", /*titleClick_handler_2*/ ctx[25]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-zrdaop");
    			add_location(div, file$m, 231, 4, 6390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};

    			if (dirty[0] & /*heigtab2list, heigActive*/ 12288) listgrid_changes.title = /*heigtab2list*/ ctx[12].length > 0
    			? `${/*heigtab2list*/ ctx[12][/*heigActive*/ ctx[13]]} - `
    			: `-`;

    			if (dirty[0] & /*highquality*/ 2) listgrid_changes.playList = /*highquality*/ ctx[1];
    			if (dirty[0] & /*highquality*/ 2) listgrid_changes.isShowMore = /*highquality*/ ctx[1].length < 6 ? false : true;

    			if (dirty[0] & /*heigtab2list, heigActive, heigcat*/ 14336 | dirty[1] & /*$$scope*/ 16384) {
    				listgrid_changes.$$scope = { dirty, ctx };
    			}

    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(231:2) {#if highquality.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (243:10) {#each heigtab2list as tab, i}
    function create_each_block$6(ctx) {
    	let span;
    	let t_value = /*tab*/ ctx[35] + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[24](/*i*/ ctx[37], /*tab*/ ctx[35]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "tab2 svelte-zrdaop");
    			toggle_class(span, "tab1-active", /*heigActive*/ ctx[13] === /*i*/ ctx[37]);
    			add_location(span, file$m, 243, 12, 6855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*heigtab2list*/ 4096 && t_value !== (t_value = /*tab*/ ctx[35] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*heigActive*/ 8192) {
    				toggle_class(span, "tab1-active", /*heigActive*/ ctx[13] === /*i*/ ctx[37]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(243:10) {#each heigtab2list as tab, i}",
    		ctx
    	});

    	return block;
    }

    // (233:6) <ListGrid          title={heigtab2list.length > 0 ? `${heigtab2list[heigActive]} - ` : `-`}          playList={highquality}          isShowMore={highquality.length < 6 ? false : true}          on:titleClick={() => {            isHomePageStore.set(false);            push('/moreList?cat=' + heigcat + '&type=high');          }}        >
    function create_default_slot_1$5(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let each_value = /*heigtab2list*/ ctx[12];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			div0 = element("div");
    			attr_dev(div0, "class", "mask svelte-zrdaop");
    			add_location(div0, file$m, 255, 10, 7190);
    			attr_dev(div1, "class", "tab-2-box svelte-zrdaop");
    			add_location(div1, file$m, 241, 8, 6776);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div1, t);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*heigActive, heigcat, heigtab2list, highQualityPlaylistFun*/ 145408) {
    				each_value = /*heigtab2list*/ ctx[12];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(233:6) <ListGrid          title={heigtab2list.length > 0 ? `${heigtab2list[heigActive]} - ` : `-`}          playList={highquality}          isShowMore={highquality.length < 6 ? false : true}          on:titleClick={() => {            isHomePageStore.set(false);            push('/moreList?cat=' + heigcat + '&type=high');          }}        >",
    		ctx
    	});

    	return block;
    }

    // (261:2) {#if !$isLoginStore}
    function create_if_block$9(ctx) {
    	let div0;
    	let button;
    	let t0;
    	let div1;
    	let a;
    	let current;

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*BtnClick_handler*/ ctx[26]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			a = element("a");
    			a.textContent = "ICP17004037-3";
    			set_style(div0, "margin-top", "40px");
    			set_style(div0, "padding", "0 20px");
    			add_location(div0, file$m, 261, 4, 7296);
    			attr_dev(a, "href", "https://beian.miit.gov.cn/");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$m, 271, 20, 7536);
    			attr_dev(div1, "class", "ba svelte-zrdaop");
    			add_location(div1, file$m, 271, 4, 7520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(button, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(button);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(261:2) {#if !$isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (263:6) <Button          on:BtnClick={() => {            isHomePageStore.set(false);            push('/about');          }}        >
    function create_default_slot$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(263:6) <Button          on:BtnClick={() => {            isHomePageStore.set(false);            push('/about');          }}        >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let toptitle;
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let current;

    	toptitle = new TopTitle({
    			props: {
    				title: "",
    				desc: "",
    				topTitleRightList: /*topTitleRightList*/ ctx[15]
    			},
    			$$inline: true
    		});

    	toptitle.$on("IconClick", /*topClickFun*/ ctx[19]);
    	let if_block0 = /*topPlayList*/ ctx[0].length > 0 && create_if_block_5$2(ctx);
    	let if_block1 = /*offList*/ ctx[2].length > 0 && create_if_block_4$2(ctx);
    	let if_block2 = /*topOrderList*/ ctx[3].length > 0 && create_if_block_3$4(ctx);
    	let if_block3 = /*hotSongers*/ ctx[4].length > 0 && create_if_block_2$4(ctx);
    	let if_block4 = /*highquality*/ ctx[1].length > 0 && create_if_block_1$8(ctx);
    	let if_block5 = !/*$isLoginStore*/ ctx[14] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			create_component(toptitle.$$.fragment);
    			t0 = space();
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", "page svelte-zrdaop");
    			add_location(div, file$m, 156, 0, 4096);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(toptitle, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t4);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t5);
    			if (if_block5) if_block5.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*topPlayList*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*topPlayList*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*offList*/ ctx[2].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*offList*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*topOrderList*/ ctx[3].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*topOrderList*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hotSongers*/ ctx[4].length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*hotSongers*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$4(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*highquality*/ ctx[1].length > 0) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*highquality*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$8(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!/*$isLoginStore*/ ctx[14]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*$isLoginStore*/ 16384) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block$9(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toptitle.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toptitle.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toptitle, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function dealWithData(data) {
    	let c = [];
    	let d = {};

    	data.forEach(element => {
    		if (!d[element.category]) {
    			c.push({
    				category: element.category,
    				allData: [element]
    			});

    			d[element.category] = element;
    		} else {
    			c.forEach(ele => {
    				if (ele.category == element.category) {
    					ele.allData.push(element);
    				}
    			});
    		}
    	});

    	return c;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let allList;
    	let active1;
    	let tab2list;
    	let active2;
    	let categories;
    	let HotCatlist;
    	let hotSongers;
    	let cat;
    	let heigcat;
    	let heigtab2list;
    	let heigActive;
    	let $isLoginStore;
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(14, $isLoginStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Discover', slots, []);
    	let topPlayList = [];
    	let highquality = [];
    	let offList = [];
    	let topOrderList = [];
    	let topTitleRightList = { type: 'icon', path: SearchLine };

    	onMount(() => {
    		allMount();
    	});

    	function allMount() {
    		playlistHotCatlistFun();
    		highQualityCatFun();
    		offPlaylistFun();
    		toplistsFun();
    		topArtistsFun();
    	}

    	//
    	async function playlistHotCatlistFun() {
    		const res = await playlistHotCatlist();

    		if (res.code === 200) {
    			HotCatlist = res.tags;
    			HotCatlist.unshift({ name: '', category: 0 });
    			playlistCatlistFun();
    		}
    	}

    	//
    	async function highQualityCatFun() {
    		const res = await highQualityCat();

    		if (res.code === 200) {
    			for (let r = 0; r < res.tags.length; r++) {
    				heigtab2list.push(res.tags[r].name);
    			}

    			$$invalidate(11, heigcat = heigtab2list[0]);
    			highQualityPlaylistFun(heigcat);
    		}
    	}

    	//
    	async function playlistCatlistFun() {
    		const res = await playlistCatlist();

    		if (res.code === 200) {
    			$$invalidate(10, categories = res.categories);
    			$$invalidate(10, categories['5'] = '', categories);
    			$$invalidate(9, allList = dealWithData(res.sub));
    			allList.unshift({ category: 5, allData: HotCatlist });
    			$$invalidate(8, active1 = allList[0].category);
    			$$invalidate(5, tab2list = allList.filter(item => item.category === active1)[0].allData);
    			$$invalidate(7, active2 = 0);
    			$$invalidate(6, cat = tab2list[0].name);
    			topPlaylistFun(tab2list[0].name);
    		}
    	}

    	//
    	async function topPlaylistFun(cat) {
    		const res = await topPlaylist({ limit: 6, cat: cat === '' ? '' : cat });

    		if (res.code === 200) {
    			$$invalidate(0, topPlayList = res.playlists);
    		}
    	}

    	//
    	async function highQualityPlaylistFun(cat) {
    		const res = await highQualityPlaylist({ limit: 6, cat: cat === '' ? '' : cat });

    		if (res.code === 200) {
    			$$invalidate(1, highquality = res.playlists);
    		}
    	}

    	//
    	async function offPlaylistFun() {
    		const res = await topPlaylist({ limit: 6, cat: '' });

    		if (res.code === 200) {
    			$$invalidate(2, offList = res.playlists);
    		}
    	}

    	//
    	async function toplistsFun() {
    		const res = await toplists();

    		if (res.code === 200) {
    			$$invalidate(3, topOrderList = res.list);
    		}
    	}

    	//
    	async function topArtistsFun() {
    		const res = await topArtists(9);

    		if (res.code === 200) {
    			$$invalidate(4, hotSongers = res.artists);
    		}
    	}

    	// 
    	function hotSongersFun() {
    		isHomePageStore.set(false);
    		push('/moreSonger');
    	}

    	function topClickFun(event) {
    		if (event.detail.index === 0) {
    			isHomePageStore.set(false);
    			push('/search');
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Discover> was created with unknown prop '${key}'`);
    	});

    	const click_handler = category => {
    		$$invalidate(8, active1 = category.category);
    		$$invalidate(5, tab2list = allList.filter(item => item.category === active1)[0].allData);
    		$$invalidate(7, active2 = 0);
    		$$invalidate(6, cat = tab2list[0].name);
    		topPlaylistFun(tab2list[0].name);
    	};

    	const click_handler_1 = (i, tab) => {
    		$$invalidate(7, active2 = i);
    		$$invalidate(6, cat = tab.name);
    		topPlaylistFun(tab.name);
    	};

    	const titleClick_handler = () => {
    		isHomePageStore.set(false);
    		push('/moreList?cat=' + cat + '&type=top');
    	};

    	const titleClick_handler_1 = () => {
    		isHomePageStore.set(false);
    		push('/moreList?cat=');
    	};

    	const click_handler_2 = (i, tab) => {
    		$$invalidate(13, heigActive = i);
    		$$invalidate(11, heigcat = tab);
    		highQualityPlaylistFun(tab);
    	};

    	const titleClick_handler_2 = () => {
    		isHomePageStore.set(false);
    		push('/moreList?cat=' + heigcat + '&type=high');
    	};

    	const BtnClick_handler = () => {
    		isHomePageStore.set(false);
    		push('/about');
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		push,
    		SearchLine,
    		Title,
    		Button,
    		TopTitle,
    		ListGrid,
    		Songer: Singer,
    		isHomePageStore,
    		isLoginStore,
    		topPlaylist,
    		toplists,
    		highQualityPlaylist,
    		playlistCatlist,
    		playlistHotCatlist,
    		highQualityCat,
    		topArtists,
    		topPlayList,
    		highquality,
    		offList,
    		topOrderList,
    		topTitleRightList,
    		allMount,
    		playlistHotCatlistFun,
    		highQualityCatFun,
    		playlistCatlistFun,
    		topPlaylistFun,
    		highQualityPlaylistFun,
    		offPlaylistFun,
    		toplistsFun,
    		topArtistsFun,
    		hotSongersFun,
    		topClickFun,
    		dealWithData,
    		hotSongers,
    		tab2list,
    		cat,
    		active2,
    		active1,
    		allList,
    		HotCatlist,
    		categories,
    		heigcat,
    		heigtab2list,
    		heigActive,
    		$isLoginStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('topPlayList' in $$props) $$invalidate(0, topPlayList = $$props.topPlayList);
    		if ('highquality' in $$props) $$invalidate(1, highquality = $$props.highquality);
    		if ('offList' in $$props) $$invalidate(2, offList = $$props.offList);
    		if ('topOrderList' in $$props) $$invalidate(3, topOrderList = $$props.topOrderList);
    		if ('topTitleRightList' in $$props) $$invalidate(15, topTitleRightList = $$props.topTitleRightList);
    		if ('hotSongers' in $$props) $$invalidate(4, hotSongers = $$props.hotSongers);
    		if ('tab2list' in $$props) $$invalidate(5, tab2list = $$props.tab2list);
    		if ('cat' in $$props) $$invalidate(6, cat = $$props.cat);
    		if ('active2' in $$props) $$invalidate(7, active2 = $$props.active2);
    		if ('active1' in $$props) $$invalidate(8, active1 = $$props.active1);
    		if ('allList' in $$props) $$invalidate(9, allList = $$props.allList);
    		if ('HotCatlist' in $$props) HotCatlist = $$props.HotCatlist;
    		if ('categories' in $$props) $$invalidate(10, categories = $$props.categories);
    		if ('heigcat' in $$props) $$invalidate(11, heigcat = $$props.heigcat);
    		if ('heigtab2list' in $$props) $$invalidate(12, heigtab2list = $$props.heigtab2list);
    		if ('heigActive' in $$props) $$invalidate(13, heigActive = $$props.heigActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(9, allList = []);
    	$$invalidate(8, active1 = 0);
    	$$invalidate(5, tab2list = []);
    	$$invalidate(7, active2 = 0);
    	$$invalidate(10, categories = {});
    	HotCatlist = [];
    	$$invalidate(4, hotSongers = []);
    	$$invalidate(6, cat = '');
    	$$invalidate(11, heigcat = '');
    	$$invalidate(12, heigtab2list = ['']);
    	$$invalidate(13, heigActive = 0);

    	return [
    		topPlayList,
    		highquality,
    		offList,
    		topOrderList,
    		hotSongers,
    		tab2list,
    		cat,
    		active2,
    		active1,
    		allList,
    		categories,
    		heigcat,
    		heigtab2list,
    		heigActive,
    		$isLoginStore,
    		topTitleRightList,
    		topPlaylistFun,
    		highQualityPlaylistFun,
    		hotSongersFun,
    		topClickFun,
    		click_handler,
    		click_handler_1,
    		titleClick_handler,
    		titleClick_handler_1,
    		click_handler_2,
    		titleClick_handler_2,
    		BtnClick_handler
    	];
    }

    class Discover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Discover",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\pages\Mine.svelte generated by Svelte v3.46.4 */
    const file$l = "src\\pages\\Mine.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[44] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[47] = list[i];
    	child_ctx[49] = i;
    	return child_ctx;
    }

    // (373:2) {:else}
    function create_else_block_2(ctx) {
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let t2;
    	let div2;
    	let button0;
    	let t3;
    	let div3;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("BtnClick", /*BtnClick_handler*/ ctx[24]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("BtnClick", /*BtnClick_handler_1*/ ctx[25]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			div1.textContent = "";
    			t2 = space();
    			div2 = element("div");
    			create_component(button0.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(button1.$$.fragment);
    			attr_dev(img, "class", "login-img svelte-mflths");
    			if (!src_url_equal(img.src, img_src_value = "/images/login.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$l, 375, 8, 12783);
    			add_location(div0, file$l, 374, 6, 12768);
    			attr_dev(div1, "class", "tip svelte-mflths");
    			add_location(div1, file$l, 377, 6, 12861);
    			attr_dev(div2, "class", "login-btn");
    			add_location(div2, file$l, 378, 6, 12900);
    			set_style(div3, "margin-top", "40px");
    			add_location(div3, file$l, 389, 6, 13150);
    			attr_dev(div4, "class", "noLogin svelte-mflths");
    			add_location(div4, file$l, 373, 4, 12739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			mount_component(button0, div2, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			mount_component(button1, div3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 524288) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 524288) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(373:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (280:2) {#if $isLoginStore}
    function create_if_block$8(ctx) {
    	let div16;
    	let div7;
    	let div5;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div4;
    	let div1;
    	let t1_value = /*$userInfoStore*/ ctx[8].profile.nickname + "";
    	let t1;
    	let t2;
    	let div2;
    	let t3_value = (/*$userInfoStore*/ ctx[8].profile.signature || '') + "";
    	let t3;
    	let t4;
    	let div3;
    	let t5;
    	let div6;
    	let arrowrightsline;
    	let t6;
    	let div15;
    	let div14;
    	let div9;
    	let div8;
    	let t7;
    	let span0;
    	let t10;
    	let div10;
    	let t11;
    	let div13;
    	let div11;
    	let playfill;
    	let t12;
    	let div12;
    	let span1;
    	let heartpulsefill;
    	let t13;
    	let t14;
    	let t15;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$userInfoStore*/ ctx[8].account.vipType !== 0) return create_if_block_5$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);

    	arrowrightsline = new ArrowRightSLine({
    			props: {
    				size: "26",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	function select_block_type_2(ctx, dirty) {
    		if (/*isRequsetSucc*/ ctx[2]) return create_if_block_4$1;
    		return create_else_block$4;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	playfill = new PlayFill({
    			props: {
    				size: "24",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	heartpulsefill = new HeartPulseFill({
    			props: {
    				size: "24",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	let if_block2 = /*collectList*/ ctx[4].length > 0 && create_if_block_3$3(ctx);
    	let if_block3 = /*createList*/ ctx[5].length > 0 && create_if_block_2$3(ctx);
    	let if_block4 = /*collectSongers*/ ctx[7].length > 0 && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			div16 = element("div");
    			div7 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div4 = element("div");
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div3 = element("div");
    			if_block0.c();
    			t5 = space();
    			div6 = element("div");
    			create_component(arrowrightsline.$$.fragment);
    			t6 = space();
    			div15 = element("div");
    			div14 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			t7 = text("");
    			span0 = element("span");
    			span0.textContent = `${/*newuserLikeSongIdsStore*/ ctx[13].length}`;
    			t10 = space();
    			div10 = element("div");
    			if_block1.c();
    			t11 = space();
    			div13 = element("div");
    			div11 = element("div");
    			create_component(playfill.$$.fragment);
    			t12 = space();
    			div12 = element("div");
    			span1 = element("span");
    			create_component(heartpulsefill.$$.fragment);
    			t13 = space();
    			if (if_block2) if_block2.c();
    			t14 = space();
    			if (if_block3) if_block3.c();
    			t15 = space();
    			if (if_block4) if_block4.c();
    			if (!src_url_equal(img.src, img_src_value = /*$userInfoStore*/ ctx[8].profile.avatarUrl.replace(/^http:/, 'https:') + '?param=180y180')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-mflths");
    			add_location(img, file$l, 284, 12, 9057);
    			attr_dev(div0, "class", "avatar svelte-mflths");
    			add_location(div0, file$l, 283, 10, 9023);
    			attr_dev(div1, "class", "nicename svelte-mflths");
    			add_location(div1, file$l, 287, 12, 9219);
    			attr_dev(div2, "class", "signature svelte-mflths");
    			add_location(div2, file$l, 288, 12, 9294);
    			attr_dev(div3, "class", "tag");
    			add_location(div3, file$l, 289, 12, 9377);
    			attr_dev(div4, "class", "info svelte-mflths");
    			add_location(div4, file$l, 286, 10, 9187);
    			attr_dev(div5, "class", "left svelte-mflths");
    			add_location(div5, file$l, 282, 8, 8993);
    			attr_dev(div6, "class", "more svelte-mflths");
    			add_location(div6, file$l, 303, 8, 9872);
    			attr_dev(div7, "class", "info-box svelte-mflths");
    			add_location(div7, file$l, 281, 6, 8917);
    			attr_dev(span0, "class", "love-title-number svelte-mflths");
    			add_location(span0, file$l, 315, 20, 10363);
    			attr_dev(div8, "class", "love-title-text svelte-mflths");
    			add_location(div8, file$l, 314, 12, 10312);
    			attr_dev(div9, "class", "love-title svelte-mflths");
    			add_location(div9, file$l, 313, 10, 10274);
    			attr_dev(div10, "class", "random svelte-mflths");
    			add_location(div10, file$l, 318, 10, 10485);
    			attr_dev(div11, "class", "quick-btn-item svelte-mflths");
    			add_location(div11, file$l, 342, 12, 11519);
    			attr_dev(span1, "class", "svelte-mflths");
    			toggle_class(span1, "heart-beat", /*$playRepeatModelStore*/ ctx[10] === 'heart' && /*$playStatusStore*/ ctx[11]);
    			add_location(span1, file$l, 346, 14, 11742);
    			attr_dev(div12, "class", "quick-btn-item svelte-mflths");
    			add_location(div12, file$l, 345, 12, 11674);
    			attr_dev(div13, "class", "quick-btn svelte-mflths");
    			add_location(div13, file$l, 341, 10, 11482);
    			attr_dev(div14, "class", "love-song svelte-mflths");
    			add_location(div14, file$l, 312, 8, 10188);
    			attr_dev(div15, "class", "love-song-box svelte-mflths");
    			set_style(div15, "background-image", "url(" + (/*$userInfoStore*/ ctx[8].profile.avatarUrl.replace(/^http:/, 'https:') + '?param=180y180') + ")");
    			add_location(div15, file$l, 307, 6, 10000);
    			attr_dev(div16, "class", "login");
    			add_location(div16, file$l, 280, 4, 8890);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div0);
    			append_dev(div0, img);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div2, t3);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if_block0.m(div3, null);
    			append_dev(div7, t5);
    			append_dev(div7, div6);
    			mount_component(arrowrightsline, div6, null);
    			/*div7_binding*/ ctx[22](div7);
    			append_dev(div16, t6);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div9);
    			append_dev(div9, div8);
    			append_dev(div8, t7);
    			append_dev(div8, span0);
    			append_dev(div14, t10);
    			append_dev(div14, div10);
    			if_block1.m(div10, null);
    			append_dev(div14, t11);
    			append_dev(div14, div13);
    			append_dev(div13, div11);
    			mount_component(playfill, div11, null);
    			append_dev(div13, t12);
    			append_dev(div13, div12);
    			append_dev(div12, span1);
    			mount_component(heartpulsefill, span1, null);
    			/*div14_binding*/ ctx[23](div14);
    			append_dev(div16, t13);
    			if (if_block2) if_block2.m(div16, null);
    			append_dev(div16, t14);
    			if (if_block3) if_block3.m(div16, null);
    			append_dev(div16, t15);
    			if (if_block4) if_block4.m(div16, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div7, "click", /*toSettingFun*/ ctx[19], false, false, false),
    					listen_dev(div11, "click", /*quickPlayFun*/ ctx[20], false, false, false),
    					listen_dev(div12, "click", /*heartPlayFun*/ ctx[21], false, false, false),
    					listen_dev(div14, "click", /*goToLoveListFun*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$userInfoStore*/ 256 && !src_url_equal(img.src, img_src_value = /*$userInfoStore*/ ctx[8].profile.avatarUrl.replace(/^http:/, 'https:') + '?param=180y180')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty[0] & /*$userInfoStore*/ 256) && t1_value !== (t1_value = /*$userInfoStore*/ ctx[8].profile.nickname + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty[0] & /*$userInfoStore*/ 256) && t3_value !== (t3_value = (/*$userInfoStore*/ ctx[8].profile.signature || '') + "")) set_data_dev(t3, t3_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div3, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div10, null);
    				}
    			}

    			if (dirty[0] & /*$playRepeatModelStore, $playStatusStore*/ 3072) {
    				toggle_class(span1, "heart-beat", /*$playRepeatModelStore*/ ctx[10] === 'heart' && /*$playStatusStore*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*$userInfoStore*/ 256) {
    				set_style(div15, "background-image", "url(" + (/*$userInfoStore*/ ctx[8].profile.avatarUrl.replace(/^http:/, 'https:') + '?param=180y180') + ")");
    			}

    			if (/*collectList*/ ctx[4].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*collectList*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div16, t14);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*createList*/ ctx[5].length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*createList*/ 32) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div16, t15);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*collectSongers*/ ctx[7].length > 0) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*collectSongers*/ 128) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$7(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div16, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arrowrightsline.$$.fragment, local);
    			transition_in(playfill.$$.fragment, local);
    			transition_in(heartpulsefill.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arrowrightsline.$$.fragment, local);
    			transition_out(playfill.$$.fragment, local);
    			transition_out(heartpulsefill.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div16);
    			if_block0.d();
    			destroy_component(arrowrightsline);
    			/*div7_binding*/ ctx[22](null);
    			if_block1.d();
    			destroy_component(playfill);
    			destroy_component(heartpulsefill);
    			/*div14_binding*/ ctx[23](null);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(280:2) {#if $isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (380:8) <Button            type="primary"            on:BtnClick={() => {              isHomePageStore.set(false);              push('/login');            }}          >
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(380:8) <Button            type=\\\"primary\\\"            on:BtnClick={() => {              isHomePageStore.set(false);              push('/login');            }}          >",
    		ctx
    	});

    	return block;
    }

    // (391:8) <Button            on:BtnClick={() => {              isHomePageStore.set(false);              push('/about');            }}          >
    function create_default_slot$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(391:8) <Button            on:BtnClick={() => {              isHomePageStore.set(false);              push('/about');            }}          >",
    		ctx
    	});

    	return block;
    }

    // (296:14) {:else}
    function create_else_block_1$1(ctx) {
    	let span;
    	let t_value = /*$userInfoStore*/ ctx[8].profile.signature + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "v-else", "");
    			attr_dev(span, "class", "text");
    			add_location(span, file$l, 296, 16, 9682);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$userInfoStore*/ 256 && t_value !== (t_value = /*$userInfoStore*/ ctx[8].profile.signature + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(296:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (291:14) {#if $userInfoStore.account.vipType !== 0}
    function create_if_block_5$1(ctx) {
    	let span1;
    	let img;
    	let img_src_value;
    	let t0;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			img = element("img");
    			t0 = space();
    			span0 = element("span");
    			span0.textContent = "VIP";
    			attr_dev(img, "class", "cvip svelte-mflths");
    			if (!src_url_equal(img.src, img_src_value = "/images/vip/vip.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$l, 292, 18, 9508);
    			attr_dev(span0, "class", "vip-text svelte-mflths");
    			add_location(span0, file$l, 293, 18, 9581);
    			attr_dev(span1, "class", "vip");
    			add_location(span1, file$l, 291, 16, 9470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, img);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(291:14) {#if $userInfoStore.account.vipType !== 0}",
    		ctx
    	});

    	return block;
    }

    // (336:12) {:else}
    function create_else_block$4(ctx) {
    	let span;
    	let embed;
    	let embed_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			embed = element("embed");
    			attr_dev(embed, "width", "100");
    			attr_dev(embed, "height", "100");
    			if (!src_url_equal(embed.src, embed_src_value = "/images/Ripple.svg")) attr_dev(embed, "src", embed_src_value);
    			attr_dev(embed, "type", "image/svg+xml");
    			add_location(embed, file$l, 337, 16, 11330);
    			set_style(span, "line-height", "100px");
    			set_style(span, "position", "relative");
    			set_style(span, "left", "50%");
    			set_style(span, "margin-left", "-50px");
    			set_style(span, "top", "40px");
    			add_location(span, file$l, 336, 14, 11222);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, embed);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(336:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (320:12) {#if isRequsetSucc}
    function create_if_block_4$1(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*randomAll*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*randomAll*/ 8) {
    				each_value_1 = /*randomAll*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(320:12) {#if isRequsetSucc}",
    		ctx
    	});

    	return block;
    }

    // (321:14) {#each randomAll as item, i}
    function create_each_block_1$1(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1_value = /*item*/ ctx[47].name + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(img, "class", "random-img svelte-mflths");
    			set_style(img, "width", /*item*/ ctx[47].size + "px");
    			set_style(img, "height", /*item*/ ctx[47].size + "px");
    			set_style(img, "top", /*item*/ ctx[47].size / 8 + "px");
    			if (!src_url_equal(img.src, img_src_value = /*item*/ ctx[47].img.replace(/^http:/, 'https:') + '?param=100y100')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$l, 326, 18, 10838);
    			attr_dev(div, "class", "random-item svelte-mflths");
    			set_style(div, "height", /*item*/ ctx[47].size + "px");
    			set_style(div, "line-height", /*item*/ ctx[47].size + "px");
    			set_style(div, "top", /*i*/ ctx[49] * 26 + "px");
    			set_style(div, "left", /*item*/ ctx[47].left + "px");
    			set_style(div, "font-size", /*item*/ ctx[47].size + "px");
    			add_location(div, file$l, 321, 16, 10600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(img, "width", /*item*/ ctx[47].size + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(img, "height", /*item*/ ctx[47].size + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(img, "top", /*item*/ ctx[47].size / 8 + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8 && !src_url_equal(img.src, img_src_value = /*item*/ ctx[47].img.replace(/^http:/, 'https:') + '?param=100y100')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty[0] & /*randomAll*/ 8 && t1_value !== (t1_value = /*item*/ ctx[47].name + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(div, "height", /*item*/ ctx[47].size + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(div, "line-height", /*item*/ ctx[47].size + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(div, "left", /*item*/ ctx[47].left + "px");
    			}

    			if (dirty[0] & /*randomAll*/ 8) {
    				set_style(div, "font-size", /*item*/ ctx[47].size + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(321:14) {#each randomAll as item, i}",
    		ctx
    	});

    	return block;
    }

    // (354:6) {#if collectList.length > 0}
    function create_if_block_3$3(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				playList: /*collectList*/ ctx[4],
    				iconText: ""
    			},
    			$$inline: true
    		});

    	listgrid.$on("titleClick", /*collectTitleFun*/ ctx[18]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-mflths");
    			add_location(div, file$l, 354, 8, 12035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};
    			if (dirty[0] & /*collectList*/ 16) listgrid_changes.playList = /*collectList*/ ctx[4];
    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(354:6) {#if collectList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (359:6) {#if createList.length > 0}
    function create_if_block_2$3(ctx) {
    	let div;
    	let listgrid;
    	let current;

    	listgrid = new ListGrid({
    			props: {
    				title: "",
    				playList: /*createList*/ ctx[5],
    				iconText: ""
    			},
    			$$inline: true
    		});

    	listgrid.$on("titleClick", /*createTitleFun*/ ctx[17]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(listgrid.$$.fragment);
    			attr_dev(div, "class", "list-grid svelte-mflths");
    			add_location(div, file$l, 359, 8, 12239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(listgrid, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgrid_changes = {};
    			if (dirty[0] & /*createList*/ 32) listgrid_changes.playList = /*createList*/ ctx[5];
    			listgrid.$set(listgrid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(listgrid);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(359:6) {#if createList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (364:6) {#if collectSongers.length > 0}
    function create_if_block_1$7(ctx) {
    	let title;
    	let t;
    	let div;
    	let current;

    	title = new Title({
    			props: {
    				title: "",
    				iconText: "",
    				isShowRight: true
    			},
    			$$inline: true
    		});

    	title.$on("TitleClick", /*collectSongersFun*/ ctx[14]);
    	let each_value = /*collectSongers*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(title.$$.fragment);
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "songer-box svelte-mflths");
    			add_location(div, file$l, 365, 8, 12545);
    		},
    		m: function mount(target, anchor) {
    			mount_component(title, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collectSongers*/ 128) {
    				each_value = /*collectSongers*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(title, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(364:6) {#if collectSongers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (367:10) {#each collectSongers as songer}
    function create_each_block$5(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[44],
    				coverSize: 330
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty[0] & /*collectSongers*/ 128) songer_changes.songer = /*songer*/ ctx[44];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(367:10) {#each collectSongers as songer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let toptitle;
    	let t;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	toptitle = new TopTitle({
    			props: {
    				title: "",
    				desc: "",
    				isRefresh: /*isRefresh*/ ctx[6],
    				topTitleRightList: /*$isLoginStore*/ ctx[9]
    				? /*topTitleRightList*/ ctx[12]
    				: null
    			},
    			$$inline: true
    		});

    	toptitle.$on("IconClick", /*topClickFun*/ ctx[15]);
    	const if_block_creators = [create_if_block$8, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$isLoginStore*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(toptitle.$$.fragment);
    			t = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "mine svelte-mflths");
    			add_location(div, file$l, 278, 0, 8843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(toptitle, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const toptitle_changes = {};
    			if (dirty[0] & /*isRefresh*/ 64) toptitle_changes.isRefresh = /*isRefresh*/ ctx[6];

    			if (dirty[0] & /*$isLoginStore*/ 512) toptitle_changes.topTitleRightList = /*$isLoginStore*/ ctx[9]
    			? /*topTitleRightList*/ ctx[12]
    			: null;

    			toptitle.$set(toptitle_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toptitle.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toptitle.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toptitle, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getRandom(n, m, sum) {
    	let arr = [];

    	for (let i = 0; i < sum; i++) {
    		arr.push(Math.floor(Math.random() * (m - n + 1) + n));
    	}

    	return arr;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let randomList;
    	let collectList;
    	let createList;
    	let randomFontSize;
    	let randomTop;
    	let randomleft;
    	let randomIds;
    	let randomAll;
    	let isRequsetSucc;
    	let isRefresh;
    	let collectSongers;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $userLikeListIdStore;
    	let $userInfoStore;
    	let $isLoginStore;
    	let $userLikeSongIdsStore;
    	let $playRepeatModelStore;
    	let $playStatusStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(31, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(32, $currentPlayListStore = $$value));
    	validate_store(userLikeListIdStore, 'userLikeListIdStore');
    	component_subscribe($$self, userLikeListIdStore, $$value => $$invalidate(33, $userLikeListIdStore = $$value));
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(8, $userInfoStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(9, $isLoginStore = $$value));
    	validate_store(userLikeSongIdsStore, 'userLikeSongIdsStore');
    	component_subscribe($$self, userLikeSongIdsStore, $$value => $$invalidate(34, $userLikeSongIdsStore = $$value));
    	validate_store(playRepeatModelStore, 'playRepeatModelStore');
    	component_subscribe($$self, playRepeatModelStore, $$value => $$invalidate(10, $playRepeatModelStore = $$value));
    	validate_store(playStatusStore, 'playStatusStore');
    	component_subscribe($$self, playStatusStore, $$value => $$invalidate(11, $playStatusStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Mine', slots, []);
    	let loveSongDom;
    	let infoDom;
    	let topTitleRightList = { type: 'icon', path: RefreshLine };

    	let newuserLikeSongIdsStore = typeof $userLikeSongIdsStore === 'string'
    	? JSON.parse($userLikeSongIdsStore)
    	: $userLikeSongIdsStore;

    	onMount(() => {
    		if (loveSongDom) {
    			ripple(loveSongDom);
    		}

    		if (infoDom) {
    			ripple(infoDom);
    		}

    		allOnMount();
    	});

    	//
    	function allOnMount() {
    		if ($isLoginStore) {
    			randomFontSize = getRandom(10, 30, 10);
    			randomTop = getRandom(0, 200, 10);
    			randomleft = getRandom(-50, 300, 10);
    			randomIds = getRandom(0, JSON.parse(localStorage.getItem('useLoveSongIds')).length, 10);
    			let ids = [];

    			for (let i = 0; i < randomIds.length; i++) {
    				ids.push(JSON.parse(localStorage.getItem('useLoveSongIds'))[randomIds[i]]);
    			}

    			getSongDetailFun(ids.join(','));
    			userPlaylistFun();
    			likedArtistsFun();
    		}
    	}

    	//
    	async function likedArtistsFun() {
    		const res = await likedArtists({ limit: 6 });

    		if (res.code === 200) {
    			$$invalidate(7, collectSongers = res.data);
    		}
    	}

    	// 
    	function collectSongersFun() {
    		isHomePageStore.set(false);
    		push('/allCollectSongers');
    	}

    	//ID
    	async function userPlaylistFun(login) {
    		const res = await userPlaylist({ uid: $userInfoStore.account.id });

    		if (res.code === 200) {
    			$$invalidate(6, isRefresh = false);
    			let createListL = [];
    			let collectListL = [];

    			//
    			if (res.playlist[0].creator.userId === $userInfoStore.account.id && res.playlist[0].name.substr(-5) === '') {
    				userLikeListIdStore.set(res.playlist[0].id);
    				localStorage.setItem('userLikeListId', res.playlist[0].id);
    				res.playlist.splice(0, 1);
    			}

    			for (let i = 0; i < res.playlist.length; i++) {
    				if (res.playlist[i].creator.userId === $userInfoStore.account.id) {
    					createListL.push(res.playlist[i]);
    				} else {
    					collectListL.push(res.playlist[i]);
    				}
    			}

    			//
    			$$invalidate(5, createList = createListL.length >= 10
    			? createListL.slice(0, 10)
    			: createListL);

    			//
    			$$invalidate(4, collectList = collectListL.length >= 10
    			? collectListL.slice(0, 10)
    			: collectListL);
    		} else {
    			Toast$1('');
    		}
    	}

    	//
    	async function getSongDetailFun(songIds) {
    		$$invalidate(2, isRequsetSucc = false);

    		if (songIds.slice(0, 1) === ',') {
    			songIds = songIds.substr(1);
    		}

    		songIds = songIds.replace(',,', ',');
    		const res = await getSongDetail(songIds);

    		if (res.code === 200) {
    			randomList = res.songs;
    			$$invalidate(3, randomAll = []);

    			for (let u = 0; u < randomList.length; u++) {
    				randomAll.push({
    					name: randomList[u].name,
    					size: randomFontSize[u],
    					top: randomTop[u],
    					left: randomleft[u],
    					img: randomList[u].al.picUrl,
    					id: randomList[u].id
    				});
    			}

    			$$invalidate(2, isRequsetSucc = true);
    		}
    	}

    	//
    	function topClickFun(event) {
    		if (event.detail.index === 0) {
    			allOnMount();
    		}
    	}

    	//
    	function goToLoveListFun() {
    		isHomePageStore.set(false);
    		push('/loveListDetail');
    	}

    	//
    	function createTitleFun() {
    		isHomePageStore.set(false);
    		push('/myAllPlayList?create');
    	}

    	//
    	function collectTitleFun() {
    		isHomePageStore.set(false);
    		push('/myAllPlayList?collect');
    	}

    	//
    	function toSettingFun() {
    		isHomePageStore.set(false);
    		push('/setting');
    	}

    	//
    	function quickPlayFun(e) {
    		e.preventDefault();
    		e.stopPropagation();
    		getPlaylistDetailFun();
    	}

    	//
    	async function heartPlayFun(e) {
    		e.preventDefault();
    		e.stopPropagation();

    		//id
    		const randomLikeSongId = newuserLikeSongIdsStore[Math.floor(Math.random() * newuserLikeSongIdsStore.length)];

    		const res = await intelligenceList({
    			id: randomLikeSongId,
    			pid: $userLikeListIdStore
    		});

    		if (res.code === 200) {
    			getSongUrl(randomLikeSongId);
    			let songsInfoList = [];

    			for (let r = 0; r < res.data.length; r++) {
    				songsInfoList.push(res.data[r].songInfo);
    			}

    			getFirstDetail(randomLikeSongId, songsInfoList);
    		}
    	}

    	async function getFirstDetail(randomLikeSongId, data) {
    		const res = await getSongDetail(randomLikeSongId);

    		if (res.code === 200) {
    			let songs = [res.songs[0], ...data];
    			currentPlayListStore.set(songs);
    			let ids = [];

    			for (let r = 0; r < songs.length; r++) {
    				ids.push(songs[r].id);
    			}

    			localStorage.setItem('localPlayList', JSON.stringify(ids));
    			playListFun(true);
    		}
    	}

    	//
    	async function getPlaylistDetailFun() {
    		const res = await getPlaylistDetail($userLikeListIdStore); //

    		if (res.code === 200) {
    			let songIdList = [];

    			for (let i = 0; i < res.playlist.trackIds.length; i++) {
    				songIdList.push(res.playlist.trackIds[i].id);
    			}

    			if (songIdList.length > 400) {
    				Toast$1('', 2000);
    			}

    			getQuickSongDetailFun(songIdList.join(','));
    			getSongUrl(songIdList[0]);
    		}
    	}

    	//
    	async function getQuickSongDetailFun(songIds) {
    		const res = await getSongDetail(songIds);

    		if (res.code === 200) {
    			currentPlayListStore.set(res.songs);
    			playListFun(false);
    		}
    	}

    	//
    	function playListFun(isHeart) {
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentSongIndexStore.set(0);
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore], isHeart);
    	}

    	async function getSongUrlFun(song, isHeart) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';

    				isHeart
    				? playRepeatModelStore.set('heart')
    				: playRepeatModelStore.set('repeat');

    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Alert(isHeart
    				? ` ${song.name}......`
    				: ` --${song.name}......`);
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mine> was created with unknown prop '${key}'`);
    	});

    	function div7_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			infoDom = $$value;
    			$$invalidate(1, infoDom);
    		});
    	}

    	function div14_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			loveSongDom = $$value;
    			$$invalidate(0, loveSongDom);
    		});
    	}

    	const BtnClick_handler = () => {
    		isHomePageStore.set(false);
    		push('/login');
    	};

    	const BtnClick_handler_1 = () => {
    		isHomePageStore.set(false);
    		push('/about');
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		push,
    		RefreshLine,
    		ArrowRightSLine,
    		PlayFill,
    		HeartPulseFill,
    		Button,
    		Title,
    		TopTitle,
    		ListGrid,
    		Songer: Singer,
    		getSongDetail,
    		getSongUrl,
    		userPlaylist,
    		likedArtists,
    		getPlaylistDetail,
    		intelligenceList,
    		currentSongStore,
    		playStatusStore,
    		currentSongIndexStore,
    		currentPlayListStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		isLoginStore,
    		isHomePageStore,
    		userLikeSongIdsStore,
    		userInfoStore,
    		userLikeListIdStore,
    		Toast: Toast$1,
    		Alert,
    		ripple,
    		loveSongDom,
    		infoDom,
    		topTitleRightList,
    		newuserLikeSongIdsStore,
    		allOnMount,
    		likedArtistsFun,
    		collectSongersFun,
    		userPlaylistFun,
    		getRandom,
    		getSongDetailFun,
    		topClickFun,
    		goToLoveListFun,
    		createTitleFun,
    		collectTitleFun,
    		toSettingFun,
    		quickPlayFun,
    		heartPlayFun,
    		getFirstDetail,
    		getPlaylistDetailFun,
    		getQuickSongDetailFun,
    		playListFun,
    		getSongUrlFun,
    		isRequsetSucc,
    		randomList,
    		randomleft,
    		randomTop,
    		randomFontSize,
    		randomAll,
    		collectList,
    		createList,
    		isRefresh,
    		collectSongers,
    		randomIds,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$userLikeListIdStore,
    		$userInfoStore,
    		$isLoginStore,
    		$userLikeSongIdsStore,
    		$playRepeatModelStore,
    		$playStatusStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('loveSongDom' in $$props) $$invalidate(0, loveSongDom = $$props.loveSongDom);
    		if ('infoDom' in $$props) $$invalidate(1, infoDom = $$props.infoDom);
    		if ('topTitleRightList' in $$props) $$invalidate(12, topTitleRightList = $$props.topTitleRightList);
    		if ('newuserLikeSongIdsStore' in $$props) $$invalidate(13, newuserLikeSongIdsStore = $$props.newuserLikeSongIdsStore);
    		if ('isRequsetSucc' in $$props) $$invalidate(2, isRequsetSucc = $$props.isRequsetSucc);
    		if ('randomList' in $$props) randomList = $$props.randomList;
    		if ('randomleft' in $$props) randomleft = $$props.randomleft;
    		if ('randomTop' in $$props) randomTop = $$props.randomTop;
    		if ('randomFontSize' in $$props) randomFontSize = $$props.randomFontSize;
    		if ('randomAll' in $$props) $$invalidate(3, randomAll = $$props.randomAll);
    		if ('collectList' in $$props) $$invalidate(4, collectList = $$props.collectList);
    		if ('createList' in $$props) $$invalidate(5, createList = $$props.createList);
    		if ('isRefresh' in $$props) $$invalidate(6, isRefresh = $$props.isRefresh);
    		if ('collectSongers' in $$props) $$invalidate(7, collectSongers = $$props.collectSongers);
    		if ('randomIds' in $$props) randomIds = $$props.randomIds;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	randomList = [];
    	$$invalidate(4, collectList = []);
    	$$invalidate(5, createList = []);
    	randomFontSize = [];
    	randomTop = [];
    	randomleft = [];
    	randomIds = [];
    	$$invalidate(3, randomAll = []);
    	$$invalidate(2, isRequsetSucc = false);
    	$$invalidate(6, isRefresh = false);
    	$$invalidate(7, collectSongers = []); //

    	return [
    		loveSongDom,
    		infoDom,
    		isRequsetSucc,
    		randomAll,
    		collectList,
    		createList,
    		isRefresh,
    		collectSongers,
    		$userInfoStore,
    		$isLoginStore,
    		$playRepeatModelStore,
    		$playStatusStore,
    		topTitleRightList,
    		newuserLikeSongIdsStore,
    		collectSongersFun,
    		topClickFun,
    		goToLoveListFun,
    		createTitleFun,
    		collectTitleFun,
    		toSettingFun,
    		quickPlayFun,
    		heartPlayFun,
    		div7_binding,
    		div14_binding,
    		BtnClick_handler,
    		BtnClick_handler_1
    	];
    }

    class Mine extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mine",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\pages\Home.svelte generated by Svelte v3.46.4 */
    const file$k = "src\\pages\\Home.svelte";

    function create_fragment$k(ctx) {
    	let div0;
    	let love;
    	let t0;
    	let div1;
    	let discover;
    	let t1;
    	let div2;
    	let mine;
    	let current;
    	love = new Love({ $$inline: true });
    	discover = new Discover({ $$inline: true });
    	mine = new Mine({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(love.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(discover.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(mine.$$.fragment);
    			set_style(div0, "display", /*$homeActiveStore*/ ctx[0] === 0 ? 'block' : 'none');
    			add_location(div0, file$k, 30, 0, 849);
    			set_style(div1, "display", /*$homeActiveStore*/ ctx[0] === 1 ? 'block' : 'none');
    			add_location(div1, file$k, 33, 0, 936);
    			set_style(div2, "display", /*$homeActiveStore*/ ctx[0] === 2 ? 'block' : 'none');
    			add_location(div2, file$k, 36, 0, 1027);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(love, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(discover, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(mine, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$homeActiveStore*/ 1) {
    				set_style(div0, "display", /*$homeActiveStore*/ ctx[0] === 0 ? 'block' : 'none');
    			}

    			if (!current || dirty & /*$homeActiveStore*/ 1) {
    				set_style(div1, "display", /*$homeActiveStore*/ ctx[0] === 1 ? 'block' : 'none');
    			}

    			if (!current || dirty & /*$homeActiveStore*/ 1) {
    				set_style(div2, "display", /*$homeActiveStore*/ ctx[0] === 2 ? 'block' : 'none');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(love.$$.fragment, local);
    			transition_in(discover.$$.fragment, local);
    			transition_in(mine.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(love.$$.fragment, local);
    			transition_out(discover.$$.fragment, local);
    			transition_out(mine.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(love);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(discover);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(mine);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $isLoginStore;
    	let $homeActiveStore;
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(1, $isLoginStore = $$value));
    	validate_store(homeActiveStore, 'homeActiveStore');
    	component_subscribe($$self, homeActiveStore, $$value => $$invalidate(0, $homeActiveStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);

    	onMount(() => {
    		$isLoginStore
    		? homeActiveStore.set(0)
    		: homeActiveStore.set(1);

    		//
    		let date = new Date();

    		if ($isLoginStore && localStorage.getItem('dailySigninFun_date') != '' + date.getFullYear() + (date.getMonth() + 1) + date.getDate()) {
    			dailySigninFun();
    		}
    	});

    	//
    	async function dailySigninFun() {
    		await dailySignin();
    		let date = new Date();
    		localStorage.setItem('dailySigninFun_date', '' + date.getFullYear() + (date.getMonth() + 1) + date.getDate());
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Love,
    		Discover,
    		Mine,
    		dailySignin,
    		isLoginStore,
    		homeActiveStore,
    		dailySigninFun,
    		$isLoginStore,
    		$homeActiveStore
    	});

    	return [$homeActiveStore];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\pages\PlayListDetail.svelte generated by Svelte v3.46.4 */

    const { window: window_1 } = globals;
    const file$j = "src\\pages\\PlayListDetail.svelte";

    // (169:8) <Lazy height={140}>
    function create_default_slot_2$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "img-cover svelte-21fmj8");
    			if (!src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[8].replace(/^http:/, 'https:') + '?param=450y450')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$j, 169, 10, 5732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coverImgUrl*/ 256 && !src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[8].replace(/^http:/, 'https:') + '?param=450y450')) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(169:8) <Lazy height={140}>",
    		ctx
    	});

    	return block;
    }

    // (188:6) <Button type="primary" on:BtnClick={() => playListFun(0)}>
    function create_default_slot_1$3(ctx) {
    	let span;
    	let playcircleline;
    	let t;
    	let current;

    	playcircleline = new PlayCircleLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(playcircleline.$$.fragment);
    			t = text("\r\n        ");
    			attr_dev(span, "class", "icon svelte-21fmj8");
    			add_location(span, file$j, 188, 8, 6571);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(playcircleline, span, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playcircleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playcircleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(playcircleline);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(188:6) <Button type=\\\"primary\\\" on:BtnClick={() => playListFun(0)}>",
    		ctx
    	});

    	return block;
    }

    // (195:4) {#if $isLoginStore && creator.userId != $userInfoStore.account.id}
    function create_if_block$7(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				type: /*collect*/ ctx[1] ? 'default' : 'primary',
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*lovePlayListFun*/ ctx[14]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "random svelte-21fmj8");
    			add_location(div, file$j, 195, 6, 6801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*collect*/ 2) button_changes.type = /*collect*/ ctx[1] ? 'default' : 'primary';

    			if (dirty & /*$$scope, collect*/ 16777218) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(195:4) {#if $isLoginStore && creator.userId != $userInfoStore.account.id}",
    		ctx
    	});

    	return block;
    }

    // (201:12) {:else}
    function create_else_block$3(ctx) {
    	let chatheartfill;
    	let current;

    	chatheartfill = new ChatHeartFill({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatheartfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatheartfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatheartfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatheartfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatheartfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(201:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (199:12) {#if collect}
    function create_if_block_1$6(ctx) {
    	let chatheartline;
    	let current;

    	chatheartline = new ChatHeartLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatheartline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatheartline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatheartline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatheartline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatheartline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(199:12) {#if collect}",
    		ctx
    	});

    	return block;
    }

    // (197:8) <Button type={collect ? 'default' : 'primary'} on:BtnClick={lovePlayListFun}>
    function create_default_slot$b(ctx) {
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let t1_value = (/*collect*/ ctx[1] ? '' : '') + "";
    	let t1;
    	let current;
    	const if_block_creators = [create_if_block_1$6, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*collect*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(span, "class", "icon svelte-21fmj8");
    			add_location(span, file$j, 197, 10, 6920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_blocks[current_block_type_index].m(span, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}

    			if ((!current || dirty & /*collect*/ 2) && t1_value !== (t1_value = (/*collect*/ ctx[1] ? '' : '') + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(197:8) <Button type={collect ? 'default' : 'primary'} on:BtnClick={lovePlayListFun}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let navbar;
    	let t0;
    	let div11;
    	let div6;
    	let div5;
    	let div0;
    	let lazy;
    	let t1;
    	let div4;
    	let div1;
    	let t2;
    	let t3;
    	let div2;
    	let img;
    	let img_src_value;
    	let t4;
    	let span;
    	let t5_value = /*creator*/ ctx[4].nickname + "";
    	let t5;
    	let t6;
    	let div3;
    	let t7;
    	let t8_value = formatTime(/*updateTime*/ ctx[5]) + "";
    	let t8;
    	let t9;
    	let t10_value = (/*songList*/ ctx[2] ? /*songList*/ ctx[2].length : 0) + "";
    	let t10;
    	let t11;
    	let t12;
    	let div7;
    	let t13;
    	let t14;
    	let div9;
    	let div8;
    	let button;
    	let t15;
    	let t16;
    	let div10;
    	let songlist;
    	let current;
    	let mounted;
    	let dispose;

    	navbar = new NavBar({
    			props: {
    				title: /*title*/ ctx[6],
    				transparent: true,
    				dark: true,
    				alphaNumber: /*alphaNumber*/ ctx[3]
    			},
    			$$inline: true
    		});

    	lazy = new Src({
    			props: {
    				height: 140,
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*BtnClick_handler*/ ctx[16]);
    	let if_block = /*$isLoginStore*/ ctx[10] && /*creator*/ ctx[4].userId != /*$userInfoStore*/ ctx[11].account.id && create_if_block$7(ctx);

    	songlist = new SongList({
    			props: { songList: /*songList*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div11 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			create_component(lazy.$$.fragment);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			t2 = text(/*name*/ ctx[7]);
    			t3 = space();
    			div2 = element("div");
    			img = element("img");
    			t4 = space();
    			span = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");
    			t7 = text("");
    			t8 = text(t8_value);
    			t9 = text("  ");
    			t10 = text(t10_value);
    			t11 = text("");
    			t12 = space();
    			div7 = element("div");
    			t13 = text(/*description*/ ctx[9]);
    			t14 = space();
    			div9 = element("div");
    			div8 = element("div");
    			create_component(button.$$.fragment);
    			t15 = space();
    			if (if_block) if_block.c();
    			t16 = space();
    			div10 = element("div");
    			create_component(songlist.$$.fragment);
    			attr_dev(div0, "class", "cover svelte-21fmj8");
    			add_location(div0, file$j, 167, 6, 5672);
    			attr_dev(div1, "class", "name svelte-21fmj8");
    			add_location(div1, file$j, 173, 8, 5896);
    			attr_dev(img, "class", "creatorImg svelte-21fmj8");
    			if (!src_url_equal(img.src, img_src_value = /*creator*/ ctx[4].avatarUrl.replace(/^http:/, 'https:') + '?param=60y60')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$j, 175, 10, 5969);
    			attr_dev(span, "class", "creatertext svelte-21fmj8");
    			add_location(span, file$j, 176, 10, 6083);
    			attr_dev(div2, "class", "creater svelte-21fmj8");
    			add_location(div2, file$j, 174, 8, 5936);
    			attr_dev(div3, "class", "update svelte-21fmj8");
    			add_location(div3, file$j, 178, 8, 6160);
    			attr_dev(div4, "class", "info svelte-21fmj8");
    			add_location(div4, file$j, 172, 6, 5868);
    			attr_dev(div5, "class", "cover-bg svelte-21fmj8");
    			add_location(div5, file$j, 166, 4, 5642);
    			attr_dev(div6, "class", "cover-box svelte-21fmj8");
    			set_style(div6, "background", "url(" + (/*coverImgUrl*/ ctx[8].replace(/^http:/, 'https:') + '?param=450y450') + ")");
    			add_location(div6, file$j, 161, 2, 5486);
    			attr_dev(div7, "class", "desc svelte-21fmj8");
    			add_location(div7, file$j, 184, 2, 6316);
    			attr_dev(div8, "class", "play svelte-21fmj8");

    			set_style(div8, "margin-right", (/*$isLoginStore*/ ctx[10] && /*creator*/ ctx[4].userId != /*$userInfoStore*/ ctx[11].account.id
    			? 20
    			: 0) + "px");

    			add_location(div8, file$j, 186, 4, 6380);
    			attr_dev(div9, "class", "btn svelte-21fmj8");
    			add_location(div9, file$j, 185, 2, 6357);
    			add_location(div10, file$j, 209, 2, 7270);
    			attr_dev(div11, "class", "play-list svelte-21fmj8");
    			add_location(div11, file$j, 160, 0, 5459);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			mount_component(lazy, div0, null);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, t2);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div2, img);
    			append_dev(div2, t4);
    			append_dev(div2, span);
    			append_dev(span, t5);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			append_dev(div3, t7);
    			append_dev(div3, t8);
    			append_dev(div3, t9);
    			append_dev(div3, t10);
    			append_dev(div3, t11);
    			/*div6_binding*/ ctx[15](div6);
    			append_dev(div11, t12);
    			append_dev(div11, div7);
    			append_dev(div7, t13);
    			append_dev(div11, t14);
    			append_dev(div11, div9);
    			append_dev(div9, div8);
    			mount_component(button, div8, null);
    			append_dev(div9, t15);
    			if (if_block) if_block.m(div9, null);
    			append_dev(div11, t16);
    			append_dev(div11, div10);
    			mount_component(songlist, div10, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1, "scroll", /*scroll*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*title*/ 64) navbar_changes.title = /*title*/ ctx[6];
    			if (dirty & /*alphaNumber*/ 8) navbar_changes.alphaNumber = /*alphaNumber*/ ctx[3];
    			navbar.$set(navbar_changes);
    			const lazy_changes = {};

    			if (dirty & /*$$scope, coverImgUrl*/ 16777472) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);
    			if (!current || dirty & /*name*/ 128) set_data_dev(t2, /*name*/ ctx[7]);

    			if (!current || dirty & /*creator*/ 16 && !src_url_equal(img.src, img_src_value = /*creator*/ ctx[4].avatarUrl.replace(/^http:/, 'https:') + '?param=60y60')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*creator*/ 16) && t5_value !== (t5_value = /*creator*/ ctx[4].nickname + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*updateTime*/ 32) && t8_value !== (t8_value = formatTime(/*updateTime*/ ctx[5]) + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*songList*/ 4) && t10_value !== (t10_value = (/*songList*/ ctx[2] ? /*songList*/ ctx[2].length : 0) + "")) set_data_dev(t10, t10_value);

    			if (!current || dirty & /*coverImgUrl*/ 256) {
    				set_style(div6, "background", "url(" + (/*coverImgUrl*/ ctx[8].replace(/^http:/, 'https:') + '?param=450y450') + ")");
    			}

    			if (!current || dirty & /*description*/ 512) set_data_dev(t13, /*description*/ ctx[9]);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (!current || dirty & /*$isLoginStore, creator, $userInfoStore*/ 3088) {
    				set_style(div8, "margin-right", (/*$isLoginStore*/ ctx[10] && /*creator*/ ctx[4].userId != /*$userInfoStore*/ ctx[11].account.id
    				? 20
    				: 0) + "px");
    			}

    			if (/*$isLoginStore*/ ctx[10] && /*creator*/ ctx[4].userId != /*$userInfoStore*/ ctx[11].account.id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isLoginStore, creator, $userInfoStore*/ 3088) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div9, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const songlist_changes = {};
    			if (dirty & /*songList*/ 4) songlist_changes.songList = /*songList*/ ctx[2];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(lazy.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(lazy.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div11);
    			destroy_component(lazy);
    			/*div6_binding*/ ctx[15](null);
    			destroy_component(button);
    			if (if_block) if_block.d();
    			destroy_component(songlist);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let title;
    	let description;
    	let alphaNumber;
    	let songList;
    	let coverImgUrl;
    	let name;
    	let updateTime;
    	let creator;
    	let collect;
    	let $playListIdStore;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $isLoginStore;
    	let $defaultResumableStore;
    	let $userInfoStore;
    	validate_store(playListIdStore, 'playListIdStore');
    	component_subscribe($$self, playListIdStore, $$value => $$invalidate(17, $playListIdStore = $$value));
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(18, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(19, $currentPlayListStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(10, $isLoginStore = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(20, $defaultResumableStore = $$value));
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(11, $userInfoStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayListDetail', slots, []);
    	let coverDom;

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			$$invalidate(2, songList = []);

    			if ($isLoginStore) {
    				const ids = JSON.parse(localStorage.getItem('usePlayListIds'));
    				$$invalidate(1, collect = ids.includes($playListIdStore));
    			} else {
    				$$invalidate(1, collect = false);
    			}

    			getPlaylistDetailFun();
    		}
    	});

    	onMount(() => {
    		if ($isLoginStore) {
    			const ids = JSON.parse(localStorage.getItem('usePlayListIds'));
    			$$invalidate(1, collect = ids.includes($playListIdStore));
    		} else {
    			$$invalidate(1, collect = false);
    		}

    		getPlaylistDetailFun();
    	});

    	async function getPlaylistDetailFun() {
    		const res = await getPlaylistDetail($playListIdStore); //

    		if (res.code === 200) {
    			isLoadingStore.set(true);
    			let songIdList = [];

    			for (let i = 0; i < res.playlist.trackIds.length; i++) {
    				songIdList.push(res.playlist.trackIds[i].id);
    			}

    			$$invalidate(9, description = res.playlist.description ? res.playlist.description : '');
    			$$invalidate(8, coverImgUrl = res.playlist.coverImgUrl);
    			$$invalidate(7, name = $$invalidate(6, title = res.playlist.name));
    			$$invalidate(5, updateTime = res.playlist.updateTime);
    			$$invalidate(4, creator = res.playlist.creator);
    			let cutSongIdList = cutArray(songIdList);

    			for (let t = 0; t < cutSongIdList.length; t++) {
    				await getSongDetailFun(cutSongIdList[t].join(','));
    			}
    		}
    	}

    	async function getSongDetailFun(songIds) {
    		const res = await getSongDetail(songIds); //

    		if (res.code === 200) {
    			$$invalidate(2, songList = songList.concat(res.songs));
    		}
    	}

    	function scroll() {
    		const coverToTop = coverDom.getBoundingClientRect().top; //coverDomNavBar

    		if (coverToTop > -50 && coverToTop <= 0) {
    			$$invalidate(3, alphaNumber = Math.abs(coverToTop) / 50);
    		} else {
    			$$invalidate(3, alphaNumber = 1);
    		}

    		if (coverToTop > 0) {
    			$$invalidate(3, alphaNumber = 0);
    		}
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	function playListFun(index) {
    		playRepeatModelStore.set('repeat');
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentPlayListStore.set(songList);
    		let ids = [];

    		for (let r = 0; r < songList.length; r++) {
    			ids.push(songList[r].id);
    		}

    		localStorage.setItem('localPlayList', JSON.stringify(ids));
    		currentSongIndexStore.set(index);
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    	}

    	async function lovePlayListFun() {
    		const res = await subscribePlaylist({ id: $playListIdStore, t: collect ? 2 : 1 });

    		if (res.code === 200) {
    			const ids = JSON.parse(localStorage.getItem('usePlayListIds'));

    			if (collect) {
    				let i = ids.indexOf($playListIdStore);
    				ids.splice(i, 1);
    			} else {
    				ids.unshift($playListIdStore);
    			}

    			playListIdStore.set(ids);
    			localStorage.setItem('usePlayListIds', JSON.stringify(ids));
    			$$invalidate(1, collect = !collect);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayListDetail> was created with unknown prop '${key}'`);
    	});

    	function div6_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			coverDom = $$value;
    			$$invalidate(0, coverDom);
    		});
    	}

    	const BtnClick_handler = () => playListFun(0);

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		onResume,
    		PlayCircleLine,
    		ChatHeartFill,
    		ChatHeartLine,
    		Button,
    		NavBar,
    		SongList,
    		playListIdStore,
    		playListDetailStore,
    		isLoginStore,
    		isLoadingStore,
    		defaultResumableStore,
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		userInfoStore,
    		getPlaylistDetail,
    		subscribePlaylist,
    		getSongUrl,
    		getSongDetail,
    		formatTime,
    		Toast: Toast$1,
    		cutArray,
    		coverDom,
    		getPlaylistDetailFun,
    		getSongDetailFun,
    		scroll,
    		getSongUrlFun,
    		playListFun,
    		lovePlayListFun,
    		collect,
    		songList,
    		alphaNumber,
    		creator,
    		updateTime,
    		title,
    		name,
    		coverImgUrl,
    		description,
    		$playListIdStore,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$isLoginStore,
    		$defaultResumableStore,
    		$userInfoStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('coverDom' in $$props) $$invalidate(0, coverDom = $$props.coverDom);
    		if ('collect' in $$props) $$invalidate(1, collect = $$props.collect);
    		if ('songList' in $$props) $$invalidate(2, songList = $$props.songList);
    		if ('alphaNumber' in $$props) $$invalidate(3, alphaNumber = $$props.alphaNumber);
    		if ('creator' in $$props) $$invalidate(4, creator = $$props.creator);
    		if ('updateTime' in $$props) $$invalidate(5, updateTime = $$props.updateTime);
    		if ('title' in $$props) $$invalidate(6, title = $$props.title);
    		if ('name' in $$props) $$invalidate(7, name = $$props.name);
    		if ('coverImgUrl' in $$props) $$invalidate(8, coverImgUrl = $$props.coverImgUrl);
    		if ('description' in $$props) $$invalidate(9, description = $$props.description);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(6, title = '');
    	$$invalidate(9, description = '');
    	$$invalidate(3, alphaNumber = 0); //NavBar
    	$$invalidate(2, songList = []);
    	$$invalidate(8, coverImgUrl = '/images/defaultCover.png');
    	$$invalidate(7, name = '');
    	$$invalidate(5, updateTime = new Date().getTime());

    	$$invalidate(4, creator = {
    		nickname: '',
    		avatarUrl: '/images/defaultCover.png',
    		id: 0
    	});

    	$$invalidate(1, collect = false);

    	return [
    		coverDom,
    		collect,
    		songList,
    		alphaNumber,
    		creator,
    		updateTime,
    		title,
    		name,
    		coverImgUrl,
    		description,
    		$isLoginStore,
    		$userInfoStore,
    		scroll,
    		playListFun,
    		lovePlayListFun,
    		div6_binding,
    		BtnClick_handler
    	];
    }

    class PlayListDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayListDetail",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

    var core = createCommonjsModule$1(function (module, exports) {
    (function (root, factory) {
    	{
    		// CommonJS
    		module.exports = factory();
    	}
    }(commonjsGlobal$1, function () {

    	/*globals window, global, require*/

    	/**
    	 * CryptoJS core components.
    	 */
    	var CryptoJS = CryptoJS || (function (Math, undefined$1) {

    	    var crypto;

    	    // Native crypto from window (Browser)
    	    if (typeof window !== 'undefined' && window.crypto) {
    	        crypto = window.crypto;
    	    }

    	    // Native crypto in web worker (Browser)
    	    if (typeof self !== 'undefined' && self.crypto) {
    	        crypto = self.crypto;
    	    }

    	    // Native crypto from worker
    	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
    	        crypto = globalThis.crypto;
    	    }

    	    // Native (experimental IE 11) crypto from window (Browser)
    	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
    	        crypto = window.msCrypto;
    	    }

    	    // Native crypto from global (NodeJS)
    	    if (!crypto && typeof commonjsGlobal$1 !== 'undefined' && commonjsGlobal$1.crypto) {
    	        crypto = commonjsGlobal$1.crypto;
    	    }

    	    // Native crypto import via require (NodeJS)
    	    if (!crypto && typeof commonjsRequire === 'function') {
    	        try {
    	            crypto = require$$0;
    	        } catch (err) {}
    	    }

    	    /*
    	     * Cryptographically secure pseudorandom number generator
    	     *
    	     * As Math.random() is cryptographically not safe to use
    	     */
    	    var cryptoSecureRandomInt = function () {
    	        if (crypto) {
    	            // Use getRandomValues method (Browser)
    	            if (typeof crypto.getRandomValues === 'function') {
    	                try {
    	                    return crypto.getRandomValues(new Uint32Array(1))[0];
    	                } catch (err) {}
    	            }

    	            // Use randomBytes method (NodeJS)
    	            if (typeof crypto.randomBytes === 'function') {
    	                try {
    	                    return crypto.randomBytes(4).readInt32LE();
    	                } catch (err) {}
    	            }
    	        }

    	        throw new Error('Native crypto module could not be used to get secure random number.');
    	    };

    	    /*
    	     * Local polyfill of Object.create

    	     */
    	    var create = Object.create || (function () {
    	        function F() {}

    	        return function (obj) {
    	            var subtype;

    	            F.prototype = obj;

    	            subtype = new F();

    	            F.prototype = null;

    	            return subtype;
    	        };
    	    }());

    	    /**
    	     * CryptoJS namespace.
    	     */
    	    var C = {};

    	    /**
    	     * Library namespace.
    	     */
    	    var C_lib = C.lib = {};

    	    /**
    	     * Base object for prototypal inheritance.
    	     */
    	    var Base = C_lib.Base = (function () {


    	        return {
    	            /**
    	             * Creates a new object that inherits from this object.
    	             *
    	             * @param {Object} overrides Properties to copy into the new object.
    	             *
    	             * @return {Object} The new object.
    	             *
    	             * @static
    	             *
    	             * @example
    	             *
    	             *     var MyType = CryptoJS.lib.Base.extend({
    	             *         field: 'value',
    	             *
    	             *         method: function () {
    	             *         }
    	             *     });
    	             */
    	            extend: function (overrides) {
    	                // Spawn
    	                var subtype = create(this);

    	                // Augment
    	                if (overrides) {
    	                    subtype.mixIn(overrides);
    	                }

    	                // Create default initializer
    	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
    	                    subtype.init = function () {
    	                        subtype.$super.init.apply(this, arguments);
    	                    };
    	                }

    	                // Initializer's prototype is the subtype object
    	                subtype.init.prototype = subtype;

    	                // Reference supertype
    	                subtype.$super = this;

    	                return subtype;
    	            },

    	            /**
    	             * Extends this object and runs the init method.
    	             * Arguments to create() will be passed to init().
    	             *
    	             * @return {Object} The new object.
    	             *
    	             * @static
    	             *
    	             * @example
    	             *
    	             *     var instance = MyType.create();
    	             */
    	            create: function () {
    	                var instance = this.extend();
    	                instance.init.apply(instance, arguments);

    	                return instance;
    	            },

    	            /**
    	             * Initializes a newly created object.
    	             * Override this method to add some logic when your objects are created.
    	             *
    	             * @example
    	             *
    	             *     var MyType = CryptoJS.lib.Base.extend({
    	             *         init: function () {
    	             *             // ...
    	             *         }
    	             *     });
    	             */
    	            init: function () {
    	            },

    	            /**
    	             * Copies properties into this object.
    	             *
    	             * @param {Object} properties The properties to mix in.
    	             *
    	             * @example
    	             *
    	             *     MyType.mixIn({
    	             *         field: 'value'
    	             *     });
    	             */
    	            mixIn: function (properties) {
    	                for (var propertyName in properties) {
    	                    if (properties.hasOwnProperty(propertyName)) {
    	                        this[propertyName] = properties[propertyName];
    	                    }
    	                }

    	                // IE won't copy toString using the loop above
    	                if (properties.hasOwnProperty('toString')) {
    	                    this.toString = properties.toString;
    	                }
    	            },

    	            /**
    	             * Creates a copy of this object.
    	             *
    	             * @return {Object} The clone.
    	             *
    	             * @example
    	             *
    	             *     var clone = instance.clone();
    	             */
    	            clone: function () {
    	                return this.init.prototype.extend(this);
    	            }
    	        };
    	    }());

    	    /**
    	     * An array of 32-bit words.
    	     *
    	     * @property {Array} words The array of 32-bit words.
    	     * @property {number} sigBytes The number of significant bytes in this word array.
    	     */
    	    var WordArray = C_lib.WordArray = Base.extend({
    	        /**
    	         * Initializes a newly created word array.
    	         *
    	         * @param {Array} words (Optional) An array of 32-bit words.
    	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
    	         *
    	         * @example
    	         *
    	         *     var wordArray = CryptoJS.lib.WordArray.create();
    	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
    	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
    	         */
    	        init: function (words, sigBytes) {
    	            words = this.words = words || [];

    	            if (sigBytes != undefined$1) {
    	                this.sigBytes = sigBytes;
    	            } else {
    	                this.sigBytes = words.length * 4;
    	            }
    	        },

    	        /**
    	         * Converts this word array to a string.
    	         *
    	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
    	         *
    	         * @return {string} The stringified word array.
    	         *
    	         * @example
    	         *
    	         *     var string = wordArray + '';
    	         *     var string = wordArray.toString();
    	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
    	         */
    	        toString: function (encoder) {
    	            return (encoder || Hex).stringify(this);
    	        },

    	        /**
    	         * Concatenates a word array to this word array.
    	         *
    	         * @param {WordArray} wordArray The word array to append.
    	         *
    	         * @return {WordArray} This word array.
    	         *
    	         * @example
    	         *
    	         *     wordArray1.concat(wordArray2);
    	         */
    	        concat: function (wordArray) {
    	            // Shortcuts
    	            var thisWords = this.words;
    	            var thatWords = wordArray.words;
    	            var thisSigBytes = this.sigBytes;
    	            var thatSigBytes = wordArray.sigBytes;

    	            // Clamp excess bits
    	            this.clamp();

    	            // Concat
    	            if (thisSigBytes % 4) {
    	                // Copy one byte at a time
    	                for (var i = 0; i < thatSigBytes; i++) {
    	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
    	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
    	                }
    	            } else {
    	                // Copy one word at a time
    	                for (var j = 0; j < thatSigBytes; j += 4) {
    	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
    	                }
    	            }
    	            this.sigBytes += thatSigBytes;

    	            // Chainable
    	            return this;
    	        },

    	        /**
    	         * Removes insignificant bits.
    	         *
    	         * @example
    	         *
    	         *     wordArray.clamp();
    	         */
    	        clamp: function () {
    	            // Shortcuts
    	            var words = this.words;
    	            var sigBytes = this.sigBytes;

    	            // Clamp
    	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
    	            words.length = Math.ceil(sigBytes / 4);
    	        },

    	        /**
    	         * Creates a copy of this word array.
    	         *
    	         * @return {WordArray} The clone.
    	         *
    	         * @example
    	         *
    	         *     var clone = wordArray.clone();
    	         */
    	        clone: function () {
    	            var clone = Base.clone.call(this);
    	            clone.words = this.words.slice(0);

    	            return clone;
    	        },

    	        /**
    	         * Creates a word array filled with random bytes.
    	         *
    	         * @param {number} nBytes The number of random bytes to generate.
    	         *
    	         * @return {WordArray} The random word array.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
    	         */
    	        random: function (nBytes) {
    	            var words = [];

    	            for (var i = 0; i < nBytes; i += 4) {
    	                words.push(cryptoSecureRandomInt());
    	            }

    	            return new WordArray.init(words, nBytes);
    	        }
    	    });

    	    /**
    	     * Encoder namespace.
    	     */
    	    var C_enc = C.enc = {};

    	    /**
    	     * Hex encoding strategy.
    	     */
    	    var Hex = C_enc.Hex = {
    	        /**
    	         * Converts a word array to a hex string.
    	         *
    	         * @param {WordArray} wordArray The word array.
    	         *
    	         * @return {string} The hex string.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
    	         */
    	        stringify: function (wordArray) {
    	            // Shortcuts
    	            var words = wordArray.words;
    	            var sigBytes = wordArray.sigBytes;

    	            // Convert
    	            var hexChars = [];
    	            for (var i = 0; i < sigBytes; i++) {
    	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
    	                hexChars.push((bite >>> 4).toString(16));
    	                hexChars.push((bite & 0x0f).toString(16));
    	            }

    	            return hexChars.join('');
    	        },

    	        /**
    	         * Converts a hex string to a word array.
    	         *
    	         * @param {string} hexStr The hex string.
    	         *
    	         * @return {WordArray} The word array.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
    	         */
    	        parse: function (hexStr) {
    	            // Shortcut
    	            var hexStrLength = hexStr.length;

    	            // Convert
    	            var words = [];
    	            for (var i = 0; i < hexStrLength; i += 2) {
    	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
    	            }

    	            return new WordArray.init(words, hexStrLength / 2);
    	        }
    	    };

    	    /**
    	     * Latin1 encoding strategy.
    	     */
    	    var Latin1 = C_enc.Latin1 = {
    	        /**
    	         * Converts a word array to a Latin1 string.
    	         *
    	         * @param {WordArray} wordArray The word array.
    	         *
    	         * @return {string} The Latin1 string.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
    	         */
    	        stringify: function (wordArray) {
    	            // Shortcuts
    	            var words = wordArray.words;
    	            var sigBytes = wordArray.sigBytes;

    	            // Convert
    	            var latin1Chars = [];
    	            for (var i = 0; i < sigBytes; i++) {
    	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
    	                latin1Chars.push(String.fromCharCode(bite));
    	            }

    	            return latin1Chars.join('');
    	        },

    	        /**
    	         * Converts a Latin1 string to a word array.
    	         *
    	         * @param {string} latin1Str The Latin1 string.
    	         *
    	         * @return {WordArray} The word array.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
    	         */
    	        parse: function (latin1Str) {
    	            // Shortcut
    	            var latin1StrLength = latin1Str.length;

    	            // Convert
    	            var words = [];
    	            for (var i = 0; i < latin1StrLength; i++) {
    	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
    	            }

    	            return new WordArray.init(words, latin1StrLength);
    	        }
    	    };

    	    /**
    	     * UTF-8 encoding strategy.
    	     */
    	    var Utf8 = C_enc.Utf8 = {
    	        /**
    	         * Converts a word array to a UTF-8 string.
    	         *
    	         * @param {WordArray} wordArray The word array.
    	         *
    	         * @return {string} The UTF-8 string.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
    	         */
    	        stringify: function (wordArray) {
    	            try {
    	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
    	            } catch (e) {
    	                throw new Error('Malformed UTF-8 data');
    	            }
    	        },

    	        /**
    	         * Converts a UTF-8 string to a word array.
    	         *
    	         * @param {string} utf8Str The UTF-8 string.
    	         *
    	         * @return {WordArray} The word array.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
    	         */
    	        parse: function (utf8Str) {
    	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
    	        }
    	    };

    	    /**
    	     * Abstract buffered block algorithm template.
    	     *
    	     * The property blockSize must be implemented in a concrete subtype.
    	     *
    	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
    	     */
    	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
    	        /**
    	         * Resets this block algorithm's data buffer to its initial state.
    	         *
    	         * @example
    	         *
    	         *     bufferedBlockAlgorithm.reset();
    	         */
    	        reset: function () {
    	            // Initial values
    	            this._data = new WordArray.init();
    	            this._nDataBytes = 0;
    	        },

    	        /**
    	         * Adds new data to this block algorithm's buffer.
    	         *
    	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
    	         *
    	         * @example
    	         *
    	         *     bufferedBlockAlgorithm._append('data');
    	         *     bufferedBlockAlgorithm._append(wordArray);
    	         */
    	        _append: function (data) {
    	            // Convert string to WordArray, else assume WordArray already
    	            if (typeof data == 'string') {
    	                data = Utf8.parse(data);
    	            }

    	            // Append
    	            this._data.concat(data);
    	            this._nDataBytes += data.sigBytes;
    	        },

    	        /**
    	         * Processes available data blocks.
    	         *
    	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
    	         *
    	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
    	         *
    	         * @return {WordArray} The processed data.
    	         *
    	         * @example
    	         *
    	         *     var processedData = bufferedBlockAlgorithm._process();
    	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
    	         */
    	        _process: function (doFlush) {
    	            var processedWords;

    	            // Shortcuts
    	            var data = this._data;
    	            var dataWords = data.words;
    	            var dataSigBytes = data.sigBytes;
    	            var blockSize = this.blockSize;
    	            var blockSizeBytes = blockSize * 4;

    	            // Count blocks ready
    	            var nBlocksReady = dataSigBytes / blockSizeBytes;
    	            if (doFlush) {
    	                // Round up to include partial blocks
    	                nBlocksReady = Math.ceil(nBlocksReady);
    	            } else {
    	                // Round down to include only full blocks,
    	                // less the number of blocks that must remain in the buffer
    	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    	            }

    	            // Count words ready
    	            var nWordsReady = nBlocksReady * blockSize;

    	            // Count bytes ready
    	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

    	            // Process blocks
    	            if (nWordsReady) {
    	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
    	                    // Perform concrete-algorithm logic
    	                    this._doProcessBlock(dataWords, offset);
    	                }

    	                // Remove processed words
    	                processedWords = dataWords.splice(0, nWordsReady);
    	                data.sigBytes -= nBytesReady;
    	            }

    	            // Return processed words
    	            return new WordArray.init(processedWords, nBytesReady);
    	        },

    	        /**
    	         * Creates a copy of this object.
    	         *
    	         * @return {Object} The clone.
    	         *
    	         * @example
    	         *
    	         *     var clone = bufferedBlockAlgorithm.clone();
    	         */
    	        clone: function () {
    	            var clone = Base.clone.call(this);
    	            clone._data = this._data.clone();

    	            return clone;
    	        },

    	        _minBufferSize: 0
    	    });

    	    /**
    	     * Abstract hasher template.
    	     *
    	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
    	     */
    	    C_lib.Hasher = BufferedBlockAlgorithm.extend({
    	        /**
    	         * Configuration options.
    	         */
    	        cfg: Base.extend(),

    	        /**
    	         * Initializes a newly created hasher.
    	         *
    	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
    	         *
    	         * @example
    	         *
    	         *     var hasher = CryptoJS.algo.SHA256.create();
    	         */
    	        init: function (cfg) {
    	            // Apply config defaults
    	            this.cfg = this.cfg.extend(cfg);

    	            // Set initial values
    	            this.reset();
    	        },

    	        /**
    	         * Resets this hasher to its initial state.
    	         *
    	         * @example
    	         *
    	         *     hasher.reset();
    	         */
    	        reset: function () {
    	            // Reset data buffer
    	            BufferedBlockAlgorithm.reset.call(this);

    	            // Perform concrete-hasher logic
    	            this._doReset();
    	        },

    	        /**
    	         * Updates this hasher with a message.
    	         *
    	         * @param {WordArray|string} messageUpdate The message to append.
    	         *
    	         * @return {Hasher} This hasher.
    	         *
    	         * @example
    	         *
    	         *     hasher.update('message');
    	         *     hasher.update(wordArray);
    	         */
    	        update: function (messageUpdate) {
    	            // Append
    	            this._append(messageUpdate);

    	            // Update the hash
    	            this._process();

    	            // Chainable
    	            return this;
    	        },

    	        /**
    	         * Finalizes the hash computation.
    	         * Note that the finalize operation is effectively a destructive, read-once operation.
    	         *
    	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
    	         *
    	         * @return {WordArray} The hash.
    	         *
    	         * @example
    	         *
    	         *     var hash = hasher.finalize();
    	         *     var hash = hasher.finalize('message');
    	         *     var hash = hasher.finalize(wordArray);
    	         */
    	        finalize: function (messageUpdate) {
    	            // Final message update
    	            if (messageUpdate) {
    	                this._append(messageUpdate);
    	            }

    	            // Perform concrete-hasher logic
    	            var hash = this._doFinalize();

    	            return hash;
    	        },

    	        blockSize: 512/32,

    	        /**
    	         * Creates a shortcut function to a hasher's object interface.
    	         *
    	         * @param {Hasher} hasher The hasher to create a helper for.
    	         *
    	         * @return {Function} The shortcut function.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
    	         */
    	        _createHelper: function (hasher) {
    	            return function (message, cfg) {
    	                return new hasher.init(cfg).finalize(message);
    	            };
    	        },

    	        /**
    	         * Creates a shortcut function to the HMAC's object interface.
    	         *
    	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
    	         *
    	         * @return {Function} The shortcut function.
    	         *
    	         * @static
    	         *
    	         * @example
    	         *
    	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
    	         */
    	        _createHmacHelper: function (hasher) {
    	            return function (message, key) {
    	                return new C_algo.HMAC.init(hasher, key).finalize(message);
    	            };
    	        }
    	    });

    	    /**
    	     * Algorithm namespace.
    	     */
    	    var C_algo = C.algo = {};

    	    return C;
    	}(Math));


    	return CryptoJS;

    }));
    });

    var md5 = createCommonjsModule$1(function (module, exports) {
    (function (root, factory) {
    	{
    		// CommonJS
    		module.exports = factory(core);
    	}
    }(commonjsGlobal$1, function (CryptoJS) {

    	(function (Math) {
    	    // Shortcuts
    	    var C = CryptoJS;
    	    var C_lib = C.lib;
    	    var WordArray = C_lib.WordArray;
    	    var Hasher = C_lib.Hasher;
    	    var C_algo = C.algo;

    	    // Constants table
    	    var T = [];

    	    // Compute constants
    	    (function () {
    	        for (var i = 0; i < 64; i++) {
    	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
    	        }
    	    }());

    	    /**
    	     * MD5 hash algorithm.
    	     */
    	    var MD5 = C_algo.MD5 = Hasher.extend({
    	        _doReset: function () {
    	            this._hash = new WordArray.init([
    	                0x67452301, 0xefcdab89,
    	                0x98badcfe, 0x10325476
    	            ]);
    	        },

    	        _doProcessBlock: function (M, offset) {
    	            // Swap endian
    	            for (var i = 0; i < 16; i++) {
    	                // Shortcuts
    	                var offset_i = offset + i;
    	                var M_offset_i = M[offset_i];

    	                M[offset_i] = (
    	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
    	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
    	                );
    	            }

    	            // Shortcuts
    	            var H = this._hash.words;

    	            var M_offset_0  = M[offset + 0];
    	            var M_offset_1  = M[offset + 1];
    	            var M_offset_2  = M[offset + 2];
    	            var M_offset_3  = M[offset + 3];
    	            var M_offset_4  = M[offset + 4];
    	            var M_offset_5  = M[offset + 5];
    	            var M_offset_6  = M[offset + 6];
    	            var M_offset_7  = M[offset + 7];
    	            var M_offset_8  = M[offset + 8];
    	            var M_offset_9  = M[offset + 9];
    	            var M_offset_10 = M[offset + 10];
    	            var M_offset_11 = M[offset + 11];
    	            var M_offset_12 = M[offset + 12];
    	            var M_offset_13 = M[offset + 13];
    	            var M_offset_14 = M[offset + 14];
    	            var M_offset_15 = M[offset + 15];

    	            // Working varialbes
    	            var a = H[0];
    	            var b = H[1];
    	            var c = H[2];
    	            var d = H[3];

    	            // Computation
    	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
    	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
    	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
    	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
    	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
    	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
    	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
    	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
    	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
    	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
    	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
    	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
    	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
    	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
    	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
    	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

    	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
    	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
    	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
    	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
    	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
    	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
    	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
    	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
    	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
    	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
    	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
    	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
    	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
    	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
    	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
    	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

    	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
    	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
    	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
    	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
    	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
    	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
    	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
    	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
    	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
    	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
    	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
    	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
    	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
    	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
    	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
    	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

    	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
    	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
    	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
    	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
    	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
    	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
    	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
    	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
    	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
    	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
    	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
    	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
    	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
    	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
    	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
    	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

    	            // Intermediate hash value
    	            H[0] = (H[0] + a) | 0;
    	            H[1] = (H[1] + b) | 0;
    	            H[2] = (H[2] + c) | 0;
    	            H[3] = (H[3] + d) | 0;
    	        },

    	        _doFinalize: function () {
    	            // Shortcuts
    	            var data = this._data;
    	            var dataWords = data.words;

    	            var nBitsTotal = this._nDataBytes * 8;
    	            var nBitsLeft = data.sigBytes * 8;

    	            // Add padding
    	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

    	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
    	            var nBitsTotalL = nBitsTotal;
    	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
    	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
    	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
    	            );
    	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
    	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
    	            );

    	            data.sigBytes = (dataWords.length + 1) * 4;

    	            // Hash final blocks
    	            this._process();

    	            // Shortcuts
    	            var hash = this._hash;
    	            var H = hash.words;

    	            // Swap endian
    	            for (var i = 0; i < 4; i++) {
    	                // Shortcut
    	                var H_i = H[i];

    	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
    	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
    	            }

    	            // Return final computed hash
    	            return hash;
    	        },

    	        clone: function () {
    	            var clone = Hasher.clone.call(this);
    	            clone._hash = this._hash.clone();

    	            return clone;
    	        }
    	    });

    	    function FF(a, b, c, d, x, s, t) {
    	        var n = a + ((b & c) | (~b & d)) + x + t;
    	        return ((n << s) | (n >>> (32 - s))) + b;
    	    }

    	    function GG(a, b, c, d, x, s, t) {
    	        var n = a + ((b & d) | (c & ~d)) + x + t;
    	        return ((n << s) | (n >>> (32 - s))) + b;
    	    }

    	    function HH(a, b, c, d, x, s, t) {
    	        var n = a + (b ^ c ^ d) + x + t;
    	        return ((n << s) | (n >>> (32 - s))) + b;
    	    }

    	    function II(a, b, c, d, x, s, t) {
    	        var n = a + (c ^ (b | ~d)) + x + t;
    	        return ((n << s) | (n >>> (32 - s))) + b;
    	    }

    	    /**
    	     * Shortcut function to the hasher's object interface.
    	     *
    	     * @param {WordArray|string} message The message to hash.
    	     *
    	     * @return {WordArray} The hash.
    	     *
    	     * @static
    	     *
    	     * @example
    	     *
    	     *     var hash = CryptoJS.MD5('message');
    	     *     var hash = CryptoJS.MD5(wordArray);
    	     */
    	    C.MD5 = Hasher._createHelper(MD5);

    	    /**
    	     * Shortcut function to the HMAC's object interface.
    	     *
    	     * @param {WordArray|string} message The message to hash.
    	     * @param {WordArray|string} key The secret key.
    	     *
    	     * @return {WordArray} The HMAC.
    	     *
    	     * @static
    	     *
    	     * @example
    	     *
    	     *     var hmac = CryptoJS.HmacMD5(message, key);
    	     */
    	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
    	}(Math));


    	return CryptoJS.MD5;

    }));
    });

    var qrcode = createCommonjsModule$1(function (module, exports) {
    /*
     * QRious v4.0.2
     * Copyright (C) 2017 Alasdair Mercer
     * Copyright (C) 2010 Tom Zerucha
     *
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     */
    (function (global, factory) {
        module.exports = factory() ;
      }(commonjsGlobal$1, (function () {  
        /*
         * Copyright (C) 2017 Alasdair Mercer, !ninja
         *
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:
         *
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         * SOFTWARE.
         */
      
        /**
         * A bare-bones constructor for surrogate prototype swapping.
         *
         * @private
         * @constructor
         */
        var Constructor = /* istanbul ignore next */ function() {};
        /**
         * A reference to <code>Object.prototype.hasOwnProperty</code>.
         *
         * @private
         * @type {Function}
         */
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        /**
         * A reference to <code>Array.prototype.slice</code>.
         *
         * @private
         * @type {Function}
         */
        var slice = Array.prototype.slice;
      
        /**
         * Creates an object which inherits the given <code>prototype</code>.
         *
         * Optionally, the created object can be extended further with the specified <code>properties</code>.
         *
         * @param {Object} prototype - the prototype to be inherited by the created object
         * @param {Object} [properties] - the optional properties to be extended by the created object
         * @return {Object} The newly created object.
         * @private
         */
        function createObject(prototype, properties) {
          var result;
          /* istanbul ignore next */
          if (typeof Object.create === 'function') {
            result = Object.create(prototype);
          } else {
            Constructor.prototype = prototype;
            result = new Constructor();
            Constructor.prototype = null;
          }
      
          if (properties) {
            extendObject(true, result, properties);
          }
      
          return result;
        }
      
        /**
         * Extends the constructor to which this method is associated with the <code>prototype</code> and/or
         * <code>statics</code> provided.
         *
         * If <code>name</code> is provided, it will be used as the class name and can be accessed via a special
         * <code>class_</code> property on the child constructor, otherwise the class name of the super constructor will be used
         * instead. The class name may also be used string representation for instances of the child constructor (via
         * <code>toString</code>), but this is not applicable to the <i>lite</i> version of Nevis.
         *
         * If <code>constructor</code> is provided, it will be used as the constructor for the child, otherwise a simple
         * constructor which only calls the super constructor will be used instead.
         *
         * The super constructor can be accessed via a special <code>super_</code> property on the child constructor.
         *
         * @param {string} [name=this.class_] - the class name to be used for the child constructor
         * @param {Function} [constructor] - the constructor for the child
         * @param {Object} [prototype] - the prototype properties to be defined for the child
         * @param {Object} [statics] - the static properties to be defined for the child
         * @return {Function} The child <code>constructor</code> provided or the one created if none was given.
         * @public
         */
        function extend(name, constructor, prototype, statics) {
          var superConstructor = this;
      
          if (typeof name !== 'string') {
            statics = prototype;
            prototype = constructor;
            constructor = name;
            name = null;
          }
      
          if (typeof constructor !== 'function') {
            statics = prototype;
            prototype = constructor;
            constructor = function() {
              return superConstructor.apply(this, arguments);
            };
          }
      
          extendObject(false, constructor, superConstructor, statics);
      
          constructor.prototype = createObject(superConstructor.prototype, prototype);
          constructor.prototype.constructor = constructor;
      
          constructor.class_ = name || superConstructor.class_;
          constructor.super_ = superConstructor;
      
          return constructor;
        }
      
        /**
         * Extends the specified <code>target</code> object with the properties in each of the <code>sources</code> provided.
         *
         * if any source is <code>null</code> it will be ignored.
         *
         * @param {boolean} own - <code>true</code> to only copy <b>own</b> properties from <code>sources</code> onto
         * <code>target</code>; otherwise <code>false</code>
         * @param {Object} target - the target object which should be extended
         * @param {...Object} [sources] - the source objects whose properties are to be copied onto <code>target</code>
         * @return {void}
         * @private
         */
        function extendObject(own, target, sources) {
          sources = slice.call(arguments, 2);
      
          var property;
          var source;
      
          for (var i = 0, length = sources.length; i < length; i++) {
            source = sources[i];
      
            for (property in source) {
              if (!own || hasOwnProperty.call(source, property)) {
                target[property] = source[property];
              }
            }
          }
        }
      
        var extend_1 = extend;
      
        /**
         * The base class from which all others should extend.
         *
         * @public
         * @constructor
         */
        function Nevis() {}
        Nevis.class_ = 'Nevis';
        Nevis.super_ = Object;
      
        /**
         * Extends the constructor to which this method is associated with the <code>prototype</code> and/or
         * <code>statics</code> provided.
         *
         * If <code>name</code> is provided, it will be used as the class name and can be accessed via a special
         * <code>class_</code> property on the child constructor, otherwise the class name of the super constructor will be used
         * instead. The class name may also be used string representation for instances of the child constructor (via
         * <code>toString</code>), but this is not applicable to the <i>lite</i> version of Nevis.
         *
         * If <code>constructor</code> is provided, it will be used as the constructor for the child, otherwise a simple
         * constructor which only calls the super constructor will be used instead.
         *
         * The super constructor can be accessed via a special <code>super_</code> property on the child constructor.
         *
         * @param {string} [name=this.class_] - the class name to be used for the child constructor
         * @param {Function} [constructor] - the constructor for the child
         * @param {Object} [prototype] - the prototype properties to be defined for the child
         * @param {Object} [statics] - the static properties to be defined for the child
         * @return {Function} The child <code>constructor</code> provided or the one created if none was given.
         * @public
         * @static
         * @memberof Nevis
         */
        Nevis.extend = extend_1;
      
        var nevis = Nevis;
      
        var lite = nevis;
      
        /**
         * Responsible for rendering a QR code {@link Frame} on a specific type of element.
         *
         * A renderer may be dependant on the rendering of another element, so the ordering of their execution is important.
         *
         * The rendering of a element can be deferred by disabling the renderer initially, however, any attempt get the element
         * from the renderer will result in it being immediately enabled and the element being rendered.
         *
         * @param {QRious} qrious - the {@link QRious} instance to be used
         * @param {*} element - the element onto which the QR code is to be rendered
         * @param {boolean} [enabled] - <code>true</code> this {@link Renderer} is enabled; otherwise <code>false</code>.
         * @public
         * @class
         * @extends Nevis
         */
        var Renderer = lite.extend(function(qrious, element, enabled) {
          /**
           * The {@link QRious} instance.
           *
           * @protected
           * @type {QRious}
           * @memberof Renderer#
           */
          this.qrious = qrious;
      
          /**
           * The element onto which this {@link Renderer} is rendering the QR code.
           *
           * @protected
           * @type {*}
           * @memberof Renderer#
           */
          this.element = element;
          this.element.qrious = qrious;
      
          /**
           * Whether this {@link Renderer} is enabled.
           *
           * @protected
           * @type {boolean}
           * @memberof Renderer#
           */
          this.enabled = Boolean(enabled);
        }, {
      
          /**
           * Draws the specified QR code <code>frame</code> on the underlying element.
           *
           * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
           *
           * @param {Frame} frame - the {@link Frame} to be drawn
           * @return {void}
           * @protected
           * @abstract
           * @memberof Renderer#
           */
          draw: function(frame) {},
      
          /**
           * Returns the element onto which this {@link Renderer} is rendering the QR code.
           *
           * If this method is called while this {@link Renderer} is disabled, it will be immediately enabled and rendered
           * before the element is returned.
           *
           * @return {*} The element.
           * @public
           * @memberof Renderer#
           */
          getElement: function() {
            if (!this.enabled) {
              this.enabled = true;
              this.render();
            }
      
            return this.element;
          },
      
          /**
           * Calculates the size (in pixel units) to represent an individual module within the QR code based on the
           * <code>frame</code> provided.
           *
           * Any configured padding will be excluded from the returned size.
           *
           * The returned value will be at least one, even in cases where the size of the QR code does not fit its contents.
           * This is done so that the inevitable clipping is handled more gracefully since this way at least something is
           * displayed instead of just a blank space filled by the background color.
           *
           * @param {Frame} frame - the {@link Frame} from which the module size is to be derived
           * @return {number} The pixel size for each module in the QR code which will be no less than one.
           * @protected
           * @memberof Renderer#
           */
          getModuleSize: function(frame) {
            var qrious = this.qrious;
            var padding = qrious.padding || 0;
            var pixels = Math.floor((qrious.size - (padding * 2)) / frame.width);
      
            return Math.max(1, pixels);
          },

          /**
           * Renders a QR code on the underlying element based on the <code>frame</code> provided.
           *
           * @param {Frame} frame - the {@link Frame} to be rendered
           * @return {void}
           * @public
           * @memberof Renderer#
           */
          render: function(frame) {
            if (this.enabled) {
              this.resize();
              this.reset();
              this.draw(frame);
            }
          },
      
          /**
           * Resets the underlying element, effectively clearing any previously rendered QR code.
           *
           * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
           *
           * @return {void}
           * @protected
           * @abstract
           * @memberof Renderer#
           */
          reset: function() {},
      
          /**
           * Ensures that the size of the underlying element matches that defined on the associated {@link QRious} instance.
           *
           * Implementations of {@link Renderer} <b>must</b> override this method with their own specific logic.
           *
           * @return {void}
           * @protected
           * @abstract
           * @memberof Renderer#
           */
          resize: function() {}
      
        });
      
        var Renderer_1 = Renderer;
      
        /**
         * An implementation of {@link Renderer} for working with <code>canvas</code> elements.
         *
         * @public
         * @class
         * @extends Renderer
         */
        var CanvasRenderer = Renderer_1.extend({
      
          /**
           * @override
           */
          draw: function(frame) {
            var i, j;
            var qrious = this.qrious;
            var moduleSize = this.getModuleSize(frame);
            var offset = parseInt((this.element.width-(frame.width * moduleSize)) / 2);
            var context = this.element.getContext('2d');
      
            context.fillStyle = qrious.foreground;
            context.globalAlpha = qrious.foregroundAlpha;
      
            for (i = 0; i < frame.width; i++) {
              for (j = 0; j < frame.width; j++) {
                if (frame.buffer[(j * frame.width) + i]) {
                  context.fillRect((moduleSize * i) + offset, (moduleSize * j) + offset, moduleSize, moduleSize);
                }
              }
            }
          },
      
          /**
           * @override
           */
          reset: function() {
            var qrious = this.qrious;
            var context = this.element.getContext('2d');
            var size = qrious.size;
      
            context.lineWidth = 1;
            context.clearRect(0, 0, size, size);
            context.fillStyle = qrious.background;
            context.globalAlpha = qrious.backgroundAlpha;
            context.fillRect(0, 0, size, size);
          },
      
          /**
           * @override
           */
          resize: function() {
            var element = this.element;
      
            element.width = element.height = this.qrious.size;
          }
      
        });
      
        var CanvasRenderer_1 = CanvasRenderer;
      
        /* eslint no-multi-spaces: "off" */
      
      
      
        /**
         * Contains alignment pattern information.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var Alignment = lite.extend(null, {
      
          /**
           * The alignment pattern block.
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof Alignment
           */
          BLOCK: [
            0,  11, 15, 19, 23, 27, 31,
            16, 18, 20, 22, 24, 26, 28, 20, 22, 24, 24, 26, 28, 28, 22, 24, 24,
            26, 26, 28, 28, 24, 24, 26, 26, 26, 28, 28, 24, 26, 26, 26, 28, 28
          ]
      
        });
      
        var Alignment_1 = Alignment;
      
        /* eslint no-multi-spaces: "off" */
      
      
      
        /**
         * Contains error correction information.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var ErrorCorrection = lite.extend(null, {
      
          /**
           * The error correction blocks.
           *
           * There are four elements per version. The first two indicate the number of blocks, then the data width, and finally
           * the ECC width.
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof ErrorCorrection
           */
          BLOCKS: [
            1,  0,  19,  7,     1,  0,  16,  10,    1,  0,  13,  13,    1,  0,  9,   17,
            1,  0,  34,  10,    1,  0,  28,  16,    1,  0,  22,  22,    1,  0,  16,  28,
            1,  0,  55,  15,    1,  0,  44,  26,    2,  0,  17,  18,    2,  0,  13,  22,
            1,  0,  80,  20,    2,  0,  32,  18,    2,  0,  24,  26,    4,  0,  9,   16,
            1,  0,  108, 26,    2,  0,  43,  24,    2,  2,  15,  18,    2,  2,  11,  22,
            2,  0,  68,  18,    4,  0,  27,  16,    4,  0,  19,  24,    4,  0,  15,  28,
            2,  0,  78,  20,    4,  0,  31,  18,    2,  4,  14,  18,    4,  1,  13,  26,
            2,  0,  97,  24,    2,  2,  38,  22,    4,  2,  18,  22,    4,  2,  14,  26,
            2,  0,  116, 30,    3,  2,  36,  22,    4,  4,  16,  20,    4,  4,  12,  24,
            2,  2,  68,  18,    4,  1,  43,  26,    6,  2,  19,  24,    6,  2,  15,  28,
            4,  0,  81,  20,    1,  4,  50,  30,    4,  4,  22,  28,    3,  8,  12,  24,
            2,  2,  92,  24,    6,  2,  36,  22,    4,  6,  20,  26,    7,  4,  14,  28,
            4,  0,  107, 26,    8,  1,  37,  22,    8,  4,  20,  24,    12, 4,  11,  22,
            3,  1,  115, 30,    4,  5,  40,  24,    11, 5,  16,  20,    11, 5,  12,  24,
            5,  1,  87,  22,    5,  5,  41,  24,    5,  7,  24,  30,    11, 7,  12,  24,
            5,  1,  98,  24,    7,  3,  45,  28,    15, 2,  19,  24,    3,  13, 15,  30,
            1,  5,  107, 28,    10, 1,  46,  28,    1,  15, 22,  28,    2,  17, 14,  28,
            5,  1,  120, 30,    9,  4,  43,  26,    17, 1,  22,  28,    2,  19, 14,  28,
            3,  4,  113, 28,    3,  11, 44,  26,    17, 4,  21,  26,    9,  16, 13,  26,
            3,  5,  107, 28,    3,  13, 41,  26,    15, 5,  24,  30,    15, 10, 15,  28,
            4,  4,  116, 28,    17, 0,  42,  26,    17, 6,  22,  28,    19, 6,  16,  30,
            2,  7,  111, 28,    17, 0,  46,  28,    7,  16, 24,  30,    34, 0,  13,  24,
            4,  5,  121, 30,    4,  14, 47,  28,    11, 14, 24,  30,    16, 14, 15,  30,
            6,  4,  117, 30,    6,  14, 45,  28,    11, 16, 24,  30,    30, 2,  16,  30,
            8,  4,  106, 26,    8,  13, 47,  28,    7,  22, 24,  30,    22, 13, 15,  30,
            10, 2,  114, 28,    19, 4,  46,  28,    28, 6,  22,  28,    33, 4,  16,  30,
            8,  4,  122, 30,    22, 3,  45,  28,    8,  26, 23,  30,    12, 28, 15,  30,
            3,  10, 117, 30,    3,  23, 45,  28,    4,  31, 24,  30,    11, 31, 15,  30,
            7,  7,  116, 30,    21, 7,  45,  28,    1,  37, 23,  30,    19, 26, 15,  30,
            5,  10, 115, 30,    19, 10, 47,  28,    15, 25, 24,  30,    23, 25, 15,  30,
            13, 3,  115, 30,    2,  29, 46,  28,    42, 1,  24,  30,    23, 28, 15,  30,
            17, 0,  115, 30,    10, 23, 46,  28,    10, 35, 24,  30,    19, 35, 15,  30,
            17, 1,  115, 30,    14, 21, 46,  28,    29, 19, 24,  30,    11, 46, 15,  30,
            13, 6,  115, 30,    14, 23, 46,  28,    44, 7,  24,  30,    59, 1,  16,  30,
            12, 7,  121, 30,    12, 26, 47,  28,    39, 14, 24,  30,    22, 41, 15,  30,
            6,  14, 121, 30,    6,  34, 47,  28,    46, 10, 24,  30,    2,  64, 15,  30,
            17, 4,  122, 30,    29, 14, 46,  28,    49, 10, 24,  30,    24, 46, 15,  30,
            4,  18, 122, 30,    13, 32, 46,  28,    48, 14, 24,  30,    42, 32, 15,  30,
            20, 4,  117, 30,    40, 7,  47,  28,    43, 22, 24,  30,    10, 67, 15,  30,
            19, 6,  118, 30,    18, 31, 47,  28,    34, 34, 24,  30,    20, 61, 15,  30
          ],
      
          /**
           * The final format bits with mask (level << 3 | mask).
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof ErrorCorrection
           */
          FINAL_FORMAT: [
            // L
            0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976,
            // M
            0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0,
            // Q
            0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed,
            // H
            0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b
          ],
      
          /**
           * A map of human-readable ECC levels.
           *
           * @public
           * @static
           * @type {Object.<string, number>}
           * @memberof ErrorCorrection
           */
          LEVELS: {
            L: 1,
            M: 2,
            Q: 3,
            H: 4
          }
      
        });
      
        var ErrorCorrection_1 = ErrorCorrection;
      
        /**
         * Contains Galois field information.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var Galois = lite.extend(null, {
      
          /**
           * The Galois field exponent table.
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof Galois
           */
          EXPONENT: [
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
            0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
            0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
            0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
            0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
            0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
            0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
            0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
            0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
            0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
            0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
            0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
            0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
            0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
            0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
            0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x00
          ],
      
          /**
           * The Galois field log table.
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof Galois
           */
          LOG: [
            0xff, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,
            0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,
            0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,
            0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9, 0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,
            0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd, 0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,
            0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,
            0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,
            0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,
            0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,
            0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,
            0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,
            0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,
            0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,
            0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa, 0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,
            0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,
            0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf
          ]
      
        });
      
        var Galois_1 = Galois;
      
        /**
         * Contains version pattern information.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var Version = lite.extend(null, {
      
          /**
           * The version pattern block.
           *
           * @public
           * @static
           * @type {number[]}
           * @memberof Version
           */
          BLOCK: [
            0xc94, 0x5bc, 0xa99, 0x4d3, 0xbf6, 0x762, 0x847, 0x60d, 0x928, 0xb78, 0x45d, 0xa17, 0x532,
            0x9a6, 0x683, 0x8c9, 0x7ec, 0xec4, 0x1e1, 0xfab, 0x08e, 0xc1a, 0x33f, 0xd75, 0x250, 0x9d5,
            0x6f0, 0x8ba, 0x79f, 0xb0b, 0x42e, 0xa64, 0x541, 0xc69
          ]
      
        });
      
        var Version_1 = Version;
      
        /**
         * Generates information for a QR code frame based on a specific value to be encoded.
         *
         * @param {Frame~Options} options - the options to be used
         * @public
         * @class
         * @extends Nevis
         */
        var Frame = lite.extend(function(options) {
          var dataBlock, eccBlock, index, neccBlock1, neccBlock2;
          var valueLength = options.value.length;
      
          this._badness = [];
          this._level = ErrorCorrection_1.LEVELS[options.level];
          this._polynomial = [];
          this._value = options.value;
          this._version = 0;
          this._stringBuffer = [];
      
          while (this._version < 40) {
            this._version++;
      
            index = ((this._level - 1) * 4) + ((this._version - 1) * 16);
      
            neccBlock1 = ErrorCorrection_1.BLOCKS[index++];
            neccBlock2 = ErrorCorrection_1.BLOCKS[index++];
            dataBlock = ErrorCorrection_1.BLOCKS[index++];
            eccBlock = ErrorCorrection_1.BLOCKS[index];
      
            index = (dataBlock * (neccBlock1 + neccBlock2)) + neccBlock2 - 3 + (this._version <= 9);
      
            if (valueLength <= index) {
              break;
            }
          }
      
          this._dataBlock = dataBlock;
          this._eccBlock = eccBlock;
          this._neccBlock1 = neccBlock1;
          this._neccBlock2 = neccBlock2;
      
          /**
           * The data width is based on version.
           *
           * @public
           * @type {number}
           * @memberof Frame#
           */
          // FIXME: Ensure that it fits instead of being truncated.
          var width = this.width = 17 + (4 * this._version);
      
          /**
           * The image buffer.
           *
           * @public
           * @type {number[]}
           * @memberof Frame#
           */
          this.buffer = Frame._createArray(width * width);
      
          this._ecc = Frame._createArray(dataBlock + ((dataBlock + eccBlock) * (neccBlock1 + neccBlock2)) + neccBlock2);
          this._mask = Frame._createArray(((width * (width + 1)) + 1) / 2);
      
          this._insertFinders();
          this._insertAlignments();
      
          // Insert single foreground cell.
          this.buffer[8 + (width * (width - 8))] = 1;
      
          this._insertTimingGap();
          this._reverseMask();
          this._insertTimingRowAndColumn();
          this._insertVersion();
          this._syncMask();
          this._convertBitStream(valueLength);
          this._calculatePolynomial();
          this._appendEccToData();
          this._interleaveBlocks();
          this._pack();
          this._finish();
        }, {
      
          _addAlignment: function(x, y) {
            var i;
            var buffer = this.buffer;
            var width = this.width;
      
            buffer[x + (width * y)] = 1;
      
            for (i = -2; i < 2; i++) {
              buffer[x + i + (width * (y - 2))] = 1;
              buffer[x - 2 + (width * (y + i + 1))] = 1;
              buffer[x + 2 + (width * (y + i))] = 1;
              buffer[x + i + 1 + (width * (y + 2))] = 1;
            }
      
            for (i = 0; i < 2; i++) {
              this._setMask(x - 1, y + i);
              this._setMask(x + 1, y - i);
              this._setMask(x - i, y - 1);
              this._setMask(x + i, y + 1);
            }
          },
      
          _appendData: function(data, dataLength, ecc, eccLength) {
            var bit, i, j;
            var polynomial = this._polynomial;
            var stringBuffer = this._stringBuffer;
      
            for (i = 0; i < eccLength; i++) {
              stringBuffer[ecc + i] = 0;
            }
      
            for (i = 0; i < dataLength; i++) {
              bit = Galois_1.LOG[stringBuffer[data + i] ^ stringBuffer[ecc]];
      
              if (bit !== 255) {
                for (j = 1; j < eccLength; j++) {
                  stringBuffer[ecc + j - 1] = stringBuffer[ecc + j] ^
                    Galois_1.EXPONENT[Frame._modN(bit + polynomial[eccLength - j])];
                }
              } else {
                for (j = ecc; j < ecc + eccLength; j++) {
                  stringBuffer[j] = stringBuffer[j + 1];
                }
              }
      
              stringBuffer[ecc + eccLength - 1] = bit === 255 ? 0 : Galois_1.EXPONENT[Frame._modN(bit + polynomial[0])];
            }
          },
      
          _appendEccToData: function() {
            var i;
            var data = 0;
            var dataBlock = this._dataBlock;
            var ecc = this._calculateMaxLength();
            var eccBlock = this._eccBlock;
      
            for (i = 0; i < this._neccBlock1; i++) {
              this._appendData(data, dataBlock, ecc, eccBlock);
      
              data += dataBlock;
              ecc += eccBlock;
            }
      
            for (i = 0; i < this._neccBlock2; i++) {
              this._appendData(data, dataBlock + 1, ecc, eccBlock);
      
              data += dataBlock + 1;
              ecc += eccBlock;
            }
          },
      
          _applyMask: function(mask) {
            var r3x, r3y, x, y;
            var buffer = this.buffer;
            var width = this.width;
      
            switch (mask) {
            case 0:
              for (y = 0; y < width; y++) {
                for (x = 0; x < width; x++) {
                  if (!((x + y) & 1) && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 1:
              for (y = 0; y < width; y++) {
                for (x = 0; x < width; x++) {
                  if (!(y & 1) && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 2:
              for (y = 0; y < width; y++) {
                for (r3x = 0, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
      
                  if (!r3x && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 3:
              for (r3y = 0, y = 0; y < width; y++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
      
                for (r3x = r3y, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
      
                  if (!r3x && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 4:
              for (y = 0; y < width; y++) {
                for (r3x = 0, r3y = (y >> 1) & 1, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                    r3y = !r3y;
                  }
      
                  if (!r3y && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 5:
              for (r3y = 0, y = 0; y < width; y++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
      
                for (r3x = 0, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
      
                  if (!((x & y & 1) + !(!r3x | !r3y)) && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 6:
              for (r3y = 0, y = 0; y < width; y++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
      
                for (r3x = 0, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
      
                  if (!((x & y & 1) + (r3x && r3x === r3y) & 1) && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            case 7:
              for (r3y = 0, y = 0; y < width; y++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
      
                for (r3x = 0, x = 0; x < width; x++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
      
                  if (!((r3x && r3x === r3y) + (x + y & 1) & 1) && !this._isMasked(x, y)) {
                    buffer[x + (y * width)] ^= 1;
                  }
                }
              }
      
              break;
            }
          },
      
          _calculateMaxLength: function() {
            return (this._dataBlock * (this._neccBlock1 + this._neccBlock2)) + this._neccBlock2;
          },
      
          _calculatePolynomial: function() {
            var i, j;
            var eccBlock = this._eccBlock;
            var polynomial = this._polynomial;
      
            polynomial[0] = 1;
      
            for (i = 0; i < eccBlock; i++) {
              polynomial[i + 1] = 1;
      
              for (j = i; j > 0; j--) {
                polynomial[j] = polynomial[j] ? polynomial[j - 1] ^
                  Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[j]] + i)] : polynomial[j - 1];
              }
      
              polynomial[0] = Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[0]] + i)];
            }
      
            // Use logs for generator polynomial to save calculation step.
            for (i = 0; i <= eccBlock; i++) {
              polynomial[i] = Galois_1.LOG[polynomial[i]];
            }
          },
      
          _checkBadness: function() {
            var b, b1, h, x, y;
            var bad = 0;
            var badness = this._badness;
            var buffer = this.buffer;
            var width = this.width;
      
            // Blocks of same colour.
            for (y = 0; y < width - 1; y++) {
              for (x = 0; x < width - 1; x++) {
                // All foreground colour.
                if ((buffer[x + (width * y)] &&
                  buffer[x + 1 + (width * y)] &&
                  buffer[x + (width * (y + 1))] &&
                  buffer[x + 1 + (width * (y + 1))]) ||
                  // All background colour.
                  !(buffer[x + (width * y)] ||
                  buffer[x + 1 + (width * y)] ||
                  buffer[x + (width * (y + 1))] ||
                  buffer[x + 1 + (width * (y + 1))])) {
                  bad += Frame.N2;
                }
              }
            }
      
            var bw = 0;
      
            // X runs.
            for (y = 0; y < width; y++) {
              h = 0;
      
              badness[0] = 0;
      
              for (b = 0, x = 0; x < width; x++) {
                b1 = buffer[x + (width * y)];
      
                if (b === b1) {
                  badness[h]++;
                } else {
                  badness[++h] = 1;
                }
      
                b = b1;
                bw += b ? 1 : -1;
              }
      
              bad += this._getBadness(h);
            }
      
            if (bw < 0) {
              bw = -bw;
            }
      
            var count = 0;
            var big = bw;
            big += big << 2;
            big <<= 1;
      
            while (big > width * width) {
              big -= width * width;
              count++;
            }
      
            bad += count * Frame.N4;
      
            // Y runs.
            for (x = 0; x < width; x++) {
              h = 0;
      
              badness[0] = 0;
      
              for (b = 0, y = 0; y < width; y++) {
                b1 = buffer[x + (width * y)];
      
                if (b === b1) {
                  badness[h]++;
                } else {
                  badness[++h] = 1;
                }
      
                b = b1;
              }
      
              bad += this._getBadness(h);
            }
      
            return bad;
          },
      
          _convertBitStream: function(length) {
            var bit, i;
            var ecc = this._ecc;
            var version = this._version;
      
            // Convert string to bit stream. 8-bit data to QR-coded 8-bit data (numeric, alphanumeric, or kanji not supported).
            for (i = 0; i < length; i++) {
              ecc[i] = this._value.charCodeAt(i);
            }
      
            var stringBuffer = this._stringBuffer = ecc.slice();
            var maxLength = this._calculateMaxLength();
      
            if (length >= maxLength - 2) {
              length = maxLength - 2;
      
              if (version > 9) {
                length--;
              }
            }
      
            // Shift and re-pack to insert length prefix.
            var index = length;
      
            if (version > 9) {
              stringBuffer[index + 2] = 0;
              stringBuffer[index + 3] = 0;
      
              while (index--) {
                bit = stringBuffer[index];
      
                stringBuffer[index + 3] |= 255 & (bit << 4);
                stringBuffer[index + 2] = bit >> 4;
              }
      
              stringBuffer[2] |= 255 & (length << 4);
              stringBuffer[1] = length >> 4;
              stringBuffer[0] = 0x40 | (length >> 12);
            } else {
              stringBuffer[index + 1] = 0;
              stringBuffer[index + 2] = 0;
      
              while (index--) {
                bit = stringBuffer[index];
      
                stringBuffer[index + 2] |= 255 & (bit << 4);
                stringBuffer[index + 1] = bit >> 4;
              }
      
              stringBuffer[1] |= 255 & (length << 4);
              stringBuffer[0] = 0x40 | (length >> 4);
            }
      
            // Fill to end with pad pattern.
            index = length + 3 - (version < 10);
      
            while (index < maxLength) {
              stringBuffer[index++] = 0xec;
              stringBuffer[index++] = 0x11;
            }
          },
      
          _getBadness: function(length) {
            var i;
            var badRuns = 0;
            var badness = this._badness;
      
            for (i = 0; i <= length; i++) {
              if (badness[i] >= 5) {
                badRuns += Frame.N1 + badness[i] - 5;
              }
            }
      
            // FBFFFBF as in finder.
            for (i = 3; i < length - 1; i += 2) {
              if (badness[i - 2] === badness[i + 2] &&
                badness[i + 2] === badness[i - 1] &&
                badness[i - 1] === badness[i + 1] &&
                badness[i - 1] * 3 === badness[i] &&
                // Background around the foreground pattern? Not part of the specs.
                (badness[i - 3] === 0 || i + 3 > length ||
                badness[i - 3] * 3 >= badness[i] * 4 ||
                badness[i + 3] * 3 >= badness[i] * 4)) {
                badRuns += Frame.N3;
              }
            }
      
            return badRuns;
          },
      
          _finish: function() {
            // Save pre-mask copy of frame.
            this._stringBuffer = this.buffer.slice();
      
            var currentMask, i;
            var bit = 0;
            var mask = 30000;
      
            /*
             * Using for instead of while since in original Arduino code if an early mask was "good enough" it wouldn't try for
             * a better one since they get more complex and take longer.
             */
            for (i = 0; i < 8; i++) {
              // Returns foreground-background imbalance.
              this._applyMask(i);
      
              currentMask = this._checkBadness();
      
              // Is current mask better than previous best?
              if (currentMask < mask) {
                mask = currentMask;
                bit = i;
              }
      
              // Don't increment "i" to a void redoing mask.
              if (bit === 7) {
                break;
              }
      
              // Reset for next pass.
              this.buffer = this._stringBuffer.slice();
            }
      
            // Redo best mask as none were "good enough" (i.e. last wasn't bit).
            if (bit !== i) {
              this._applyMask(bit);
            }
      
            // Add in final mask/ECC level bytes.
            mask = ErrorCorrection_1.FINAL_FORMAT[bit + (this._level - 1 << 3)];
      
            var buffer = this.buffer;
            var width = this.width;
      
            // Low byte.
            for (i = 0; i < 8; i++, mask >>= 1) {
              if (mask & 1) {
                buffer[width - 1 - i + (width * 8)] = 1;
      
                if (i < 6) {
                  buffer[8 + (width * i)] = 1;
                } else {
                  buffer[8 + (width * (i + 1))] = 1;
                }
              }
            }
      
            // High byte.
            for (i = 0; i < 7; i++, mask >>= 1) {
              if (mask & 1) {
                buffer[8 + (width * (width - 7 + i))] = 1;
      
                if (i) {
                  buffer[6 - i + (width * 8)] = 1;
                } else {
                  buffer[7 + (width * 8)] = 1;
                }
              }
            }
          },
      
          _interleaveBlocks: function() {
            var i, j;
            var dataBlock = this._dataBlock;
            var ecc = this._ecc;
            var eccBlock = this._eccBlock;
            var k = 0;
            var maxLength = this._calculateMaxLength();
            var neccBlock1 = this._neccBlock1;
            var neccBlock2 = this._neccBlock2;
            var stringBuffer = this._stringBuffer;
      
            for (i = 0; i < dataBlock; i++) {
              for (j = 0; j < neccBlock1; j++) {
                ecc[k++] = stringBuffer[i + (j * dataBlock)];
              }
      
              for (j = 0; j < neccBlock2; j++) {
                ecc[k++] = stringBuffer[(neccBlock1 * dataBlock) + i + (j * (dataBlock + 1))];
              }
            }
      
            for (j = 0; j < neccBlock2; j++) {
              ecc[k++] = stringBuffer[(neccBlock1 * dataBlock) + i + (j * (dataBlock + 1))];
            }
      
            for (i = 0; i < eccBlock; i++) {
              for (j = 0; j < neccBlock1 + neccBlock2; j++) {
                ecc[k++] = stringBuffer[maxLength + i + (j * eccBlock)];
              }
            }
      
            this._stringBuffer = ecc;
          },
      
          _insertAlignments: function() {
            var i, x, y;
            var version = this._version;
            var width = this.width;
      
            if (version > 1) {
              i = Alignment_1.BLOCK[version];
              y = width - 7;
      
              for (;;) {
                x = width - 7;
      
                while (x > i - 3) {
                  this._addAlignment(x, y);
      
                  if (x < i) {
                    break;
                  }
      
                  x -= i;
                }
      
                if (y <= i + 9) {
                  break;
                }
      
                y -= i;
      
                this._addAlignment(6, y);
                this._addAlignment(y, 6);
              }
            }
          },
      
          _insertFinders: function() {
            var i, j, x, y;
            var buffer = this.buffer;
            var width = this.width;
      
            for (i = 0; i < 3; i++) {
              j = 0;
              y = 0;
      
              if (i === 1) {
                j = width - 7;
              }
              if (i === 2) {
                y = width - 7;
              }
      
              buffer[y + 3 + (width * (j + 3))] = 1;
      
              for (x = 0; x < 6; x++) {
                buffer[y + x + (width * j)] = 1;
                buffer[y + (width * (j + x + 1))] = 1;
                buffer[y + 6 + (width * (j + x))] = 1;
                buffer[y + x + 1 + (width * (j + 6))] = 1;
              }
      
              for (x = 1; x < 5; x++) {
                this._setMask(y + x, j + 1);
                this._setMask(y + 1, j + x + 1);
                this._setMask(y + 5, j + x);
                this._setMask(y + x + 1, j + 5);
              }
      
              for (x = 2; x < 4; x++) {
                buffer[y + x + (width * (j + 2))] = 1;
                buffer[y + 2 + (width * (j + x + 1))] = 1;
                buffer[y + 4 + (width * (j + x))] = 1;
                buffer[y + x + 1 + (width * (j + 4))] = 1;
              }
            }
          },
      
          _insertTimingGap: function() {
            var x, y;
            var width = this.width;
      
            for (y = 0; y < 7; y++) {
              this._setMask(7, y);
              this._setMask(width - 8, y);
              this._setMask(7, y + width - 7);
            }
      
            for (x = 0; x < 8; x++) {
              this._setMask(x, 7);
              this._setMask(x + width - 8, 7);
              this._setMask(x, width - 8);
            }
          },
      
          _insertTimingRowAndColumn: function() {
            var x;
            var buffer = this.buffer;
            var width = this.width;
      
            for (x = 0; x < width - 14; x++) {
              if (x & 1) {
                this._setMask(8 + x, 6);
                this._setMask(6, 8 + x);
              } else {
                buffer[8 + x + (width * 6)] = 1;
                buffer[6 + (width * (8 + x))] = 1;
              }
            }
          },
      
          _insertVersion: function() {
            var i, j, x, y;
            var buffer = this.buffer;
            var version = this._version;
            var width = this.width;
      
            if (version > 6) {
              i = Version_1.BLOCK[version - 7];
              j = 17;
      
              for (x = 0; x < 6; x++) {
                for (y = 0; y < 3; y++, j--) {
                  if (1 & (j > 11 ? version >> j - 12 : i >> j)) {
                    buffer[5 - x + (width * (2 - y + width - 11))] = 1;
                    buffer[2 - y + width - 11 + (width * (5 - x))] = 1;
                  } else {
                    this._setMask(5 - x, 2 - y + width - 11);
                    this._setMask(2 - y + width - 11, 5 - x);
                  }
                }
              }
            }
          },
      
          _isMasked: function(x, y) {
            var bit = Frame._getMaskBit(x, y);
      
            return this._mask[bit] === 1;
          },
      
          _pack: function() {
            var bit, i, j;
            var k = 1;
            var v = 1;
            var width = this.width;
            var x = width - 1;
            var y = width - 1;
      
            // Interleaved data and ECC codes.
            var length = ((this._dataBlock + this._eccBlock) * (this._neccBlock1 + this._neccBlock2)) + this._neccBlock2;
      
            for (i = 0; i < length; i++) {
              bit = this._stringBuffer[i];
      
              for (j = 0; j < 8; j++, bit <<= 1) {
                if (0x80 & bit) {
                  this.buffer[x + (width * y)] = 1;
                }
      
                // Find next fill position.
                do {
                  if (v) {
                    x--;
                  } else {
                    x++;
      
                    if (k) {
                      if (y !== 0) {
                        y--;
                      } else {
                        x -= 2;
                        k = !k;
      
                        if (x === 6) {
                          x--;
                          y = 9;
                        }
                      }
                    } else if (y !== width - 1) {
                      y++;
                    } else {
                      x -= 2;
                      k = !k;
      
                      if (x === 6) {
                        x--;
                        y -= 8;
                      }
                    }
                  }
      
                  v = !v;
                } while (this._isMasked(x, y));
              }
            }
          },
      
          _reverseMask: function() {
            var x, y;
            var width = this.width;
      
            for (x = 0; x < 9; x++) {
              this._setMask(x, 8);
            }
      
            for (x = 0; x < 8; x++) {
              this._setMask(x + width - 8, 8);
              this._setMask(8, x);
            }
      
            for (y = 0; y < 7; y++) {
              this._setMask(8, y + width - 7);
            }
          },
      
          _setMask: function(x, y) {
            var bit = Frame._getMaskBit(x, y);
      
            this._mask[bit] = 1;
          },
      
          _syncMask: function() {
            var x, y;
            var width = this.width;
      
            for (y = 0; y < width; y++) {
              for (x = 0; x <= y; x++) {
                if (this.buffer[x + (width * y)]) {
                  this._setMask(x, y);
                }
              }
            }
          }
      
        }, {
      
          _createArray: function(length) {
            var i;
            var array = [];
      
            for (i = 0; i < length; i++) {
              array[i] = 0;
            }
      
            return array;
          },
      
          _getMaskBit: function(x, y) {
            var bit;
      
            if (x > y) {
              bit = x;
              x = y;
              y = bit;
            }
      
            bit = y;
            bit += y * y;
            bit >>= 1;
            bit += x;
      
            return bit;
          },
      
          _modN: function(x) {
            while (x >= 255) {
              x -= 255;
              x = (x >> 8) + (x & 255);
            }
      
            return x;
          },
      
          // *Badness* coefficients.
          N1: 3,
          N2: 3,
          N3: 40,
          N4: 10
      
        });
      
        var Frame_1 = Frame;
      
        /**
         * The options used by {@link Frame}.
         *
         * @typedef {Object} Frame~Options
         * @property {string} level - The ECC level to be used.
         * @property {string} value - The value to be encoded.
         */
      
        /**
         * An implementation of {@link Renderer} for working with <code>img</code> elements.
         *
         * This depends on {@link CanvasRenderer} being executed first as this implementation simply applies the data URL from
         * the rendered <code>canvas</code> element as the <code>src</code> for the <code>img</code> element being rendered.
         *
         * @public
         * @class
         * @extends Renderer
         */
        var ImageRenderer = Renderer_1.extend({
      
          /**
           * @override
           */
          draw: function() {
            this.element.src = this.qrious.toDataURL();
          },
      
          /**
           * @override
           */
          reset: function() {
            this.element.src = '';
          },
      
          /**
           * @override
           */
          resize: function() {
            var element = this.element;
      
            element.width = element.height = this.qrious.size;
          }
      
        });
      
        var ImageRenderer_1 = ImageRenderer;
      
        /**
         * Defines an available option while also configuring how values are applied to the target object.
         *
         * Optionally, a default value can be specified as well a value transformer for greater control over how the option
         * value is applied.
         *
         * If no value transformer is specified, then any specified option will be applied directly. All values are maintained
         * on the target object itself as a field using the option name prefixed with a single underscore.
         *
         * When an option is specified as modifiable, the {@link OptionManager} will be required to include a setter for the
         * property that is defined on the target object that uses the option name.
         *
         * @param {string} name - the name to be used
         * @param {boolean} [modifiable] - <code>true</code> if the property defined on target objects should include a setter;
         * otherwise <code>false</code>
         * @param {*} [defaultValue] - the default value to be used
         * @param {Option~ValueTransformer} [valueTransformer] - the value transformer to be used
         * @public
         * @class
         * @extends Nevis
         */
        var Option = lite.extend(function(name, modifiable, defaultValue, valueTransformer) {
          /**
           * The name for this {@link Option}.
           *
           * @public
           * @type {string}
           * @memberof Option#
           */
          this.name = name;
      
          /**
           * Whether a setter should be included on the property defined on target objects for this {@link Option}.
           *
           * @public
           * @type {boolean}
           * @memberof Option#
           */
          this.modifiable = Boolean(modifiable);
      
          /**
           * The default value for this {@link Option}.
           *
           * @public
           * @type {*}
           * @memberof Option#
           */
          this.defaultValue = defaultValue;
      
          this._valueTransformer = valueTransformer;
        }, {
      
          /**
           * Transforms the specified <code>value</code> so that it can be applied for this {@link Option}.
           *
           * If a value transformer has been specified for this {@link Option}, it will be called upon to transform
           * <code>value</code>. Otherwise, <code>value</code> will be returned directly.
           *
           * @param {*} value - the value to be transformed
           * @return {*} The transformed value or <code>value</code> if no value transformer is specified.
           * @public
           * @memberof Option#
           */
          transform: function(value) {
            var transformer = this._valueTransformer;
            if (typeof transformer === 'function') {
              return transformer(value, this);
            }
      
            return value;
          }
      
        });
      
        var Option_1 = Option;
      
        /**
         * Returns a transformed value for the specified <code>value</code> to be applied for the <code>option</code> provided.
         *
         * @callback Option~ValueTransformer
         * @param {*} value - the value to be transformed
         * @param {Option} option - the {@link Option} for which <code>value</code> is being transformed
         * @return {*} The transform value.
         */
      
        /**
         * Contains utility methods that are useful throughout the library.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var Utilities = lite.extend(null, {
      
          /**
           * Returns the absolute value of a given number.
           *
           * This method is simply a convenient shorthand for <code>Math.abs</code> while ensuring that nulls are returned as
           * <code>null</code> instead of zero.
           *
           * @param {number} value - the number whose absolute value is to be returned
           * @return {number} The absolute value of <code>value</code> or <code>null</code> if <code>value</code> is
           * <code>null</code>.
           * @public
           * @static
           * @memberof Utilities
           */
          abs: function(value) {
            return value != null ? Math.abs(value) : null;
          },
      
          /**
           * Returns whether the specified <code>object</code> has a property with the specified <code>name</code> as an own
           * (not inherited) property.
           *
           * @param {Object} object - the object on which the property is to be checked
           * @param {string} name - the name of the property to be checked
           * @return {boolean} <code>true</code> if <code>object</code> has an own property with <code>name</code>.
           * @public
           * @static
           * @memberof Utilities
           */
          hasOwn: function(object, name) {
            return Object.prototype.hasOwnProperty.call(object, name);
          },
      
          /**
           * A non-operation method that does absolutely nothing.
           *
           * @return {void}
           * @public
           * @static
           * @memberof Utilities
           */
          noop: function() {},
      
          /**
           * Transforms the specified <code>string</code> to upper case while remaining null-safe.
           *
           * @param {string} string - the string to be transformed to upper case
           * @return {string} <code>string</code> transformed to upper case if <code>string</code> is not <code>null</code>.
           * @public
           * @static
           * @memberof Utilities
           */
          toUpperCase: function(string) {
            return string != null ? string.toUpperCase() : null;
          }
      
        });
      
        var Utilities_1 = Utilities;
      
        /**
         * Manages multiple {@link Option} instances that are intended to be used by multiple implementations.
         *
         * Although the option definitions are shared between targets, the values are maintained on the targets themselves.
         *
         * @param {Option[]} options - the options to be used
         * @public
         * @class
         * @extends Nevis
         */
        var OptionManager = lite.extend(function(options) {
          /**
           * The available options for this {@link OptionManager}.
           *
           * @public
           * @type {Object.<string, Option>}
           * @memberof OptionManager#
           */
          this.options = {};
      
          options.forEach(function(option) {
            this.options[option.name] = option;
          }, this);
        }, {
      
          /**
           * Returns whether an option with the specified <code>name</code> is available.
           *
           * @param {string} name - the name of the {@link Option} whose existence is to be checked
           * @return {boolean} <code>true</code> if an {@link Option} exists with <code>name</code>; otherwise
           * <code>false</code>.
           * @public
           * @memberof OptionManager#
           */
          exists: function(name) {
            return this.options[name] != null;
          },
      
          /**
           * Returns the value of the option with the specified <code>name</code> on the <code>target</code> object provided.
           *
           * @param {string} name - the name of the {@link Option} whose value on <code>target</code> is to be returned
           * @param {Object} target - the object from which the value of the named {@link Option} is to be returned
           * @return {*} The value of the {@link Option} with <code>name</code> on <code>target</code>.
           * @public
           * @memberof OptionManager#
           */
          get: function(name, target) {
            return OptionManager._get(this.options[name], target);
          },
      
          /**
           * Returns a copy of all of the available options on the <code>target</code> object provided.
           *
           * @param {Object} target - the object from which the option name/value pairs are to be returned
           * @return {Object.<string, *>} A hash containing the name/value pairs of all options on <code>target</code>.
           * @public
           * @memberof OptionManager#
           */
          getAll: function(target) {
            var name;
            var options = this.options;
            var result = {};
      
            for (name in options) {
              if (Utilities_1.hasOwn(options, name)) {
                result[name] = OptionManager._get(options[name], target);
              }
            }
      
            return result;
          },
      
          /**
           * Initializes the available options for the <code>target</code> object provided and then applies the initial values
           * within the speciifed <code>options</code>.
           *
           * This method will throw an error if any of the names within <code>options</code> does not match an available option.
           *
           * This involves setting the default values and defining properties for all of the available options on
           * <code>target</code> before finally calling {@link OptionMananger#setAll} with <code>options</code> and
           * <code>target</code>. Any options that are configured to be modifiable will have a setter included in their defined
           * property that will allow its corresponding value to be modified.
           *
           * If a change handler is specified, it will be called whenever the value changes on <code>target</code> for a
           * modifiable option, but only when done so via the defined property's setter.
           *
           * @param {Object.<string, *>} options - the name/value pairs of the initial options to be set
           * @param {Object} target - the object on which the options are to be initialized
           * @param {Function} [changeHandler] - the function to be called whenever the value of an modifiable option changes on
           * <code>target</code>
           * @return {void}
           * @throws {Error} If <code>options</code> contains an invalid option name.
           * @public
           * @memberof OptionManager#
           */
          init: function(options, target, changeHandler) {
            if (typeof changeHandler !== 'function') {
              changeHandler = Utilities_1.noop;
            }
      
            var name, option;
      
            for (name in this.options) {
              if (Utilities_1.hasOwn(this.options, name)) {
                option = this.options[name];
      
                OptionManager._set(option, option.defaultValue, target);
                OptionManager._createAccessor(option, target, changeHandler);
              }
            }
      
            this._setAll(options, target, true);
          },
      
          /**
           * Sets the value of the option with the specified <code>name</code> on the <code>target</code> object provided to
           * <code>value</code>.
           *
           * This method will throw an error if <code>name</code> does not match an available option or matches an option that
           * cannot be modified.
           *
           * If <code>value</code> is <code>null</code> and the {@link Option} has a default value configured, then that default
           * value will be used instead. If the {@link Option} also has a value transformer configured, it will be used to
           * transform whichever value was determined to be used.
           *
           * This method returns whether the value of the underlying field on <code>target</code> was changed as a result.
           *
           * @param {string} name - the name of the {@link Option} whose value is to be set
           * @param {*} value - the value to be set for the named {@link Option} on <code>target</code>
           * @param {Object} target - the object on which <code>value</code> is to be set for the named {@link Option}
           * @return {boolean} <code>true</code> if the underlying field on <code>target</code> was changed; otherwise
           * <code>false</code>.
           * @throws {Error} If <code>name</code> is invalid or is for an option that cannot be modified.
           * @public
           * @memberof OptionManager#
           */
          set: function(name, value, target) {
            return this._set(name, value, target);
          },
      
          /**
           * Sets all of the specified <code>options</code> on the <code>target</code> object provided to their corresponding
           * values.
           *
           * This method will throw an error if any of the names within <code>options</code> does not match an available option
           * or matches an option that cannot be modified.
           *
           * If any value within <code>options</code> is <code>null</code> and the corresponding {@link Option} has a default
           * value configured, then that default value will be used instead. If an {@link Option} also has a value transformer
           * configured, it will be used to transform whichever value was determined to be used.
           *
           * This method returns whether the value for any of the underlying fields on <code>target</code> were changed as a
           * result.
           *
           * @param {Object.<string, *>} options - the name/value pairs of options to be set
           * @param {Object} target - the object on which the options are to be set
           * @return {boolean} <code>true</code> if any of the underlying fields on <code>target</code> were changed; otherwise
           * <code>false</code>.
           * @throws {Error} If <code>options</code> contains an invalid option name or an option that cannot be modiifed.
           * @public
           * @memberof OptionManager#
           */
          setAll: function(options, target) {
            return this._setAll(options, target);
          },
      
          _set: function(name, value, target, allowUnmodifiable) {
            var option = this.options[name];
            if (!option) {
              throw new Error('Invalid option: ' + name);
            }
            if (!option.modifiable && !allowUnmodifiable) {
              throw new Error('Option cannot be modified: ' + name);
            }
      
            return OptionManager._set(option, value, target);
          },
      
          _setAll: function(options, target, allowUnmodifiable) {
            if (!options) {
              return false;
            }
      
            var name;
            var changed = false;
      
            for (name in options) {
              if (Utilities_1.hasOwn(options, name) && this._set(name, options[name], target, allowUnmodifiable)) {
                changed = true;
              }
            }
      
            return changed;
          }
      
        }, {
      
          _createAccessor: function(option, target, changeHandler) {
            var descriptor = {
              get: function() {
                return OptionManager._get(option, target);
              }
            };
      
            if (option.modifiable) {
              descriptor.set = function(value) {
                if (OptionManager._set(option, value, target)) {
                  changeHandler(value, option);
                }
              };
            }
      
            Object.defineProperty(target, option.name, descriptor);
          },
      
          _get: function(option, target) {
            return target['_' + option.name];
          },
      
          _set: function(option, value, target) {
            var fieldName = '_' + option.name;
            var oldValue = target[fieldName];
            var newValue = option.transform(value != null ? value : option.defaultValue);
      
            target[fieldName] = newValue;
      
            return newValue !== oldValue;
          }
      
        });
      
        var OptionManager_1 = OptionManager;
      
        /**
         * Called whenever the value of a modifiable {@link Option} is changed on a target object via the defined property's
         * setter.
         *
         * @callback OptionManager~ChangeHandler
         * @param {*} value - the new value for <code>option</code> on the target object
         * @param {Option} option - the modifable {@link Option} whose value has changed on the target object.
         * @return {void}
         */
      
        /**
         * A basic manager for {@link Service} implementations that are mapped to simple names.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var ServiceManager = lite.extend(function() {
          this._services = {};
        }, {
      
          /**
           * Returns the {@link Service} being managed with the specified <code>name</code>.
           *
           * @param {string} name - the name of the {@link Service} to be returned
           * @return {Service} The {@link Service} is being managed with <code>name</code>.
           * @throws {Error} If no {@link Service} is being managed with <code>name</code>.
           * @public
           * @memberof ServiceManager#
           */
          getService: function(name) {
            var service = this._services[name];
            if (!service) {
              throw new Error('Service is not being managed with name: ' + name);
            }
      
            return service;
          },
      
          /**
           * Sets the {@link Service} implementation to be managed for the specified <code>name</code> to the
           * <code>service</code> provided.
           *
           * @param {string} name - the name of the {@link Service} to be managed with <code>name</code>
           * @param {Service} service - the {@link Service} implementation to be managed
           * @return {void}
           * @throws {Error} If a {@link Service} is already being managed with the same <code>name</code>.
           * @public
           * @memberof ServiceManager#
           */
          setService: function(name, service) {
            if (this._services[name]) {
              throw new Error('Service is already managed with name: ' + name);
            }
      
            if (service) {
              this._services[name] = service;
            }
          }
      
        });
      
        var ServiceManager_1 = ServiceManager;
      
        var optionManager = new OptionManager_1([
          new Option_1('background', true, 'white'),
          new Option_1('backgroundAlpha', true, 1, Utilities_1.abs),
          new Option_1('element'),
          new Option_1('foreground', true, 'black'),
          new Option_1('foregroundAlpha', true, 1, Utilities_1.abs),
          new Option_1('level', true, 'L', Utilities_1.toUpperCase),
          new Option_1('mime', true, 'image/png'),
          new Option_1('padding', true, null, Utilities_1.abs),
          new Option_1('size', true, 100, Utilities_1.abs),
          new Option_1('value', true, '')
        ]);
        var serviceManager = new ServiceManager_1();
      
        /**
         * Enables configuration of a QR code generator which uses HTML5 <code>canvas</code> for rendering.
         *
         * @param {QRious~Options} [options] - the options to be used
         * @throws {Error} If any <code>options</code> are invalid.
         * @public
         * @class
         * @extends Nevis
         */
        var QRious = lite.extend(function(options) {
          optionManager.init(options, this, this.update.bind(this));
      
          var element = optionManager.get('element', this);
          var elementService = serviceManager.getService('element');
          var canvas = element && elementService.isCanvas(element) ? element : elementService.createCanvas();
          var image = element && elementService.isImage(element) ? element : elementService.createImage();
      
          this._canvasRenderer = new CanvasRenderer_1(this, canvas, true);
          this._imageRenderer = new ImageRenderer_1(this, image, image === element);
      
          this.update();
        }, {
      
          /**
           * Returns all of the options configured for this {@link QRious}.
           *
           * Any changes made to the returned object will not be reflected in the options themselves or their corresponding
           * underlying fields.
           *
           * @return {Object.<string, *>} A copy of the applied options.
           * @public
           * @memberof QRious#
           */
          get: function() {
            return optionManager.getAll(this);
          },
      
          /**
           * Sets all of the specified <code>options</code> and automatically updates this {@link QRious} if any of the
           * underlying fields are changed as a result.
           *
           * This is the preferred method for updating multiple options at one time to avoid unnecessary updates between
           * changes.
           *
           * @param {QRious~Options} options - the options to be set
           * @return {void}
           * @throws {Error} If any <code>options</code> are invalid or cannot be modified.
           * @public
           * @memberof QRious#
           */
          set: function(options) {
            if (optionManager.setAll(options, this)) {
              this.update();
            }
          },
      
          /**
           * Returns the image data URI for the generated QR code using the <code>mime</code> provided.
           *
           * @param {string} [mime] - the MIME type for the image
           * @return {string} The image data URI for the QR code.
           * @public
           * @memberof QRious#
           */
          toDataURL: function(mime) {
            return this.canvas.toDataURL(mime || this.mime);
          },
      
          /**
           * Updates this {@link QRious} by generating a new {@link Frame} and re-rendering the QR code.
           *
           * @return {void}
           * @protected
           * @memberof QRious#
           */
          update: function() {
            var frame = new Frame_1({
              level: this.level,
              value: this.value
            });
      
            this._canvasRenderer.render(frame);
            this._imageRenderer.render(frame);
          }
      
        }, {
      
          /**
           * Configures the <code>service</code> provided to be used by all {@link QRious} instances.
           *
           * @param {Service} service - the {@link Service} to be configured
           * @return {void}
           * @throws {Error} If a {@link Service} has already been configured with the same name.
           * @public
           * @static
           * @memberof QRious
           */
          use: function(service) {
            serviceManager.setService(service.getName(), service);
          }
      
        });
      
        Object.defineProperties(QRious.prototype, {
      
          canvas: {
            /**
             * Returns the <code>canvas</code> element being used to render the QR code for this {@link QRious}.
             *
             * @return {*} The <code>canvas</code> element.
             * @public
             * @memberof QRious#
             * @alias canvas
             */
            get: function() {
              return this._canvasRenderer.getElement();
            }
          },
      
          image: {
            /**
             * Returns the <code>img</code> element being used to render the QR code for this {@link QRious}.
             *
             * @return {*} The <code>img</code> element.
             * @public
             * @memberof QRious#
             * @alias image
             */
            get: function() {
              return this._imageRenderer.getElement();
            }
          }
      
        });
      
        var QRious_1$2 = QRious;
      
        /**
         * The options used by {@link QRious}.
         *
         * @typedef {Object} QRious~Options
         * @property {string} [background="white"] - The background color to be applied to the QR code.
         * @property {number} [backgroundAlpha=1] - The background alpha to be applied to the QR code.
         * @property {*} [element] - The element to be used to render the QR code which may either be an <code>canvas</code> or
         * <code>img</code>. The element(s) will be created if needed.
         * @property {string} [foreground="black"] - The foreground color to be applied to the QR code.
         * @property {number} [foregroundAlpha=1] - The foreground alpha to be applied to the QR code.
         * @property {string} [level="L"] - The error correction level to be applied to the QR code.
         * @property {string} [mime="image/png"] - The MIME type to be used to render the image for the QR code.
         * @property {number} [padding] - The padding for the QR code in pixels.
         * @property {number} [size=100] - The size of the QR code in pixels.
         * @property {string} [value=""] - The value to be encoded within the QR code.
         */
      
        var index = QRious_1$2;
      
        /**
         * Defines a service contract that must be met by all implementations.
         *
         * @public
         * @class
         * @extends Nevis
         */
        var Service = lite.extend({
      
          /**
           * Returns the name of this {@link Service}.
           *
           * @return {string} The service name.
           * @public
           * @abstract
           * @memberof Service#
           */
          getName: function() {}
      
        });
      
        var Service_1 = Service;
      
        /**
         * A service for working with elements.
         *
         * @public
         * @class
         * @extends Service
         */
        var ElementService = Service_1.extend({
      
          /**
           * Creates an instance of a canvas element.
           *
           * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
           *
           * @return {*} The newly created canvas element.
           * @public
           * @abstract
           * @memberof ElementService#
           */
          createCanvas: function() {},
      
          /**
           * Creates an instance of a image element.
           *
           * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
           *
           * @return {*} The newly created image element.
           * @public
           * @abstract
           * @memberof ElementService#
           */
          createImage: function() {},
      
          /**
           * @override
           */
          getName: function() {
            return 'element';
          },
      
          /**
           * Returns whether the specified <code>element</code> is a canvas.
           *
           * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
           *
           * @param {*} element - the element to be checked
           * @return {boolean} <code>true</code> if <code>element</code> is a canvas; otherwise <code>false</code>.
           * @public
           * @abstract
           * @memberof ElementService#
           */
          isCanvas: function(element) {},
      
          /**
           * Returns whether the specified <code>element</code> is an image.
           *
           * Implementations of {@link ElementService} <b>must</b> override this method with their own specific logic.
           *
           * @param {*} element - the element to be checked
           * @return {boolean} <code>true</code> if <code>element</code> is an image; otherwise <code>false</code>.
           * @public
           * @abstract
           * @memberof ElementService#
           */
          isImage: function(element) {}
      
        });
      
        var ElementService_1 = ElementService;
      
        /**
         * An implementation of {@link ElementService} intended for use within a browser environment.
         *
         * @public
         * @class
         * @extends ElementService
         */
        var BrowserElementService = ElementService_1.extend({
      
          /**
           * @override
           */
          createCanvas: function() {
            return document.createElement('canvas');
          },
      
          /**
           * @override
           */
          createImage: function() {
            return document.createElement('img');
          },
      
          /**
           * @override
           */
          isCanvas: function(element) {
            return element instanceof HTMLCanvasElement;
          },
      
          /**
           * @override
           */
          isImage: function(element) {
            return element instanceof HTMLImageElement;
          }
      
        });
      
        var BrowserElementService_1 = BrowserElementService;
      
        index.use(new BrowserElementService_1());
      
        var QRious_1 = index;
      
        return QRious_1;
      
      })));
    });

    /* node_modules\svelte-qrcode\src\lib\index.svelte generated by Svelte v3.46.4 */
    const file$i = "node_modules\\svelte-qrcode\\src\\lib\\index.svelte";

    function create_fragment$i(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*value*/ ctx[0]);
    			attr_dev(img, "class", /*className*/ ctx[1]);
    			add_location(img, file$i, 41, 0, 681);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*image*/ 4 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[2])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*value*/ 1) {
    				attr_dev(img, "alt", /*value*/ ctx[0]);
    			}

    			if (dirty & /*className*/ 2) {
    				attr_dev(img, "class", /*className*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lib', slots, []);
    	const QRcode = new qrcode();
    	let { errorCorrection = "L" } = $$props;
    	let { background = "#fff" } = $$props;
    	let { color = "#000" } = $$props;
    	let { size = "200" } = $$props;
    	let { value = "" } = $$props;
    	let { padding = 0 } = $$props;
    	let { className = "qrcode" } = $$props;
    	let image = '';

    	function generateQrCode() {
    		QRcode.set({
    			background,
    			foreground: color,
    			level: errorCorrection,
    			padding,
    			size,
    			value
    		});

    		$$invalidate(2, image = QRcode.toDataURL('image/jpeg'));
    	}

    	onMount(() => {
    		generateQrCode();
    	});

    	const writable_props = [
    		'errorCorrection',
    		'background',
    		'color',
    		'size',
    		'value',
    		'padding',
    		'className'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lib> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('errorCorrection' in $$props) $$invalidate(3, errorCorrection = $$props.errorCorrection);
    		if ('background' in $$props) $$invalidate(4, background = $$props.background);
    		if ('color' in $$props) $$invalidate(5, color = $$props.color);
    		if ('size' in $$props) $$invalidate(6, size = $$props.size);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('padding' in $$props) $$invalidate(7, padding = $$props.padding);
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		QrCode: qrcode,
    		QRcode,
    		errorCorrection,
    		background,
    		color,
    		size,
    		value,
    		padding,
    		className,
    		image,
    		generateQrCode
    	});

    	$$self.$inject_state = $$props => {
    		if ('errorCorrection' in $$props) $$invalidate(3, errorCorrection = $$props.errorCorrection);
    		if ('background' in $$props) $$invalidate(4, background = $$props.background);
    		if ('color' in $$props) $$invalidate(5, color = $$props.color);
    		if ('size' in $$props) $$invalidate(6, size = $$props.size);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('padding' in $$props) $$invalidate(7, padding = $$props.padding);
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('image' in $$props) $$invalidate(2, image = $$props.image);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			{
    				if (value) {
    					generateQrCode();
    				}
    			}
    		}
    	};

    	return [value, className, image, errorCorrection, background, color, size, padding];
    }

    class Lib extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			errorCorrection: 3,
    			background: 4,
    			color: 5,
    			size: 6,
    			value: 0,
    			padding: 7,
    			className: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lib",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get errorCorrection() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorCorrection(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Lib>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Lib>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * 
     * - phone: 
     * - password: 
     * - countrycode: 1
     * - md5_password: md5, password 
     * - captcha: , /captcha/sent,,, password 
     * @param {Object} params
     * @param {string} params.phone
     * @param {string} params.password
     * @param {string=} params.countrycode
     * @param {string=} params.md5_password
     * @param {string=} params.captcha
     */
    function loginWithPhone(params) {
      return service({
        url: "/login/cellphone",
        method: "post",
        params,
      });
    }

    /**
     * 
     * - email: 163 
     * - password: 
     * - md5_password: md5, password 
     * @param {Object} params
     * @param {string} params.email
     * @param {string} params.password
     * @param {string=} params.md5_password
     */
    function loginWithEmail(params) {
      return service({
        url: "/login",
        method: "post",
        params,
      });
    }

    /**
     * key
     */
    function loginQrCodeKey() {
      return service({
        url: "/login/qr/key",
        method: "get",
        params: {
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     * : keybase64,
     * base64,
     * @param {Object} params
     * @param {string} params.key
     * @param {string=} params.qrimg base64
     */
    function loginQrCodeCreate(params) {
      return service({
        url: "/login/qr/create",
        method: "get",
        params: {
          ...params,
          timestamp: new Date().getTime(),
        },
      });
    }

    /**
     * 
     * : ,800,801,802,803(803cookies)
     * @param {string} key
     */
    function loginQrCodeCheck(key) {
      return service({
        url: "/login/qr/check",
        method: "get",
        params: {
          key,
          timestamp: new Date().getTime(),
        },
        isHideLoading: true,
      });
    }

    /* src\pages\Login.svelte generated by Svelte v3.46.4 */
    const file$h = "src\\pages\\Login.svelte";

    // (254:2) {#if type === 'qr'}
    function create_if_block_7(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let qrcode;
    	let t2;
    	let div2;
    	let t4;
    	let div3;
    	let span0;
    	let t6;
    	let span1;
    	let current;
    	let mounted;
    	let dispose;

    	qrcode = new Lib({
    			props: { value: /*qrImg*/ ctx[7] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = text(/*qrTip*/ ctx[6]);
    			t1 = space();
    			div1 = element("div");
    			create_component(qrcode.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			div2.textContent = " APP  APP ";
    			t4 = space();
    			div3 = element("div");
    			span0 = element("span");
    			span0.textContent = "";
    			t6 = text("\r\n        ");
    			span1 = element("span");
    			span1.textContent = "";
    			attr_dev(div0, "class", "qr-tip svelte-1hbo5j0");
    			add_location(div0, file$h, 255, 6, 7206);
    			attr_dev(div1, "class", "qrcode svelte-1hbo5j0");
    			add_location(div1, file$h, 256, 6, 7247);
    			attr_dev(div2, "class", "tip svelte-1hbo5j0");
    			add_location(div2, file$h, 259, 6, 7323);
    			add_location(span0, file$h, 261, 8, 7432);
    			add_location(span1, file$h, 269, 8, 7617);
    			attr_dev(div3, "class", "type-switch svelte-1hbo5j0");
    			add_location(div3, file$h, 260, 6, 7397);
    			attr_dev(div4, "class", "qr svelte-1hbo5j0");
    			add_location(div4, file$h, 254, 4, 7182);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, t0);
    			append_dev(div4, t1);
    			append_dev(div4, div1);
    			mount_component(qrcode, div1, null);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, span0);
    			append_dev(div3, t6);
    			append_dev(div3, span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span0, "click", /*click_handler*/ ctx[20], false, false, false),
    					listen_dev(span1, "click", /*click_handler_1*/ ctx[21], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*qrTip*/ 64) set_data_dev(t0, /*qrTip*/ ctx[6]);
    			const qrcode_changes = {};
    			if (dirty[0] & /*qrImg*/ 128) qrcode_changes.value = /*qrImg*/ ctx[7];
    			qrcode.$set(qrcode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qrcode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qrcode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(qrcode);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(254:2) {#if type === 'qr'}",
    		ctx
    	});

    	return block;
    }

    // (281:2) {#if type === 'phone'}
    function create_if_block_1$5(ctx) {
    	let div3;
    	let input;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let t4;
    	let div1;
    	let button;
    	let t5;
    	let t6;
    	let div2;
    	let span0;
    	let t8;
    	let span1;
    	let current;
    	let mounted;
    	let dispose;

    	input = new Input({
    			props: {
    				label: "",
    				type: "tel",
    				maxlength: "11"
    			},
    			$$inline: true
    		});

    	input.$on("setInput", /*getPhone*/ ctx[16]);
    	let if_block0 = /*phoneType*/ ctx[8] === 'pwd' && create_if_block_6(ctx);
    	let if_block1 = /*phoneType*/ ctx[8] === 'code' && create_if_block_5(ctx);
    	let if_block2 = /*phoneType*/ ctx[8] === 'pwd' && create_if_block_4(ctx);
    	let if_block3 = /*phoneType*/ ctx[8] === 'code' && create_if_block_3$2(ctx);

    	button = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*getClickPhone*/ ctx[11]);
    	let if_block4 = /*phoneType*/ ctx[8] === 'pwd' && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			create_component(input.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "";
    			t8 = text("\r\n        ");
    			span1 = element("span");
    			span1.textContent = "";
    			attr_dev(div0, "class", "phone-switch svelte-1hbo5j0");
    			add_location(div0, file$h, 298, 6, 8406);
    			attr_dev(div1, "class", "btn svelte-1hbo5j0");
    			add_location(div1, file$h, 317, 6, 8842);
    			add_location(span0, file$h, 324, 8, 9076);
    			add_location(span1, file$h, 325, 8, 9141);
    			attr_dev(div2, "class", "type-switch svelte-1hbo5j0");
    			add_location(div2, file$h, 323, 6, 9041);
    			attr_dev(div3, "class", "phone");
    			add_location(div3, file$h, 281, 4, 7845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			mount_component(input, div3, null);
    			append_dev(div3, t0);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t1);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, div0);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div3, t4);
    			append_dev(div3, div1);
    			mount_component(button, div1, null);
    			append_dev(div3, t5);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div2, t8);
    			append_dev(div2, span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span0, "click", /*qrLoginFun*/ ctx[18], false, false, false),
    					listen_dev(span1, "click", /*click_handler_4*/ ctx[26], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*phoneType*/ ctx[8] === 'pwd') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*phoneType*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*phoneType*/ ctx[8] === 'code') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*phoneType*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*phoneType*/ ctx[8] === 'pwd') {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_4(ctx);
    					if_block2.c();
    					if_block2.m(div0, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*phoneType*/ ctx[8] === 'code') {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_3$2(ctx);
    					if_block3.c();
    					if_block3.m(div0, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*phoneType*/ ctx[8] === 'pwd') {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_2$2(ctx);
    					if_block4.c();
    					if_block4.m(div3, t6);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(input);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(button);
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(281:2) {#if type === 'phone'}",
    		ctx
    	});

    	return block;
    }

    // (284:6) {#if phoneType === 'pwd'}
    function create_if_block_6(ctx) {
    	let input;
    	let updating_password_phone;
    	let current;

    	function input_password_phone_binding(value) {
    		/*input_password_phone_binding*/ ctx[22](value);
    	}

    	let input_props = {
    		label: "",
    		type: "password",
    		maxlength: "40"
    	};

    	if (/*password_phone*/ ctx[2] !== void 0) {
    		input_props.password_phone = /*password_phone*/ ctx[2];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(input, 'password_phone', input_password_phone_binding));
    	input.$on("setInput", /*getpassword_phone*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};

    			if (!updating_password_phone && dirty[0] & /*password_phone*/ 4) {
    				updating_password_phone = true;
    				input_changes.password_phone = /*password_phone*/ ctx[2];
    				add_flush_callback(() => updating_password_phone = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(284:6) {#if phoneType === 'pwd'}",
    		ctx
    	});

    	return block;
    }

    // (287:6) {#if phoneType === 'code'}
    function create_if_block_5(ctx) {
    	let input;
    	let updating_code_phone;
    	let current;

    	function input_code_phone_binding(value) {
    		/*input_code_phone_binding*/ ctx[23](value);
    	}

    	let input_props = {
    		label: "",
    		type: "tel",
    		maxlength: "4",
    		rightBtn: true,
    		btnText: /*btnText*/ ctx[5]
    	};

    	if (/*code_phone*/ ctx[4] !== void 0) {
    		input_props.code_phone = /*code_phone*/ ctx[4];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(input, 'code_phone', input_code_phone_binding));
    	input.$on("setInput", /*getcode_phone*/ ctx[14]);
    	input.$on("setBtn", /*sendSmsCodeFun*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};
    			if (dirty[0] & /*btnText*/ 32) input_changes.btnText = /*btnText*/ ctx[5];

    			if (!updating_code_phone && dirty[0] & /*code_phone*/ 16) {
    				updating_code_phone = true;
    				input_changes.code_phone = /*code_phone*/ ctx[4];
    				add_flush_callback(() => updating_code_phone = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(287:6) {#if phoneType === 'code'}",
    		ctx
    	});

    	return block;
    }

    // (300:8) {#if phoneType === 'pwd'}
    function create_if_block_4(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "";
    			add_location(span, file$h, 300, 10, 8479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_2*/ ctx[24], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(300:8) {#if phoneType === 'pwd'}",
    		ctx
    	});

    	return block;
    }

    // (308:8) {#if phoneType === 'code'}
    function create_if_block_3$2(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "";
    			add_location(span, file$h, 308, 10, 8669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_3*/ ctx[25], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(308:8) {#if phoneType === 'code'}",
    		ctx
    	});

    	return block;
    }

    // (319:8) <Button on:BtnClick={getClickPhone} type="primary">
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(319:8) <Button on:BtnClick={getClickPhone} type=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    // (321:6) {#if phoneType === 'pwd'}
    function create_if_block_2$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = `${/*tiptext*/ ctx[10]}`;
    			attr_dev(div, "class", "tip svelte-1hbo5j0");
    			add_location(div, file$h, 321, 8, 8988);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(321:6) {#if phoneType === 'pwd'}",
    		ctx
    	});

    	return block;
    }

    // (338:2) {#if type === 'email'}
    function create_if_block$6(ctx) {
    	let div3;
    	let input0;
    	let t0;
    	let input1;
    	let updating_password_email;
    	let t1;
    	let div0;
    	let button;
    	let t2;
    	let div1;
    	let t4;
    	let div2;
    	let span0;
    	let t6;
    	let span1;
    	let current;
    	let mounted;
    	let dispose;

    	input0 = new Input({
    			props: { label: "", maxlength: 30, type: "text" },
    			$$inline: true
    		});

    	input0.$on("setInput", /*getEmail*/ ctx[17]);

    	function input1_password_email_binding(value) {
    		/*input1_password_email_binding*/ ctx[27](value);
    	}

    	let input1_props = {
    		label: "",
    		type: "password",
    		maxlength: "40"
    	};

    	if (/*password_email*/ ctx[3] !== void 0) {
    		input1_props.password_email = /*password_email*/ ctx[3];
    	}

    	input1 = new Input({ props: input1_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(input1, 'password_email', input1_password_email_binding));
    	input1.$on("setInput", /*getpassword_email*/ ctx[15]);

    	button = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*getClickEmail*/ ctx[12]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			create_component(input0.$$.fragment);
    			t0 = space();
    			create_component(input1.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = `${/*tiptext*/ ctx[10]}`;
    			t4 = space();
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "";
    			t6 = text("\r\n        ");
    			span1 = element("span");
    			span1.textContent = "";
    			attr_dev(div0, "class", "btn svelte-1hbo5j0");
    			add_location(div0, file$h, 341, 6, 9587);
    			attr_dev(div1, "class", "tip svelte-1hbo5j0");
    			add_location(div1, file$h, 344, 6, 9698);
    			add_location(span0, file$h, 346, 8, 9773);
    			add_location(span1, file$h, 352, 8, 9936);
    			attr_dev(div2, "class", "type-switch svelte-1hbo5j0");
    			add_location(div2, file$h, 345, 6, 9738);
    			attr_dev(div3, "class", "email");
    			add_location(div3, file$h, 338, 4, 9371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			mount_component(input0, div3, null);
    			append_dev(div3, t0);
    			mount_component(input1, div3, null);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			mount_component(button, div0, null);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div2, t6);
    			append_dev(div2, span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span0, "click", /*click_handler_5*/ ctx[28], false, false, false),
    					listen_dev(span1, "click", /*qrLoginFun*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const input1_changes = {};

    			if (!updating_password_email && dirty[0] & /*password_email*/ 8) {
    				updating_password_email = true;
    				input1_changes.password_email = /*password_email*/ ctx[3];
    				add_flush_callback(() => updating_password_email = false);
    			}

    			input1.$set(input1_changes);
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input0.$$.fragment, local);
    			transition_in(input1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(input0);
    			destroy_component(input1);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(338:2) {#if type === 'email'}",
    		ctx
    	});

    	return block;
    }

    // (343:8) <Button on:BtnClick={getClickEmail} type="primary">
    function create_default_slot$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(343:8) <Button on:BtnClick={getClickEmail} type=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let navbar;
    	let t0;
    	let div5;
    	let div0;
    	let t2;
    	let div4;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t3;
    	let div2;
    	let linksline;
    	let t4;
    	let div3;
    	let img1;
    	let img1_src_value;
    	let t5;
    	let t6;
    	let t7;
    	let current;

    	navbar = new NavBar({
    			props: { title: /*loginType*/ ctx[9] },
    			$$inline: true
    		});

    	linksline = new LinksLine({ $$inline: true });
    	let if_block0 = /*type*/ ctx[0] === 'qr' && create_if_block_7(ctx);
    	let if_block1 = /*type*/ ctx[0] === 'phone' && create_if_block_1$5(ctx);
    	let if_block2 = /*type*/ ctx[0] === 'email' && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "";
    			t2 = space();
    			div4 = element("div");
    			div1 = element("div");
    			img0 = element("img");
    			t3 = space();
    			div2 = element("div");
    			create_component(linksline.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			img1 = element("img");
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div0, "class", "desc svelte-1hbo5j0");
    			add_location(div0, file$h, 243, 2, 6870);
    			if (!src_url_equal(img0.src, img0_src_value = "/images/nm_logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			attr_dev(img0, "class", "svelte-1hbo5j0");
    			add_location(img0, file$h, 246, 6, 6963);
    			attr_dev(div1, "class", "netease svelte-1hbo5j0");
    			add_location(div1, file$h, 245, 4, 6934);
    			attr_dev(div2, "class", "arr svelte-1hbo5j0");
    			add_location(div2, file$h, 248, 4, 7021);
    			if (!src_url_equal(img1.src, img1_src_value = "/images/sm_logo.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "class", "svelte-1hbo5j0");
    			add_location(img1, file$h, 251, 24, 7097);
    			attr_dev(div3, "class", "simple svelte-1hbo5j0");
    			add_location(div3, file$h, 251, 4, 7077);
    			attr_dev(div4, "class", "lead svelte-1hbo5j0");
    			add_location(div4, file$h, 244, 2, 6910);
    			attr_dev(div5, "class", "login-page svelte-1hbo5j0");
    			add_location(div5, file$h, 242, 0, 6842);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, img0);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			mount_component(linksline, div2, null);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, img1);
    			append_dev(div5, t5);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t6);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t7);
    			if (if_block2) if_block2.m(div5, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbar_changes = {};
    			if (dirty[0] & /*loginType*/ 512) navbar_changes.title = /*loginType*/ ctx[9];
    			navbar.$set(navbar_changes);

    			if (/*type*/ ctx[0] === 'qr') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, t6);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[0] === 'phone') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div5, t7);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*type*/ ctx[0] === 'email') {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*type*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div5, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(linksline.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(linksline.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div5);
    			destroy_component(linksline);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isPhone(phone) {
    	//
    	let mPattern = /^1[3-9]\d{9}$/;

    	// true or false
    	return mPattern.test(phone);
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let phoneType;
    	let loginType;
    	let qrImg;
    	let qrTip;
    	let btnText;
    	let $userInfoStore;
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(31, $userInfoStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	let timerLogin = null;
    	let phone = '';
    	let email = '';
    	let password_phone = '';
    	let password_email = '';
    	let code_phone = '';
    	let type = 'phone';
    	let tiptext = ' MD5  API https://github.com/dufu1991/simple-cloud-music ';

    	function loginSuccFun(res) {
    		//
    		setCookies(res.cookie);

    		userInfoStore.set(res);
    		localStorage.setItem('userInfo', JSON.stringify(res));
    		userPlaylistFun(res);
    	}

    	//
    	async function getClickPhone() {
    		if (!isPhone(phone)) {
    			Toast$1('');
    		} else if (phoneType === 'code' && code_phone.length != 4) {
    			Toast$1('');
    		} else {
    			let params = {};

    			if (phoneType === 'code') {
    				//
    				params = {
    					phone,
    					captcha: code_phone,
    					password: 'fakePassword'
    				};
    			} else {
    				//
    				params = {
    					phone,
    					md5_password: password_phone,
    					password: 'fakePassword'
    				};
    			}

    			const res = await loginWithPhone(params);

    			if (res.code === 200) {
    				loginSuccFun(res);
    			} else {
    				Alert(', ');
    			}
    		}
    	}

    	//
    	async function getClickEmail() {
    		const res = await loginWithEmail({
    			email,
    			md5_password: password_email,
    			password: 'fakePassword'
    		});

    		if (res.code === 200) {
    			loginSuccFun(res);
    		} else {
    			Alert(', ');
    		}
    	}

    	onMount(() => {
    		isHomePageStore.set(false);
    		playIsMinStore.set(false);
    	});

    	onDestroy(() => {
    		playIsMinStore.set(true);
    	});

    	function getpassword_phone(e) {
    		$$invalidate(2, password_phone = md5(e.detail.value).toString());
    	}

    	function getcode_phone(e) {
    		$$invalidate(4, code_phone = e.detail.value.toString());
    	}

    	function getpassword_email(e) {
    		email_phone = md5(e.detail.value).toString();
    	}

    	function getPhone(e) {
    		phone = e.detail.value;
    	}

    	function getEmail(e) {
    		email = e.detail.value;
    	}

    	async function userPlaylistFun(login) {
    		//ID,
    		const res = await userPlaylist({
    			uid: login.account.id,
    			limit: 10000,
    			offset: 0
    		});

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.playlist.length; i++) {
    				ids.push(res.playlist[i].id);
    			}

    			if (res.playlist[0].creator.userId === $userInfoStore.account.id && res.playlist[0].name.substr(-5) === '') {
    				userLikeListIdStore.set(res.playlist[0].id);
    				localStorage.setItem('userLikeListId', res.playlist[0].id);
    			}

    			localStorage.setItem('usePlayListIds', JSON.stringify(ids));
    			userLikedSongsIDsFun(login);
    		} else {
    			Alert('');
    		}
    	}

    	async function userLikedSongsIDsFun(login) {
    		//ID,
    		const res = await userLikedSongsIDs(login.account.id);

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.ids.length; i++) {
    				ids.push(res.ids[i]);
    			}

    			isLoginStore.set(true);
    			localStorage.setItem('isLogin', true);
    			userLikeSongIdsStore.set(JSON.stringify(ids));
    			localStorage.setItem('useLoveSongIds', JSON.stringify(ids));
    			likedArtistsFun();
    		} else {
    			alert('');
    		}
    	}

    	//
    	async function likedArtistsFun() {
    		const res = await likedArtists({ limit: 2000 });

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.data.length; i++) {
    				ids.push(res.data[i].id);
    			}

    			localStorage.setItem('useLoveSongerIds', JSON.stringify(ids));

    			setTimeout(
    				() => {
    					pop();
    				},
    				100
    			);
    		} else {
    			alert('');
    		}
    	}

    	async function qrLoginFun() {
    		$$invalidate(0, type = 'qr');
    		const res = await loginQrCodeKey();

    		if (res.code === 200) {
    			loginQrCodeCreateFun(res.data.unikey);
    		}
    	}

    	async function loginQrCodeCreateFun(key) {
    		const res = await loginQrCodeCreate({ key });

    		if (res.code === 200) {
    			$$invalidate(7, qrImg = res.data.qrurl);

    			$$invalidate(1, timerLogin = setInterval(
    				() => {
    					loginQrCodeCheckFun(key);
    				},
    				1000
    			));
    		}
    	}

    	async function loginQrCodeCheckFun(key) {
    		const res = await loginQrCodeCheck(key);

    		if (res.code === 800) {
    			$$invalidate(6, qrTip = res.message);
    		} else if (res.code === 801) {
    			$$invalidate(6, qrTip = res.message);
    		} else if (res.code === 802) {
    			$$invalidate(6, qrTip = res.message);
    		} else if (res.code === 803) {
    			clearInterval(timerLogin);

    			setTimeout(
    				() => {
    					userAccountFun(res.cookie);
    				},
    				300
    			);
    		} else {
    			clearInterval(timerLogin);
    		}
    	}

    	async function userAccountFun(cookie) {
    		const res = await userAccount(cookie);

    		if (res.code === 200) {
    			let newres = res;
    			newres.cookie = cookie;
    			loginSuccFun(newres);
    		}
    	}

    	async function sendSmsCodeFun() {
    		if (btnText === '') {
    			if (!isPhone(phone)) {
    				Toast$1('');
    			} else {
    				const res = await sendSmsCode(phone);

    				if (res.code === 200) {
    					Toast$1('' + phone.substring(phone.length - 4) + '', 2000);
    					setinter60();
    				}
    			}
    		}
    	}

    	function setinter60() {
    		let time = 59;

    		let myTimer = setInterval(
    			() => {
    				time--;

    				if (time === 0) {
    					clearInterval(myTimer);
    					$$invalidate(5, btnText = '');
    				} else {
    					$$invalidate(5, btnText = time + 's ');
    				}
    			},
    			1000
    		);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		clearInterval(timerLogin);
    		$$invalidate(0, type = 'phone');
    	};

    	const click_handler_1 = () => {
    		clearInterval(timerLogin);
    		$$invalidate(0, type = 'email');
    	};

    	function input_password_phone_binding(value) {
    		password_phone = value;
    		$$invalidate(2, password_phone);
    	}

    	function input_code_phone_binding(value) {
    		code_phone = value;
    		$$invalidate(4, code_phone);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(8, phoneType = 'code');
    	};

    	const click_handler_3 = () => {
    		$$invalidate(8, phoneType = 'pwd');
    	};

    	const click_handler_4 = () => {
    		$$invalidate(0, type = 'email');
    		clearInterval(timerLogin);
    	};

    	function input1_password_email_binding(value) {
    		password_email = value;
    		$$invalidate(3, password_email);
    	}

    	const click_handler_5 = () => {
    		clearInterval(timerLogin);
    		$$invalidate(0, type = 'phone');
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		pop,
    		md5,
    		LinksLine,
    		QrCode: Lib,
    		NavBar,
    		Input,
    		Button,
    		isHomePageStore,
    		isLoginStore,
    		playIsMinStore,
    		userInfoStore,
    		userLikeSongIdsStore,
    		userLikeListIdStore,
    		loginWithPhone,
    		loginWithEmail,
    		loginQrCodeKey,
    		loginQrCodeCreate,
    		loginQrCodeCheck,
    		userPlaylist,
    		userLikedSongsIDs,
    		likedArtists,
    		userAccount,
    		sendSmsCode,
    		setCookies,
    		Alert,
    		Toast: Toast$1,
    		timerLogin,
    		phone,
    		email,
    		password_phone,
    		password_email,
    		code_phone,
    		type,
    		tiptext,
    		loginSuccFun,
    		getClickPhone,
    		getClickEmail,
    		getpassword_phone,
    		getcode_phone,
    		getpassword_email,
    		getPhone,
    		getEmail,
    		userPlaylistFun,
    		userLikedSongsIDsFun,
    		likedArtistsFun,
    		qrLoginFun,
    		loginQrCodeCreateFun,
    		loginQrCodeCheckFun,
    		userAccountFun,
    		sendSmsCodeFun,
    		setinter60,
    		isPhone,
    		btnText,
    		qrTip,
    		qrImg,
    		phoneType,
    		loginType,
    		$userInfoStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('timerLogin' in $$props) $$invalidate(1, timerLogin = $$props.timerLogin);
    		if ('phone' in $$props) phone = $$props.phone;
    		if ('email' in $$props) email = $$props.email;
    		if ('password_phone' in $$props) $$invalidate(2, password_phone = $$props.password_phone);
    		if ('password_email' in $$props) $$invalidate(3, password_email = $$props.password_email);
    		if ('code_phone' in $$props) $$invalidate(4, code_phone = $$props.code_phone);
    		if ('type' in $$props) $$invalidate(0, type = $$props.type);
    		if ('tiptext' in $$props) $$invalidate(10, tiptext = $$props.tiptext);
    		if ('btnText' in $$props) $$invalidate(5, btnText = $$props.btnText);
    		if ('qrTip' in $$props) $$invalidate(6, qrTip = $$props.qrTip);
    		if ('qrImg' in $$props) $$invalidate(7, qrImg = $$props.qrImg);
    		if ('phoneType' in $$props) $$invalidate(8, phoneType = $$props.phoneType);
    		if ('loginType' in $$props) $$invalidate(9, loginType = $$props.loginType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*type*/ 1) {
    			$$invalidate(9, loginType = type === 'qr'
    			? ''
    			: type === 'phone' ? '' : '');
    		}
    	};

    	$$invalidate(8, phoneType = 'code'); //code--pwd--
    	$$invalidate(7, qrImg = '');
    	$$invalidate(6, qrTip = '');
    	$$invalidate(5, btnText = '');

    	return [
    		type,
    		timerLogin,
    		password_phone,
    		password_email,
    		code_phone,
    		btnText,
    		qrTip,
    		qrImg,
    		phoneType,
    		loginType,
    		tiptext,
    		getClickPhone,
    		getClickEmail,
    		getpassword_phone,
    		getcode_phone,
    		getpassword_email,
    		getPhone,
    		getEmail,
    		qrLoginFun,
    		sendSmsCodeFun,
    		click_handler,
    		click_handler_1,
    		input_password_phone_binding,
    		input_code_phone_binding,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		input1_password_email_binding,
    		click_handler_5
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\pages\TodayListDetail.svelte generated by Svelte v3.46.4 */
    const file$g = "src\\pages\\TodayListDetail.svelte";

    // (101:6) <Button type="primary" on:BtnClick={() => playListFun(0)}>
    function create_default_slot$9(ctx) {
    	let span;
    	let playcircleline;
    	let t;
    	let current;

    	playcircleline = new PlayCircleLine({
    			props: {
    				size: "22",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(playcircleline.$$.fragment);
    			t = text("\r\n        ");
    			attr_dev(span, "class", "icon svelte-1cxuvfh");
    			add_location(span, file$g, 101, 8, 3420);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(playcircleline, span, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playcircleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playcircleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(playcircleline);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(101:6) <Button type=\\\"primary\\\" on:BtnClick={() => playListFun(0)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let navbar;
    	let t0;
    	let div5;
    	let div0;
    	let t2;
    	let div1;
    	let t3;
    	let t4_value = /*songList*/ ctx[0].length + "";
    	let t4;
    	let t5;
    	let t6;
    	let div3;
    	let div2;
    	let button;
    	let t7;
    	let div4;
    	let songlist;
    	let current;

    	navbar = new NavBar({
    			props: { title: "" },
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*BtnClick_handler*/ ctx[2]);

    	songlist = new SongList({
    			props: { songList: /*songList*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "";
    			t2 = space();
    			div1 = element("div");
    			t3 = text(" ");
    			t4 = text(t4_value);
    			t5 = text("   6:00");
    			t6 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(button.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			create_component(songlist.$$.fragment);
    			attr_dev(div0, "class", "today-title svelte-1cxuvfh");
    			add_location(div0, file$g, 94, 2, 3177);
    			attr_dev(div1, "class", "today-desc svelte-1cxuvfh");
    			add_location(div1, file$g, 95, 2, 3218);
    			attr_dev(div2, "class", "play svelte-1cxuvfh");
    			add_location(div2, file$g, 99, 4, 3326);
    			attr_dev(div3, "class", "btn svelte-1cxuvfh");
    			add_location(div3, file$g, 98, 2, 3303);
    			add_location(div4, file$g, 108, 2, 3584);
    			attr_dev(div5, "class", "play-list svelte-1cxuvfh");
    			add_location(div5, file$g, 93, 0, 3150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t2);
    			append_dev(div5, div1);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div1, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			mount_component(button, div2, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			mount_component(songlist, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*songList*/ 1) && t4_value !== (t4_value = /*songList*/ ctx[0].length + "")) set_data_dev(t4, t4_value);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const songlist_changes = {};
    			if (dirty & /*songList*/ 1) songlist_changes.songList = /*songList*/ ctx[0];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div5);
    			destroy_component(button);
    			destroy_component(songlist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let songList;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $todayListStore;
    	let $defaultResumableStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(3, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(4, $currentPlayListStore = $$value));
    	validate_store(todayListStore, 'todayListStore');
    	component_subscribe($$self, todayListStore, $$value => $$invalidate(5, $todayListStore = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(6, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TodayListDetail', slots, []);

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			let songIdList = [];

    			for (let i = 0; i < $todayListStore.length; i++) {
    				songIdList.push($todayListStore[i].id);
    			}

    			getSongDetailFun(songIdList.join(','));
    			getSongUrl(songIdList[0]);
    		}
    	});

    	onMount(() => {
    		let songIdList = [];

    		for (let i = 0; i < $todayListStore.length; i++) {
    			songIdList.push($todayListStore[i].id);
    		}

    		getSongDetailFun(songIdList.join(','));
    		getSongUrl(songIdList[0]);
    	});

    	async function getSongDetailFun(songIds) {
    		const res = await getSongDetail(songIds); //

    		if (res.code === 200) {
    			playListDetailStore.set(res.songs);
    			$$invalidate(0, songList = res.songs);
    		}
    	}

    	function playListFun(index) {
    		playRepeatModelStore.set('repeat');
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentPlayListStore.set(songList);
    		let ids = [];

    		for (let r = 0; r < songList.length; r++) {
    			ids.push(songList[r].id);
    		}

    		localStorage.setItem('localPlayList', JSON.stringify(ids));
    		currentSongIndexStore.set(index);
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TodayListDetail> was created with unknown prop '${key}'`);
    	});

    	const BtnClick_handler = () => playListFun(0);

    	$$self.$capture_state = () => ({
    		onMount,
    		PlayCircleLine,
    		onResume,
    		Button,
    		NavBar,
    		SongList,
    		getSongUrl,
    		getSongDetail,
    		playListDetailStore,
    		todayListStore,
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		defaultResumableStore,
    		Toast: Toast$1,
    		getSongDetailFun,
    		playListFun,
    		getSongUrlFun,
    		songList,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$todayListStore,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('songList' in $$props) $$invalidate(0, songList = $$props.songList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(0, songList = []);
    	return [songList, playListFun, BtnClick_handler];
    }

    class TodayListDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TodayListDetail",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src\pages\LoveListDetail.svelte generated by Svelte v3.46.4 */
    const file$f = "src\\pages\\LoveListDetail.svelte";

    // (193:2) {#if isSearch}
    function create_if_block_3$1(ctx) {
    	let div;
    	let form;
    	let input;
    	let t0;
    	let button;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			form = element("form");
    			input = element("input");
    			t0 = space();
    			button = element("button");
    			t1 = text("");
    			attr_dev(input, "placeholder", "");
    			attr_dev(input, "type", "search");
    			input.value = /*keywords*/ ctx[4];
    			attr_dev(input, "class", "svelte-1i0xqe3");
    			add_location(input, file$f, 195, 8, 6277);
    			attr_dev(form, "action", "JavaScript:void 0");
    			attr_dev(form, "class", "svelte-1i0xqe3");
    			add_location(form, file$f, 194, 6, 6234);

    			set_style(button, "background-color", /*keywords*/ ctx[4] === ''
    			? 'rgb(224, 224, 224)'
    			: 'var(--primary-text-color)');

    			set_style(button, "color", /*keywords*/ ctx[4] === '' ? '#666' : '#fff');
    			attr_dev(button, "class", "svelte-1i0xqe3");
    			add_location(button, file$f, 197, 6, 6382);
    			attr_dev(div, "class", "input-box svelte-1i0xqe3");
    			add_location(div, file$f, 193, 4, 6203);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, form);
    			append_dev(form, input);
    			/*input_binding*/ ctx[12](input);
    			append_dev(div, t0);
    			append_dev(div, button);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*keywords*/ 16 && input.value !== /*keywords*/ ctx[4]) {
    				prop_dev(input, "value", /*keywords*/ ctx[4]);
    			}

    			if (dirty & /*keywords*/ 16) {
    				set_style(button, "background-color", /*keywords*/ ctx[4] === ''
    				? 'rgb(224, 224, 224)'
    				: 'var(--primary-text-color)');
    			}

    			if (dirty & /*keywords*/ 16) {
    				set_style(button, "color", /*keywords*/ ctx[4] === '' ? '#666' : '#fff');
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*input_binding*/ ctx[12](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(193:2) {#if isSearch}",
    		ctx
    	});

    	return block;
    }

    // (213:4) {#if isSearch && keywords != ''}
    function create_if_block_2$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*searchSongList*/ ctx[5].length + "";
    	let t1;
    	let t2;
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			t0 = text(" ");
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = text(" ");
    			t3 = text(/*keywords*/ ctx[4]);
    			t4 = text("");
    			add_location(span, file$f, 213, 10, 6843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*searchSongList*/ 32 && t1_value !== (t1_value = /*searchSongList*/ ctx[5].length + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*keywords*/ 16) set_data_dev(t3, /*keywords*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(213:4) {#if isSearch && keywords != ''}",
    		ctx
    	});

    	return block;
    }

    // (219:2) {:else}
    function create_else_block_1(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t;
    	let div1;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("BtnClick", /*BtnClick_handler*/ ctx[14]);

    	button1 = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("BtnClick", /*playListShuffleFun*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(button1.$$.fragment);
    			attr_dev(div0, "class", "play svelte-1i0xqe3");
    			add_location(div0, file$f, 220, 6, 7007);
    			attr_dev(div1, "class", "play svelte-1i0xqe3");
    			add_location(div1, file$f, 228, 6, 7273);
    			attr_dev(div2, "class", "btn svelte-1i0xqe3");
    			add_location(div2, file$f, 219, 4, 6982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(button0, div0, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			mount_component(button1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(219:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (217:2) {#if isSearch && keywords != ''}
    function create_if_block_1$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			add_location(div, file$f, 217, 4, 6958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(217:2) {#if isSearch && keywords != ''}",
    		ctx
    	});

    	return block;
    }

    // (222:8) <Button type="primary" on:BtnClick={() => playListFun(0)}>
    function create_default_slot_1$1(ctx) {
    	let span;
    	let playcircleline;
    	let t;
    	let current;

    	playcircleline = new PlayCircleLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(playcircleline.$$.fragment);
    			t = text("\r\n          ");
    			attr_dev(span, "class", "icon svelte-1i0xqe3");
    			add_location(span, file$f, 222, 10, 7105);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(playcircleline, span, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playcircleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playcircleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(playcircleline);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(222:8) <Button type=\\\"primary\\\" on:BtnClick={() => playListFun(0)}>",
    		ctx
    	});

    	return block;
    }

    // (230:8) <Button type="primary" on:BtnClick={playListShuffleFun}>
    function create_default_slot$8(ctx) {
    	let span;
    	let shuffleline;
    	let t;
    	let current;

    	shuffleline = new ShuffleLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(shuffleline.$$.fragment);
    			t = text("\r\n          ");
    			attr_dev(span, "class", "icon svelte-1i0xqe3");
    			add_location(span, file$f, 230, 10, 7369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(shuffleline, span, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shuffleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shuffleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(shuffleline);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(230:8) <Button type=\\\"primary\\\" on:BtnClick={playListShuffleFun}>",
    		ctx
    	});

    	return block;
    }

    // (242:4) {:else}
    function create_else_block$2(ctx) {
    	let songlist;
    	let current;

    	songlist = new SongList({
    			props: { songList: /*songList*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songlist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songlist_changes = {};
    			if (dirty & /*songList*/ 4) songlist_changes.songList = /*songList*/ ctx[2];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(242:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (240:4) {#if isSearch && keywords != ''}
    function create_if_block$5(ctx) {
    	let songlist;
    	let current;

    	songlist = new SongList({
    			props: { songList: /*searchSongList*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songlist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songlist_changes = {};
    			if (dirty & /*searchSongList*/ 32) songlist_changes.songList = /*searchSongList*/ ctx[5];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(240:4) {#if isSearch && keywords != ''}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let navbar;
    	let t0;
    	let div3;
    	let t1;
    	let div0;
    	let t3;
    	let div1;
    	let t4;
    	let t5_value = /*songList*/ ctx[2].length + "";
    	let t5;
    	let t6;
    	let t7;
    	let current_block_type_index;
    	let if_block2;
    	let t8;
    	let div2;
    	let current_block_type_index_1;
    	let if_block3;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: /*$userInfoStore*/ ctx[6].profile.nickname + '',
    				isRefresh: /*isRefresh*/ ctx[3],
    				rightIcons: /*rightIcons*/ ctx[7]
    			},
    			$$inline: true
    		});

    	navbar.$on("setRightIconClick", /*rightClickFun*/ ctx[11]);
    	let if_block0 = /*isSearch*/ ctx[1] && create_if_block_3$1(ctx);
    	let if_block1 = /*isSearch*/ ctx[1] && /*keywords*/ ctx[4] != '' && create_if_block_2$1(ctx);
    	const if_block_creators = [create_if_block_1$4, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSearch*/ ctx[1] && /*keywords*/ ctx[4] != '') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const if_block_creators_1 = [create_if_block$5, create_else_block$2];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isSearch*/ ctx[1] && /*keywords*/ ctx[4] != '') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "";
    			t3 = space();
    			div1 = element("div");
    			t4 = text(" ");
    			t5 = text(t5_value);
    			t6 = text(" \r\n    ");
    			if (if_block1) if_block1.c();
    			t7 = space();
    			if_block2.c();
    			t8 = space();
    			div2 = element("div");
    			if_block3.c();
    			attr_dev(div0, "class", "today-title svelte-1i0xqe3");
    			add_location(div0, file$f, 209, 2, 6701);
    			attr_dev(div1, "class", "today-desc svelte-1i0xqe3");
    			add_location(div1, file$f, 210, 2, 6742);
    			add_location(div2, file$f, 238, 2, 7551);
    			attr_dev(div3, "class", "play-list svelte-1i0xqe3");
    			add_location(div3, file$f, 191, 0, 6156);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div3, anchor);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div3, t7);
    			if_blocks[current_block_type_index].m(div3, null);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			if_blocks_1[current_block_type_index_1].m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*$userInfoStore*/ 64) navbar_changes.title = /*$userInfoStore*/ ctx[6].profile.nickname + '';
    			if (dirty & /*isRefresh*/ 8) navbar_changes.isRefresh = /*isRefresh*/ ctx[3];
    			navbar.$set(navbar_changes);

    			if (/*isSearch*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(div3, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty & /*songList*/ 4) && t5_value !== (t5_value = /*songList*/ ctx[2].length + "")) set_data_dev(t5, t5_value);

    			if (/*isSearch*/ ctx[1] && /*keywords*/ ctx[4] != '') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div3, t8);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_1[current_block_type_index_1];

    				if (!if_block3) {
    					if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block3.c();
    				} else {
    					if_block3.p(ctx, dirty);
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(div2, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    			if_blocks_1[current_block_type_index_1].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let keywords;
    	let isSearch;
    	let songList;
    	let searchSongList;
    	let isRefresh;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $userLikeListIdStore;
    	let $defaultResumableStore;
    	let $userInfoStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(15, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(16, $currentPlayListStore = $$value));
    	validate_store(userLikeListIdStore, 'userLikeListIdStore');
    	component_subscribe($$self, userLikeListIdStore, $$value => $$invalidate(17, $userLikeListIdStore = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(18, $defaultResumableStore = $$value));
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(6, $userInfoStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LoveListDetail', slots, []);
    	let inputDom;
    	let rightIcons = [{ id: 'SearchLine', icon: SearchLine }];

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			$$invalidate(2, songList = []);
    			$$invalidate(1, isSearch = false);
    			$$invalidate(5, searchSongList = []);
    			$$invalidate(4, keywords = '');
    			isHomePageStore.set(false);
    			getPlaylistDetailFun();
    		}
    	});

    	onMount(() => {
    		isHomePageStore.set(false);
    		getPlaylistDetailFun();
    	});

    	onDestroy(() => {
    		isHomePageStore.set(true);
    	});

    	function inputchange(e) {
    		setTimeout(
    			() => {
    				//
    				if (!e.target.isNeedPrevent && e.target.oldValue !== e.target.value) {
    					//
    					e.target.oldValue = e.target.value;

    					$$invalidate(4, keywords = e.target.value);
    					searchFun();
    				}
    			},
    			100
    		);
    	}

    	//
    	function searchFun() {
    		if (keywords.trim() != '') {
    			// inputDom.blur();
    			$$invalidate(5, searchSongList = songList.filter(item => item.name.indexOf(keywords) > -1 || songerListToStr(item.ar).indexOf(keywords) > -1 || songerListToStr(item.alia, false).indexOf(keywords) > -1));
    		}
    	}

    	//
    	async function getPlaylistDetailFun() {
    		const res = await getPlaylistDetail($userLikeListIdStore); //

    		if (res.code === 200) {
    			isLoadingStore.set(true);
    			let songIdList = [];

    			for (let i = 0; i < res.playlist.trackIds.length; i++) {
    				songIdList.push(res.playlist.trackIds[i].id);
    			}

    			let cutSongIdList = cutArray(songIdList);

    			for (let t = 0; t < cutSongIdList.length; t++) {
    				await getSongDetailFun(cutSongIdList[t].join(','), t === cutSongIdList.length - 1);
    			}
    		}
    	}

    	//
    	async function getSongDetailFun(songIds, last) {
    		const res = await getSongDetail(songIds);

    		if (res.code === 200) {
    			$$invalidate(2, songList = songList.concat(res.songs));

    			if (last) {
    				$$invalidate(3, isRefresh = false);
    			}
    		}
    	}

    	//
    	function playListFun(index) {
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentPlayListStore.set(songList);
    		let ids = [];

    		for (let r = 0; r < songList.length; r++) {
    			ids.push(songList[r].id);
    		}

    		localStorage.setItem('localPlayList', JSON.stringify(ids));
    		currentSongIndexStore.set(index);
    		playRepeatModelStore.set('repeat');
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    	}

    	//
    	function playListShuffleFun() {
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentPlayListStore.set(songList);
    		let ids = [];

    		for (let r = 0; r < songList.length; r++) {
    			ids.push(songList[r].id);
    		}

    		localStorage.setItem('localPlayList', JSON.stringify(ids));
    		let index = Math.floor(Math.random() * ($currentPlayListStore.length - 1));
    		playRepeatModelStore.set('shuffle');
    		currentSongIndexStore.set(index);
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	function rightClickFun(e) {
    		if (e.detail.id === 'SearchLine' && isSearch) {
    			$$invalidate(1, isSearch = false);
    		} else if (e.detail.id === 'SearchLine' && !isSearch) {
    			$$invalidate(1, isSearch = true);

    			setTimeout(
    				() => {
    					inputDom.focus();

    					inputDom.addEventListener('compositionstart', function (e) {
    						//
    						e.target.isNeedPrevent = true;
    					});

    					inputDom.addEventListener('compositionend', function (e) {
    						//
    						e.target.isNeedPrevent = false;
    					});

    					inputDom.addEventListener('input', inputchange);

    					inputDom.addEventListener('keydown', function (e) {
    						if (e.key === 'Enter') {
    							inputDom.blur();
    							searchFun();
    						}
    					});
    				},
    				100
    			);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoveListDetail> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputDom = $$value;
    			$$invalidate(0, inputDom);
    		});
    	}

    	const click_handler = () => {
    		inputDom.blur();
    		searchFun();
    	};

    	const BtnClick_handler = () => playListFun(0);

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		onResume,
    		PlayCircleLine,
    		ShuffleLine,
    		SearchLine,
    		RefreshLine,
    		Button,
    		NavBar,
    		SongList,
    		isHomePageStore,
    		isLoadingStore,
    		defaultResumableStore,
    		userInfoStore,
    		userLikeListIdStore,
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		getSongUrl,
    		getSongDetail,
    		getPlaylistDetail,
    		Toast: Toast$1,
    		cutArray,
    		songerListToStr,
    		inputDom,
    		rightIcons,
    		inputchange,
    		searchFun,
    		getPlaylistDetailFun,
    		getSongDetailFun,
    		playListFun,
    		playListShuffleFun,
    		getSongUrlFun,
    		rightClickFun,
    		isSearch,
    		songList,
    		isRefresh,
    		keywords,
    		searchSongList,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$userLikeListIdStore,
    		$defaultResumableStore,
    		$userInfoStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputDom' in $$props) $$invalidate(0, inputDom = $$props.inputDom);
    		if ('rightIcons' in $$props) $$invalidate(7, rightIcons = $$props.rightIcons);
    		if ('isSearch' in $$props) $$invalidate(1, isSearch = $$props.isSearch);
    		if ('songList' in $$props) $$invalidate(2, songList = $$props.songList);
    		if ('isRefresh' in $$props) $$invalidate(3, isRefresh = $$props.isRefresh);
    		if ('keywords' in $$props) $$invalidate(4, keywords = $$props.keywords);
    		if ('searchSongList' in $$props) $$invalidate(5, searchSongList = $$props.searchSongList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(4, keywords = '');
    	$$invalidate(1, isSearch = false);
    	$$invalidate(2, songList = []);
    	$$invalidate(5, searchSongList = []); //
    	$$invalidate(3, isRefresh = false);

    	return [
    		inputDom,
    		isSearch,
    		songList,
    		isRefresh,
    		keywords,
    		searchSongList,
    		$userInfoStore,
    		rightIcons,
    		searchFun,
    		playListFun,
    		playListShuffleFun,
    		rightClickFun,
    		input_binding,
    		click_handler,
    		BtnClick_handler
    	];
    }

    class LoveListDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoveListDetail",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\components\MiniPlayListCover.svelte generated by Svelte v3.46.4 */
    const file$e = "src\\components\\MiniPlayListCover.svelte";

    // (39:4) <Lazy height={width}>
    function create_default_slot$7(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[0].replace(/^http:/, 'https:') + `?param=${/*width*/ ctx[3] * 2}y${/*width*/ ctx[3] * 2}`)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-ub7aiu");
    			add_location(img, file$e, 39, 6, 1133);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coverImgUrl, width*/ 9 && !src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[0].replace(/^http:/, 'https:') + `?param=${/*width*/ ctx[3] * 2}y${/*width*/ ctx[3] * 2}`)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(39:4) <Lazy height={width}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div3;
    	let div0;
    	let lazy;
    	let t0;
    	let div1;
    	let span;
    	let playminiline;
    	let t1;
    	let t2_value = tranNumber(/*playCount*/ ctx[1]) + "";
    	let t2;
    	let t3;
    	let div2;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;

    	lazy = new Src({
    			props: {
    				height: /*width*/ ctx[3],
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	playminiline = new PlayMiniLine({ $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(lazy.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			span = element("span");
    			create_component(playminiline.$$.fragment);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(/*name*/ ctx[2]);
    			attr_dev(div0, "class", "cover-img svelte-ub7aiu");
    			set_style(div0, "width", /*width*/ ctx[3] + "px");
    			set_style(div0, "height", /*width*/ ctx[3] + "px");
    			add_location(div0, file$e, 37, 2, 1034);
    			set_style(span, "position", "relative");
    			set_style(span, "top", "1px");
    			add_location(span, file$e, 43, 4, 1285);
    			attr_dev(div1, "class", "play-num svelte-ub7aiu");
    			add_location(div1, file$e, 42, 2, 1257);
    			attr_dev(div2, "class", "name svelte-ub7aiu");
    			set_style(div2, "width", /*width*/ ctx[3] + "px");
    			add_location(div2, file$e, 48, 2, 1406);
    			attr_dev(div3, "class", "cover svelte-ub7aiu");
    			set_style(div3, "width", /*width*/ ctx[3] + "px");
    			add_location(div3, file$e, 36, 0, 944);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(lazy, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div1, span);
    			mount_component(playminiline, span, null);
    			append_dev(div1, t1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, t4);
    			/*div3_binding*/ ctx[8](div3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div3, "click", /*goToDetail*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const lazy_changes = {};
    			if (dirty & /*width*/ 8) lazy_changes.height = /*width*/ ctx[3];

    			if (dirty & /*$$scope, coverImgUrl, width*/ 521) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);

    			if (!current || dirty & /*width*/ 8) {
    				set_style(div0, "width", /*width*/ ctx[3] + "px");
    			}

    			if (!current || dirty & /*width*/ 8) {
    				set_style(div0, "height", /*width*/ ctx[3] + "px");
    			}

    			if ((!current || dirty & /*playCount*/ 2) && t2_value !== (t2_value = tranNumber(/*playCount*/ ctx[1]) + "")) set_data_dev(t2, t2_value);
    			if (!current || dirty & /*name*/ 4) set_data_dev(t4, /*name*/ ctx[2]);

    			if (!current || dirty & /*width*/ 8) {
    				set_style(div2, "width", /*width*/ ctx[3] + "px");
    			}

    			if (!current || dirty & /*width*/ 8) {
    				set_style(div3, "width", /*width*/ ctx[3] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy.$$.fragment, local);
    			transition_in(playminiline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy.$$.fragment, local);
    			transition_out(playminiline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(lazy);
    			destroy_component(playminiline);
    			/*div3_binding*/ ctx[8](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MiniPlayListCover', slots, []);
    	let { coverImgUrl = '' } = $$props;
    	let { playCount = 0 } = $$props;
    	let { name = '' } = $$props;
    	let { id = 0 } = $$props;
    	let { width = 150 } = $$props;
    	let { trackCount = 0 } = $$props;
    	let coverDom;

    	onMount(() => {
    		if (coverDom) {
    			ripple(coverDom);
    		}
    	});

    	function goToDetail() {
    		playListIdStore.set(id);
    		isHomePageStore.set(false);

    		if (trackCount > 1000) {
    			Confirm('  ' + trackCount + ' ', async () => {
    				push('/playlistdetail');
    			});
    		} else {
    			push('/playlistdetail');
    		}
    	}

    	const writable_props = ['coverImgUrl', 'playCount', 'name', 'id', 'width', 'trackCount'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MiniPlayListCover> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			coverDom = $$value;
    			$$invalidate(4, coverDom);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('coverImgUrl' in $$props) $$invalidate(0, coverImgUrl = $$props.coverImgUrl);
    		if ('playCount' in $$props) $$invalidate(1, playCount = $$props.playCount);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('id' in $$props) $$invalidate(6, id = $$props.id);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    		if ('trackCount' in $$props) $$invalidate(7, trackCount = $$props.trackCount);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		push,
    		PlayMiniLine,
    		playListIdStore,
    		isHomePageStore,
    		ripple,
    		tranNumber,
    		Confirm,
    		coverImgUrl,
    		playCount,
    		name,
    		id,
    		width,
    		trackCount,
    		coverDom,
    		goToDetail
    	});

    	$$self.$inject_state = $$props => {
    		if ('coverImgUrl' in $$props) $$invalidate(0, coverImgUrl = $$props.coverImgUrl);
    		if ('playCount' in $$props) $$invalidate(1, playCount = $$props.playCount);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('id' in $$props) $$invalidate(6, id = $$props.id);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    		if ('trackCount' in $$props) $$invalidate(7, trackCount = $$props.trackCount);
    		if ('coverDom' in $$props) $$invalidate(4, coverDom = $$props.coverDom);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		coverImgUrl,
    		playCount,
    		name,
    		width,
    		coverDom,
    		goToDetail,
    		id,
    		trackCount,
    		div3_binding
    	];
    }

    class MiniPlayListCover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			coverImgUrl: 0,
    			playCount: 1,
    			name: 2,
    			id: 6,
    			width: 3,
    			trackCount: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MiniPlayListCover",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get coverImgUrl() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set coverImgUrl(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get playCount() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playCount(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trackCount() {
    		throw new Error("<MiniPlayListCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trackCount(value) {
    		throw new Error("<MiniPlayListCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\pages\MyAllPlayList.svelte generated by Svelte v3.46.4 */
    const file$d = "src\\pages\\MyAllPlayList.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (60:4) <Lazy height={180}>
    function create_default_slot$6(ctx) {
    	let miniplaylistcover;
    	let t;
    	let current;

    	miniplaylistcover = new MiniPlayListCover({
    			props: {
    				name: /*play*/ ctx[5].name,
    				coverImgUrl: /*play*/ ctx[5].coverImgUrl,
    				id: /*play*/ ctx[5].id,
    				playCount: /*play*/ ctx[5].playCount,
    				trackCount: /*play*/ ctx[5].trackCount
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(miniplaylistcover.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(miniplaylistcover, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const miniplaylistcover_changes = {};
    			if (dirty & /*playList*/ 1) miniplaylistcover_changes.name = /*play*/ ctx[5].name;
    			if (dirty & /*playList*/ 1) miniplaylistcover_changes.coverImgUrl = /*play*/ ctx[5].coverImgUrl;
    			if (dirty & /*playList*/ 1) miniplaylistcover_changes.id = /*play*/ ctx[5].id;
    			if (dirty & /*playList*/ 1) miniplaylistcover_changes.playCount = /*play*/ ctx[5].playCount;
    			if (dirty & /*playList*/ 1) miniplaylistcover_changes.trackCount = /*play*/ ctx[5].trackCount;
    			miniplaylistcover.$set(miniplaylistcover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(miniplaylistcover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(miniplaylistcover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(miniplaylistcover, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(60:4) <Lazy height={180}>",
    		ctx
    	});

    	return block;
    }

    // (59:2) {#each playList as play}
    function create_each_block$4(ctx) {
    	let lazy;
    	let current;

    	lazy = new Src({
    			props: {
    				height: 180,
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lazy.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lazy, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lazy_changes = {};

    			if (dirty & /*$$scope, playList*/ 257) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lazy, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(59:2) {#each playList as play}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let navbar;
    	let t;
    	let div;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: /*$search*/ ctx[1] === '?create' ? '' : ''
    			},
    			$$inline: true
    		});

    	let each_value = /*playList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "play-list-page svelte-l15zgd");
    			add_location(div, file$d, 57, 0, 1554);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*$search*/ 2) navbar_changes.title = /*$search*/ ctx[1] === '?create' ? '' : '';
    			navbar.$set(navbar_changes);

    			if (dirty & /*playList*/ 1) {
    				each_value = /*playList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let playList;
    	let $search;
    	let $userInfoStore;
    	let $defaultResumableStore;
    	validate_store(search$1, 'search');
    	component_subscribe($$self, search$1, $$value => $$invalidate(1, $search = $$value));
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(2, $userInfoStore = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(3, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MyAllPlayList', slots, []);

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			userPlaylistFun();
    		}
    	});

    	onMount(() => {
    		userPlaylistFun();
    	});

    	//ID
    	async function userPlaylistFun(login) {
    		const res = await userPlaylist({ uid: $userInfoStore.account.id });

    		if (res.code === 200) {
    			let createListL = [];
    			let collectListL = [];

    			//
    			if (res.playlist[0].creator.userId === $userInfoStore.account.id && res.playlist[0].name.substr(-5) === '') {
    				res.playlist.splice(0, 1);
    			}

    			for (let i = 0; i < res.playlist.length; i++) {
    				if (res.playlist[i].creator.userId === $userInfoStore.account.id) {
    					createListL.push(res.playlist[i]);
    				} else {
    					collectListL.push(res.playlist[i]);
    				}
    			}

    			$$invalidate(0, playList = $search === '?create' ? createListL : collectListL);
    		} else {
    			Alert('');
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MyAllPlayList> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Lazy: Src,
    		search: search$1,
    		onResume,
    		NavBar,
    		MiniPlayListCover,
    		userPlaylist,
    		userInfoStore,
    		defaultResumableStore,
    		Alert,
    		userPlaylistFun,
    		playList,
    		$search,
    		$userInfoStore,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('playList' in $$props) $$invalidate(0, playList = $$props.playList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(0, playList = []);
    	return [playList, $search];
    }

    class MyAllPlayList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MyAllPlayList",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src\pages\Setting.svelte generated by Svelte v3.46.4 */
    const file$c = "src\\pages\\Setting.svelte";

    // (95:4) <Button on:BtnClick={logoutFun}>
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(95:4) <Button on:BtnClick={logoutFun}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let navbar;
    	let t0;
    	let div2;
    	let cell0;
    	let t1;
    	let cell1;
    	let t2;
    	let cell2;
    	let t3;
    	let cell3;
    	let t4;
    	let cell4;
    	let t5;
    	let cell5;
    	let t6;
    	let cell6;
    	let t7;
    	let div0;
    	let button;
    	let t8;
    	let div1;
    	let current;
    	navbar = new NavBar({ props: { title: "" }, $$inline: true });

    	cell0 = new Cell({
    			props: {
    				title: "",
    				desc: /*musicQualityArr*/ ctx[5][Number(/*$musicQualityStore*/ ctx[0])],
    				arrow: true
    			},
    			$$inline: true
    		});

    	cell0.$on("cellClick", /*brFun*/ ctx[8]);

    	cell1 = new Cell({
    			props: {
    				title: "",
    				desc: "Switch",
    				cellCheck: /*$isShowCommentStore*/ ctx[1] === '0' ? false : true
    			},
    			$$inline: true
    		});

    	cell1.$on("cellClick", /*switchCommentFun*/ ctx[7]);

    	cell2 = new Cell({
    			props: {
    				title: "",
    				desc: "Switch",
    				cellCheck: /*$isShowTranslateStore*/ ctx[2]
    			},
    			$$inline: true
    		});

    	cell2.$on("cellClick", /*translateFun*/ ctx[9]);

    	cell3 = new Cell({
    			props: {
    				title: "",
    				titleDesc: "",
    				desc: "Switch",
    				cellCheck: /*$restoreScrollStore*/ ctx[3]
    			},
    			$$inline: true
    		});

    	cell3.$on("cellClick", /*switchScrollFun*/ ctx[6]);

    	cell4 = new Cell({
    			props: {
    				title: "",
    				titleDesc: "",
    				desc: "Switch",
    				cellCheck: /*$showVisualizerStore*/ ctx[4] === '1' ? true : false
    			},
    			$$inline: true
    		});

    	cell4.$on("cellClick", /*visualizerFun*/ ctx[13]);

    	cell5 = new Cell({
    			props: { title: "", arrow: true },
    			$$inline: true
    		});

    	cell5.$on("cellClick", /*aboutFun*/ ctx[11]);

    	cell6 = new Cell({
    			props: { title: "", arrow: true },
    			$$inline: true
    		});

    	cell6.$on("cellClick", /*versionFun*/ ctx[12]);

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*logoutFun*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			create_component(cell0.$$.fragment);
    			t1 = space();
    			create_component(cell1.$$.fragment);
    			t2 = space();
    			create_component(cell2.$$.fragment);
    			t3 = space();
    			create_component(cell3.$$.fragment);
    			t4 = space();
    			create_component(cell4.$$.fragment);
    			t5 = space();
    			create_component(cell5.$$.fragment);
    			t6 = space();
    			create_component(cell6.$$.fragment);
    			t7 = space();
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			t8 = space();
    			div1 = element("div");
    			div1.textContent = "V 1.0.2";
    			attr_dev(div0, "class", "bottom svelte-76h2cb");
    			add_location(div0, file$c, 93, 2, 2735);
    			attr_dev(div1, "class", "version svelte-76h2cb");
    			add_location(div1, file$c, 96, 2, 2820);
    			attr_dev(div2, "class", "setting-page svelte-76h2cb");
    			add_location(div2, file$c, 67, 0, 1873);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(cell0, div2, null);
    			append_dev(div2, t1);
    			mount_component(cell1, div2, null);
    			append_dev(div2, t2);
    			mount_component(cell2, div2, null);
    			append_dev(div2, t3);
    			mount_component(cell3, div2, null);
    			append_dev(div2, t4);
    			mount_component(cell4, div2, null);
    			append_dev(div2, t5);
    			mount_component(cell5, div2, null);
    			append_dev(div2, t6);
    			mount_component(cell6, div2, null);
    			append_dev(div2, t7);
    			append_dev(div2, div0);
    			mount_component(button, div0, null);
    			append_dev(div2, t8);
    			append_dev(div2, div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cell0_changes = {};
    			if (dirty & /*$musicQualityStore*/ 1) cell0_changes.desc = /*musicQualityArr*/ ctx[5][Number(/*$musicQualityStore*/ ctx[0])];
    			cell0.$set(cell0_changes);
    			const cell1_changes = {};
    			if (dirty & /*$isShowCommentStore*/ 2) cell1_changes.cellCheck = /*$isShowCommentStore*/ ctx[1] === '0' ? false : true;
    			cell1.$set(cell1_changes);
    			const cell2_changes = {};
    			if (dirty & /*$isShowTranslateStore*/ 4) cell2_changes.cellCheck = /*$isShowTranslateStore*/ ctx[2];
    			cell2.$set(cell2_changes);
    			const cell3_changes = {};
    			if (dirty & /*$restoreScrollStore*/ 8) cell3_changes.cellCheck = /*$restoreScrollStore*/ ctx[3];
    			cell3.$set(cell3_changes);
    			const cell4_changes = {};
    			if (dirty & /*$showVisualizerStore*/ 16) cell4_changes.cellCheck = /*$showVisualizerStore*/ ctx[4] === '1' ? true : false;
    			cell4.$set(cell4_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			transition_in(cell2.$$.fragment, local);
    			transition_in(cell3.$$.fragment, local);
    			transition_in(cell4.$$.fragment, local);
    			transition_in(cell5.$$.fragment, local);
    			transition_in(cell6.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			transition_out(cell2.$$.fragment, local);
    			transition_out(cell3.$$.fragment, local);
    			transition_out(cell4.$$.fragment, local);
    			transition_out(cell5.$$.fragment, local);
    			transition_out(cell6.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(cell0);
    			destroy_component(cell1);
    			destroy_component(cell2);
    			destroy_component(cell3);
    			destroy_component(cell4);
    			destroy_component(cell5);
    			destroy_component(cell6);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function clearAllCookie() {
    	let keys = document.cookie.match(/[^ =;]+(?=\=)/g);

    	if (keys) {
    		for (let i = keys.length; i--; ) document.cookie = keys[i] + '=0;expires=' + new Date(0).toUTCString();
    	}
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $musicQualityStore;
    	let $isShowCommentStore;
    	let $isShowTranslateStore;
    	let $restoreScrollStore;
    	let $showVisualizerStore;
    	validate_store(musicQualityStore, 'musicQualityStore');
    	component_subscribe($$self, musicQualityStore, $$value => $$invalidate(0, $musicQualityStore = $$value));
    	validate_store(isShowCommentStore, 'isShowCommentStore');
    	component_subscribe($$self, isShowCommentStore, $$value => $$invalidate(1, $isShowCommentStore = $$value));
    	validate_store(isShowTranslateStore, 'isShowTranslateStore');
    	component_subscribe($$self, isShowTranslateStore, $$value => $$invalidate(2, $isShowTranslateStore = $$value));
    	validate_store(restoreScrollStore, 'restoreScrollStore');
    	component_subscribe($$self, restoreScrollStore, $$value => $$invalidate(3, $restoreScrollStore = $$value));
    	validate_store(showVisualizerStore, 'showVisualizerStore');
    	component_subscribe($$self, showVisualizerStore, $$value => $$invalidate(4, $showVisualizerStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Setting', slots, []);
    	let musicQualityArr = ['', '', '', ''];

    	function switchScrollFun(e) {
    		restoreScrollStore.set(e.detail.cellCheck);
    		localStorage.setItem('restoreScroll', e.detail.cellCheck ? '1' : '0');
    	}

    	function switchCommentFun(e) {
    		isShowCommentStore.set(e.detail.cellCheck ? '1' : '0');
    		localStorage.setItem('isShowComment', e.detail.cellCheck ? '1' : '0');
    	}

    	function brFun() {
    		push('/brSelect');
    	}

    	function translateFun(e) {
    		isShowTranslateStore.set(e.detail.cellCheck);
    		localStorage.setItem('isShowTranslate', e.detail.cellCheck ? '1' : '0');
    	}

    	function logoutFun() {
    		Confirm('', async () => {
    			const res = await logout();

    			if (res.code === 200) {
    				localStorage.clear();
    				isLoginStore.set(false);
    				clearAllCookie();
    				pop();
    			}
    		});
    	}

    	function aboutFun() {
    		push('/about');
    	}

    	function versionFun() {
    		push('/version');
    	}

    	function visualizerFun(e) {
    		showVisualizerStore.set(e.detail.cellCheck ? '1' : '0');
    		localStorage.setItem('showVisualizer', e.detail.cellCheck ? '1' : '0');
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Setting> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		pop,
    		push,
    		NavBar,
    		Cell,
    		Button,
    		logout,
    		restoreScrollStore,
    		musicQualityStore,
    		isShowTranslateStore,
    		isLoginStore,
    		isShowCommentStore,
    		showVisualizerStore,
    		Confirm,
    		musicQualityArr,
    		switchScrollFun,
    		switchCommentFun,
    		brFun,
    		translateFun,
    		logoutFun,
    		clearAllCookie,
    		aboutFun,
    		versionFun,
    		visualizerFun,
    		$musicQualityStore,
    		$isShowCommentStore,
    		$isShowTranslateStore,
    		$restoreScrollStore,
    		$showVisualizerStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('musicQualityArr' in $$props) $$invalidate(5, musicQualityArr = $$props.musicQualityArr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$musicQualityStore,
    		$isShowCommentStore,
    		$isShowTranslateStore,
    		$restoreScrollStore,
    		$showVisualizerStore,
    		musicQualityArr,
    		switchScrollFun,
    		switchCommentFun,
    		brFun,
    		translateFun,
    		logoutFun,
    		aboutFun,
    		versionFun,
    		visualizerFun
    	];
    }

    class Setting extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Setting",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    // import { mapTrackPlayableStatus } from '@/utils/common';

    /**
     * 
     *  :  ,  /  /  /  /  ,  ,  ,
     *  "   "(  ),  mp3url  ,  /song/url  id 
     * - keywords : 
     * - limit :  ,  30
     * - offset :  ,  :  :(  -1)*30,  30  limit  ,  0
     * - type:  1  ,  : 1: , 10: , 100: , 1000: , 1002: , 1004: MV, 1006: , 1009: , 1014: , 1018:
     * -  : /search?keywords= /cloudsearch?keywords=()
     * @param {Object} params
     * @param {string} params.keywords
     * @param {number=} params.limit
     * @param {number=} params.offset
     * @param {number=} params.type
     */
    function search(params) {
      return service({
        url: "/search",
        method: "get",
        params,
      }).then(data => {
        // if (data.result?.song !== undefined)
        //   data.result.song.songs = mapTrackPlayableStatus(data.result.song.songs);
        return data;
      });
    }

    /* src\pages\Search.svelte generated by Svelte v3.46.4 */

    const { console: console_1 } = globals;
    const file$b = "src\\pages\\Search.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    // (158:4) {#each searchkeywordList10.filter(function (s) {        return s && s.trim();      }) as item}
    function create_each_block_5(ctx) {
    	let span;
    	let t_value = /*item*/ ctx[36] + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[17](/*item*/ ctx[36]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "key-item svelte-1mbdxts");
    			add_location(span, file$b, 160, 6, 4849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*searchkeywordList10*/ 128 && t_value !== (t_value = /*item*/ ctx[36] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(158:4) {#each searchkeywordList10.filter(function (s) {        return s && s.trim();      }) as item}",
    		ctx
    	});

    	return block;
    }

    // (165:4) {#if searchkeywordList10.filter(function (s) {        return s && s.trim();      }).length > 0}
    function create_if_block_1$3(ctx) {
    	let span;
    	let deletebinline;
    	let current;
    	let mounted;
    	let dispose;

    	deletebinline = new DeleteBinLine({
    			props: {
    				size: "12",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(deletebinline.$$.fragment);
    			attr_dev(span, "class", "key-item svelte-1mbdxts");
    			add_location(span, file$b, 167, 6, 5063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(deletebinline, span, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*clearSearchFun*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deletebinline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deletebinline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(deletebinline);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(165:4) {#if searchkeywordList10.filter(function (s) {        return s && s.trim();      }).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (174:4) {#each typeList as t}
    function create_each_block_4(ctx) {
    	let div;
    	let t0_value = /*t*/ ctx[33].text + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[18](/*t*/ ctx[33]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "type-item svelte-1mbdxts");
    			toggle_class(div, "active", /*active*/ ctx[9] === /*t*/ ctx[33].index);
    			add_location(div, file$b, 174, 6, 5294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*active, typeList*/ 1536) {
    				toggle_class(div, "active", /*active*/ ctx[9] === /*t*/ ctx[33].index);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(174:4) {#each typeList as t}",
    		ctx
    	});

    	return block;
    }

    // (189:2) {#if isShowResult}
    function create_if_block$4(ctx) {
    	let div15;
    	let div7;
    	let div0;
    	let t1;
    	let div2;
    	let div1;
    	let songlist0;
    	let t2;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t7;
    	let div6;
    	let t8;
    	let div10;
    	let div9;
    	let div8;
    	let songlist1;
    	let t9;
    	let div12;
    	let div11;
    	let t10;
    	let div14;
    	let div13;
    	let current;

    	songlist0 = new SongList({
    			props: { songList: /*songs*/ ctx[5] },
    			$$inline: true
    		});

    	let each_value_3 = /*songers*/ ctx[2];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks_3[i], 1, 1, () => {
    		each_blocks_3[i] = null;
    	});

    	let each_value_2 = /*playLists*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out_1 = i => transition_out(each_blocks_2[i], 1, 1, () => {
    		each_blocks_2[i] = null;
    	});

    	songlist1 = new SongList({
    			props: { songList: /*songs*/ ctx[5] },
    			$$inline: true
    		});

    	let each_value_1 = /*songers*/ ctx[2];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out_2 = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*playLists*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out_3 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			div0.textContent = "";
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(songlist0.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			div3.textContent = "";
    			t4 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t5 = space();
    			div5 = element("div");
    			div5.textContent = "";
    			t7 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t8 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			create_component(songlist1.$$.fragment);
    			t9 = space();
    			div12 = element("div");
    			div11 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t10 = space();
    			div14 = element("div");
    			div13 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "songer-title svelte-1mbdxts");
    			add_location(div0, file$b, 192, 8, 5830);
    			attr_dev(div1, "class", "song-box");
    			add_location(div1, file$b, 194, 10, 5911);
    			attr_dev(div2, "class", "reault-song");
    			add_location(div2, file$b, 193, 8, 5874);
    			attr_dev(div3, "class", "songer-title svelte-1mbdxts");
    			add_location(div3, file$b, 199, 8, 6050);
    			attr_dev(div4, "class", "reault-songer svelte-1mbdxts");
    			add_location(div4, file$b, 200, 8, 6094);
    			attr_dev(div5, "class", "songer-title svelte-1mbdxts");
    			add_location(div5, file$b, 208, 8, 6342);
    			attr_dev(div6, "class", "reault-play-list svelte-1mbdxts");
    			add_location(div6, file$b, 209, 8, 6386);
    			attr_dev(div7, "class", "result all-box");
    			set_style(div7, "display", /*active*/ ctx[9] === 0 ? 'block' : 'none');
    			add_location(div7, file$b, 191, 6, 5740);
    			attr_dev(div8, "class", "song-box");
    			add_location(div8, file$b, 226, 10, 6967);
    			attr_dev(div9, "class", "reault-song");
    			add_location(div9, file$b, 225, 8, 6930);
    			attr_dev(div10, "class", "result song-box");
    			set_style(div10, "display", /*active*/ ctx[9] === 1 ? 'block' : 'none');
    			add_location(div10, file$b, 224, 6, 6839);
    			attr_dev(div11, "class", "reault-songer svelte-1mbdxts");
    			add_location(div11, file$b, 233, 8, 7206);
    			attr_dev(div12, "class", "result reault-songer-box");
    			set_style(div12, "display", /*active*/ ctx[9] === 2 ? 'block' : 'none');
    			add_location(div12, file$b, 232, 6, 7106);
    			attr_dev(div13, "class", "reault-play-list svelte-1mbdxts");
    			add_location(div13, file$b, 241, 8, 7462);
    			set_style(div14, "display", /*active*/ ctx[9] === 3 ? 'block' : 'none');
    			add_location(div14, file$b, 240, 6, 7395);
    			attr_dev(div15, "class", "result-box");
    			add_location(div15, file$b, 189, 4, 5689);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div7);
    			append_dev(div7, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div2);
    			append_dev(div2, div1);
    			mount_component(songlist0, div1, null);
    			append_dev(div7, t2);
    			append_dev(div7, div3);
    			append_dev(div7, t4);
    			append_dev(div7, div4);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div4, null);
    			}

    			append_dev(div7, t5);
    			append_dev(div7, div5);
    			append_dev(div7, t7);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div6, null);
    			}

    			append_dev(div15, t8);
    			append_dev(div15, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			mount_component(songlist1, div8, null);
    			append_dev(div15, t9);
    			append_dev(div15, div12);
    			append_dev(div12, div11);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div11, null);
    			}

    			append_dev(div15, t10);
    			append_dev(div15, div14);
    			append_dev(div14, div13);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div13, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songlist0_changes = {};
    			if (dirty[0] & /*songs*/ 32) songlist0_changes.songList = /*songs*/ ctx[5];
    			songlist0.$set(songlist0_changes);

    			if (dirty[0] & /*songers*/ 4) {
    				each_value_3 = /*songers*/ ctx[2];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    						transition_in(each_blocks_3[i], 1);
    					} else {
    						each_blocks_3[i] = create_each_block_3(child_ctx);
    						each_blocks_3[i].c();
    						transition_in(each_blocks_3[i], 1);
    						each_blocks_3[i].m(div4, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks_3.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*playLists*/ 8) {
    				each_value_2 = /*playLists*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    						transition_in(each_blocks_2[i], 1);
    					} else {
    						each_blocks_2[i] = create_each_block_2(child_ctx);
    						each_blocks_2[i].c();
    						transition_in(each_blocks_2[i], 1);
    						each_blocks_2[i].m(div6, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks_2.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*active*/ 512) {
    				set_style(div7, "display", /*active*/ ctx[9] === 0 ? 'block' : 'none');
    			}

    			const songlist1_changes = {};
    			if (dirty[0] & /*songs*/ 32) songlist1_changes.songList = /*songs*/ ctx[5];
    			songlist1.$set(songlist1_changes);

    			if (!current || dirty[0] & /*active*/ 512) {
    				set_style(div10, "display", /*active*/ ctx[9] === 1 ? 'block' : 'none');
    			}

    			if (dirty[0] & /*songers*/ 4) {
    				each_value_1 = /*songers*/ ctx[2];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div11, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out_2(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*active*/ 512) {
    				set_style(div12, "display", /*active*/ ctx[9] === 2 ? 'block' : 'none');
    			}

    			if (dirty[0] & /*playLists*/ 8) {
    				each_value = /*playLists*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div13, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_3(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*active*/ 512) {
    				set_style(div14, "display", /*active*/ ctx[9] === 3 ? 'block' : 'none');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlist0.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			transition_in(songlist1.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlist0.$$.fragment, local);
    			each_blocks_3 = each_blocks_3.filter(Boolean);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			each_blocks_2 = each_blocks_2.filter(Boolean);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			transition_out(songlist1.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    			destroy_component(songlist0);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_component(songlist1);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(189:2) {#if isShowResult}",
    		ctx
    	});

    	return block;
    }

    // (202:10) {#each songers as songer}
    function create_each_block_3(ctx) {
    	let div;
    	let songer;
    	let t;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[26],
    				coverSize: 330
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(songer.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "songer-box svelte-1mbdxts");
    			add_location(div, file$b, 202, 12, 6172);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(songer, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty[0] & /*songers*/ 4) songer_changes.songer = /*songer*/ ctx[26];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(songer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(202:10) {#each songers as songer}",
    		ctx
    	});

    	return block;
    }

    // (211:10) {#each playLists as play}
    function create_each_block_2(ctx) {
    	let div;
    	let miniplaylistcover;
    	let t;
    	let current;

    	miniplaylistcover = new MiniPlayListCover({
    			props: {
    				name: /*play*/ ctx[23].name,
    				coverImgUrl: /*play*/ ctx[23].coverImgUrl,
    				id: /*play*/ ctx[23].id,
    				playCount: /*play*/ ctx[23].playCount,
    				trackCount: /*play*/ ctx[23].trackCount
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(miniplaylistcover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "list-box");
    			add_location(div, file$b, 211, 12, 6467);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(miniplaylistcover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const miniplaylistcover_changes = {};
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.name = /*play*/ ctx[23].name;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.coverImgUrl = /*play*/ ctx[23].coverImgUrl;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.id = /*play*/ ctx[23].id;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.playCount = /*play*/ ctx[23].playCount;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.trackCount = /*play*/ ctx[23].trackCount;
    			miniplaylistcover.$set(miniplaylistcover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(miniplaylistcover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(miniplaylistcover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(miniplaylistcover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(211:10) {#each playLists as play}",
    		ctx
    	});

    	return block;
    }

    // (235:10) {#each songers as songer}
    function create_each_block_1(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[26],
    				coverSize: 250
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty[0] & /*songers*/ 4) songer_changes.songer = /*songer*/ ctx[26];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(235:10) {#each songers as songer}",
    		ctx
    	});

    	return block;
    }

    // (243:10) {#each playLists as play}
    function create_each_block$3(ctx) {
    	let miniplaylistcover;
    	let current;

    	miniplaylistcover = new MiniPlayListCover({
    			props: {
    				name: /*play*/ ctx[23].name,
    				coverImgUrl: /*play*/ ctx[23].coverImgUrl,
    				id: /*play*/ ctx[23].id,
    				playCount: /*play*/ ctx[23].playCount,
    				trackCount: /*play*/ ctx[23].trackCount
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(miniplaylistcover.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(miniplaylistcover, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const miniplaylistcover_changes = {};
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.name = /*play*/ ctx[23].name;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.coverImgUrl = /*play*/ ctx[23].coverImgUrl;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.id = /*play*/ ctx[23].id;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.playCount = /*play*/ ctx[23].playCount;
    			if (dirty[0] & /*playLists*/ 8) miniplaylistcover_changes.trackCount = /*play*/ ctx[23].trackCount;
    			miniplaylistcover.$set(miniplaylistcover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(miniplaylistcover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(miniplaylistcover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(miniplaylistcover, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(243:10) {#each playLists as play}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let navbar;
    	let t0;
    	let div4;
    	let div0;
    	let form;
    	let input;
    	let t1;
    	let button;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let show_if = /*searchkeywordList10*/ ctx[7].filter(func).length > 0;
    	let t5;
    	let div2;
    	let t6;
    	let div3;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	navbar = new NavBar({ props: { title: "" }, $$inline: true });
    	let each_value_5 = /*searchkeywordList10*/ ctx[7].filter(func_1);
    	validate_each_argument(each_value_5);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_1[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	let if_block0 = show_if && create_if_block_1$3(ctx);
    	let each_value_4 = /*typeList*/ ctx[10];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	let if_block1 = /*isShowResult*/ ctx[6] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			div0 = element("div");
    			form = element("form");
    			input = element("input");
    			t1 = space();
    			button = element("button");
    			t2 = text("");
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div3 = element("div");
    			t7 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(input, "placeholder", "");
    			attr_dev(input, "type", "search");
    			input.value = /*keywords*/ ctx[1];
    			attr_dev(input, "class", "svelte-1mbdxts");
    			add_location(input, file$b, 146, 6, 4368);
    			attr_dev(form, "action", "JavaScript:void 0");
    			attr_dev(form, "class", "svelte-1mbdxts");
    			add_location(form, file$b, 145, 4, 4327);

    			set_style(button, "background-color", /*keywords*/ ctx[1] === ''
    			? 'rgb(224, 224, 224)'
    			: 'var(--primary-text-color)');

    			set_style(button, "color", /*keywords*/ ctx[1] === '' ? '#666' : '#fff');
    			attr_dev(button, "class", "svelte-1mbdxts");
    			add_location(button, file$b, 148, 4, 4469);
    			attr_dev(div0, "class", "input-box svelte-1mbdxts");
    			add_location(div0, file$b, 144, 2, 4298);
    			attr_dev(div1, "class", "searchkeyword svelte-1mbdxts");
    			add_location(div1, file$b, 156, 2, 4714);
    			attr_dev(div2, "class", "type svelte-1mbdxts");
    			add_location(div2, file$b, 172, 2, 5220);
    			attr_dev(div3, "class", "active-line svelte-1mbdxts");
    			set_style(div3, "left", 20 + (localStorage.getItem('fullWidth') - 40) / 4 * /*active*/ ctx[9] + "px");
    			add_location(div3, file$b, 187, 2, 5554);
    			attr_dev(div4, "class", "search-page svelte-1mbdxts");
    			add_location(div4, file$b, 143, 0, 4269);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, form);
    			append_dev(form, input);
    			/*input_binding*/ ctx[15](input);
    			append_dev(div0, t1);
    			append_dev(div0, button);
    			append_dev(button, t2);
    			append_dev(div4, t3);
    			append_dev(div4, div1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div1, null);
    			}

    			append_dev(div1, t4);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div4, t5);
    			append_dev(div4, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			/*div2_binding*/ ctx[19](div2);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			append_dev(div4, t7);
    			if (if_block1) if_block1.m(div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*keywords*/ 2 && input.value !== /*keywords*/ ctx[1]) {
    				prop_dev(input, "value", /*keywords*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*keywords*/ 2) {
    				set_style(button, "background-color", /*keywords*/ ctx[1] === ''
    				? 'rgb(224, 224, 224)'
    				: 'var(--primary-text-color)');
    			}

    			if (!current || dirty[0] & /*keywords*/ 2) {
    				set_style(button, "color", /*keywords*/ ctx[1] === '' ? '#666' : '#fff');
    			}

    			if (dirty[0] & /*quickSearchFun, searchkeywordList10*/ 4224) {
    				each_value_5 = /*searchkeywordList10*/ ctx[7].filter(func_1);
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_5(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div1, t4);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_5.length;
    			}

    			if (dirty[0] & /*searchkeywordList10*/ 128) show_if = /*searchkeywordList10*/ ctx[7].filter(func).length > 0;

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*searchkeywordList10*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*active, typeList, type, searchFun*/ 3840) {
    				each_value_4 = /*typeList*/ ctx[10];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}

    			if (!current || dirty[0] & /*active*/ 512) {
    				set_style(div3, "left", 20 + (localStorage.getItem('fullWidth') - 40) / 4 * /*active*/ ctx[9] + "px");
    			}

    			if (/*isShowResult*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isShowResult*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div4, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div4);
    			/*input_binding*/ ctx[15](null);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			/*div2_binding*/ ctx[19](null);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function uniqe(arr) {
    	for (var i = 0; i < arr.length; i++) {
    		if (arr.indexOf(arr[i]) == i) {
    			temp.push(arr[i]);
    		}
    	}

    	return temp;
    }

    const func = function (s) {
    	return s && s.trim();
    };

    const func_1 = function (s) {
    	return s && s.trim();
    };

    function instance$b($$self, $$props, $$invalidate) {
    	let songs;
    	let active;
    	let type;
    	let searchkeywordList;
    	let searchkeywordList10;
    	let isShowResult;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Search', slots, []);
    	let inputDom;
    	let keywords = '';
    	let songers = [];
    	let playLists = [];

    	let typeList = [
    		{ index: 0, type: 0, text: '' },
    		{ index: 1, type: 1, text: '' },
    		{ index: 2, type: 100, text: '' },
    		{ index: 3, type: 1000, text: '' }
    	];

    	let typeDoms;

    	onMount(() => {
    		if (typeDoms) ripple(typeDoms, true);

    		inputDom.addEventListener('compositionstart', function (e) {
    			//
    			e.target.isNeedPrevent = true;
    		});

    		inputDom.addEventListener('compositionend', function (e) {
    			//
    			e.target.isNeedPrevent = false;
    		});

    		inputDom.addEventListener('input', inputchange);

    		inputDom.addEventListener('keydown', function (e) {
    			if (e.key === 'Enter') searchFun();
    		});
    	});

    	function inputchange(e) {
    		setTimeout(
    			() => {
    				//
    				if (!e.target.isNeedPrevent && e.target.oldValue !== e.target.value) {
    					//
    					e.target.oldValue = e.target.value;

    					$$invalidate(1, keywords = e.target.value);
    				}
    			},
    			10
    		);
    	}

    	//
    	function searchFun() {
    		if (keywords.trim() != '') {
    			inputDom.blur();

    			let searchkeywords = localStorage.getItem('searchkeywords')
    			? localStorage.getItem('searchkeywords')
    			: '';

    			if (searchkeywords.indexOf(keywords) != -1) {
    				//
    				searchkeywords = `${keywords}|&&|` + searchkeywords.replace(`${keywords}|&&|`, '');
    			} else {
    				searchkeywords = `${keywords}|&&|` + searchkeywords;
    			}

    			$$invalidate(14, searchkeywordList = searchkeywords.split('|&&|'));
    			localStorage.setItem('searchkeywords', searchkeywords);

    			if (type === 0) {
    				//
    				searchApiFun(typeList[1].type, false);

    				searchApiFun(typeList[2].type, false);
    				searchApiFun(typeList[3].type, false);
    			} else {
    				searchApiFun(type, true);
    			}
    		}
    	}

    	function quickSearchFun(key) {
    		$$invalidate(1, keywords = key);
    		searchFun();
    	}

    	function clearSearchFun() {
    		$$invalidate(7, searchkeywordList10 = []);
    		localStorage.removeItem('searchkeywords');
    	}

    	//
    	async function searchApiFun(type, isMore) {
    		const res = await search({ keywords, type, limit: isMore ? 30 : 6 });

    		if (res.code === 200) {
    			$$invalidate(6, isShowResult = true);

    			switch (type) {
    				case 1:
    					let songIdList = [];
    					for (let i = 0; i < res.result.songs.length; i++) {
    						songIdList.push(res.result.songs[i].id);
    					}
    					getSongDetailFun(songIdList.join(','));
    					break;
    				case 100:
    					$$invalidate(2, songers = res.result.artists);
    					break;
    				case 1000:
    					$$invalidate(3, playLists = res.result.playlists);
    					break;
    				default:
    					console.log('');
    					break;
    			}
    		}
    	}

    	//
    	async function getSongDetailFun(songIds) {
    		const res = await getSongDetail(songIds);

    		if (res.code === 200) {
    			$$invalidate(5, songs = res.songs);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputDom = $$value;
    			$$invalidate(0, inputDom);
    		});
    	}

    	const click_handler = () => searchFun();
    	const click_handler_1 = item => quickSearchFun(item);

    	const click_handler_2 = t => {
    		$$invalidate(9, active = t.index);
    		$$invalidate(8, type = t.type);
    		searchFun();
    	};

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			typeDoms = $$value;
    			$$invalidate(4, typeDoms);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		DeleteBinLine,
    		NavBar,
    		Songer: Singer,
    		MiniPlayListCover,
    		SongList,
    		search,
    		getSongDetail,
    		ripple,
    		inputDom,
    		keywords,
    		songers,
    		playLists,
    		typeList,
    		typeDoms,
    		inputchange,
    		searchFun,
    		quickSearchFun,
    		clearSearchFun,
    		searchApiFun,
    		getSongDetailFun,
    		uniqe,
    		songs,
    		isShowResult,
    		searchkeywordList10,
    		type,
    		searchkeywordList,
    		active
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputDom' in $$props) $$invalidate(0, inputDom = $$props.inputDom);
    		if ('keywords' in $$props) $$invalidate(1, keywords = $$props.keywords);
    		if ('songers' in $$props) $$invalidate(2, songers = $$props.songers);
    		if ('playLists' in $$props) $$invalidate(3, playLists = $$props.playLists);
    		if ('typeList' in $$props) $$invalidate(10, typeList = $$props.typeList);
    		if ('typeDoms' in $$props) $$invalidate(4, typeDoms = $$props.typeDoms);
    		if ('songs' in $$props) $$invalidate(5, songs = $$props.songs);
    		if ('isShowResult' in $$props) $$invalidate(6, isShowResult = $$props.isShowResult);
    		if ('searchkeywordList10' in $$props) $$invalidate(7, searchkeywordList10 = $$props.searchkeywordList10);
    		if ('type' in $$props) $$invalidate(8, type = $$props.type);
    		if ('searchkeywordList' in $$props) $$invalidate(14, searchkeywordList = $$props.searchkeywordList);
    		if ('active' in $$props) $$invalidate(9, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*searchkeywordList*/ 16384) {
    			$$invalidate(7, searchkeywordList10 = searchkeywordList.length > 10
    			? searchkeywordList.slice(0, 10).filter(function (s) {
    					return s && s.trim();
    				})
    			: searchkeywordList.filter(function (s) {
    					return s && s.trim();
    				}));
    		}
    	};

    	$$invalidate(5, songs = []);
    	$$invalidate(9, active = 0);
    	$$invalidate(8, type = typeList[0].type);

    	$$invalidate(14, searchkeywordList = localStorage.getItem('searchkeywords')
    	? [...new Set(localStorage.getItem('searchkeywords').split('|&&|'))].filter(function (s) {
    			return s && s.trim();
    		})
    	: []);

    	$$invalidate(6, isShowResult = false);

    	return [
    		inputDom,
    		keywords,
    		songers,
    		playLists,
    		typeDoms,
    		songs,
    		isShowResult,
    		searchkeywordList10,
    		type,
    		active,
    		typeList,
    		searchFun,
    		quickSearchFun,
    		clearSearchFun,
    		searchkeywordList,
    		input_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		div2_binding
    	];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\pages\SongerDetail.svelte generated by Svelte v3.46.4 */
    const file$a = "src\\pages\\SongerDetail.svelte";

    // (140:8) <Lazy height={140}>
    function create_default_slot_2(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "img-cover svelte-dyfxu7");
    			if (!src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[6].replace(/^http:/, 'https:') + '?param=400y400')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$a, 140, 10, 4750);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coverImgUrl*/ 64 && !src_url_equal(img.src, img_src_value = /*coverImgUrl*/ ctx[6].replace(/^http:/, 'https:') + '?param=400y400')) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(140:8) <Lazy height={140}>",
    		ctx
    	});

    	return block;
    }

    // (153:6) <Button type="primary" on:BtnClick={() => playListFun(0)}>
    function create_default_slot_1(ctx) {
    	let span;
    	let playcircleline;
    	let t;
    	let current;

    	playcircleline = new PlayCircleLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(playcircleline.$$.fragment);
    			t = text("\r\n        ");
    			attr_dev(span, "class", "icon svelte-dyfxu7");
    			add_location(span, file$a, 153, 8, 5257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(playcircleline, span, null);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playcircleline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playcircleline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(playcircleline);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(153:6) <Button type=\\\"primary\\\" on:BtnClick={() => playListFun(0)}>",
    		ctx
    	});

    	return block;
    }

    // (160:4) {#if $isLoginStore}
    function create_if_block$3(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				type: /*collect*/ ctx[0] ? 'default' : 'primary',
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*loveSongerFun*/ ctx[12]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "random svelte-dyfxu7");
    			add_location(div, file$a, 160, 6, 5440);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*collect*/ 1) button_changes.type = /*collect*/ ctx[0] ? 'default' : 'primary';

    			if (dirty & /*$$scope, collect*/ 8388609) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(160:4) {#if $isLoginStore}",
    		ctx
    	});

    	return block;
    }

    // (166:12) {:else}
    function create_else_block$1(ctx) {
    	let chatheartfill;
    	let current;

    	chatheartfill = new ChatHeartFill({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatheartfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatheartfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatheartfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatheartfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatheartfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(166:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:12) {#if collect}
    function create_if_block_1$2(ctx) {
    	let chatheartline;
    	let current;

    	chatheartline = new ChatHeartLine({
    			props: {
    				size: "20",
    				style: "vertical-align: middle"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatheartline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatheartline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatheartline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatheartline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatheartline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(164:12) {#if collect}",
    		ctx
    	});

    	return block;
    }

    // (162:8) <Button type={collect ? 'default' : 'primary'} on:BtnClick={loveSongerFun}>
    function create_default_slot$4(ctx) {
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let t1_value = (/*collect*/ ctx[0] ? '' : '') + "";
    	let t1;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*collect*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			attr_dev(span, "class", "icon svelte-dyfxu7");
    			add_location(span, file$a, 162, 10, 5557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_blocks[current_block_type_index].m(span, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}

    			if ((!current || dirty & /*collect*/ 1) && t1_value !== (t1_value = (/*collect*/ ctx[0] ? '' : '') + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(162:8) <Button type={collect ? 'default' : 'primary'} on:BtnClick={loveSongerFun}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let navbar;
    	let t0;
    	let div10;
    	let div6;
    	let div5;
    	let div0;
    	let lazy;
    	let t1;
    	let div4;
    	let div1;
    	let t2;
    	let t3;
    	let div2;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let div3;
    	let t11;
    	let t12;
    	let div8;
    	let div7;
    	let button;
    	let t13;
    	let t14;
    	let div9;
    	let title;
    	let t15;
    	let songlist;
    	let current;
    	let mounted;
    	let dispose;

    	navbar = new NavBar({
    			props: { title: /*name*/ ctx[7], dark: true },
    			$$inline: true
    		});

    	lazy = new Src({
    			props: {
    				height: 140,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				type: "primary",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("BtnClick", /*BtnClick_handler*/ ctx[13]);
    	let if_block = /*$isLoginStore*/ ctx[9] && create_if_block$3(ctx);

    	title = new Title({
    			props: {
    				title: ` ${/*hotSongs*/ ctx[1].length} `,
    				isShowRight: /*hotSongs*/ ctx[1].length === 50
    			},
    			$$inline: true
    		});

    	title.$on("TitleClick", /*TitleClick_handler*/ ctx[14]);

    	songlist = new SongList({
    			props: { songList: /*hotSongs*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div10 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			create_component(lazy.$$.fragment);
    			t1 = space();
    			div4 = element("div");
    			div1 = element("div");
    			t2 = text(/*name*/ ctx[7]);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(/*musicSize*/ ctx[4]);
    			t5 = text("   ");
    			t6 = text(/*albumSize*/ ctx[3]);
    			t7 = text("   ");
    			t8 = text(/*mvSize*/ ctx[5]);
    			t9 = text("  MV");
    			t10 = space();
    			div3 = element("div");
    			t11 = text(/*description*/ ctx[2]);
    			t12 = space();
    			div8 = element("div");
    			div7 = element("div");
    			create_component(button.$$.fragment);
    			t13 = space();
    			if (if_block) if_block.c();
    			t14 = space();
    			div9 = element("div");
    			create_component(title.$$.fragment);
    			t15 = space();
    			create_component(songlist.$$.fragment);
    			attr_dev(div0, "class", "cover svelte-dyfxu7");
    			add_location(div0, file$a, 138, 6, 4690);
    			attr_dev(div1, "class", "name svelte-dyfxu7");
    			add_location(div1, file$a, 144, 8, 4914);
    			attr_dev(div2, "class", "song-count svelte-dyfxu7");
    			add_location(div2, file$a, 145, 8, 4954);
    			attr_dev(div3, "class", "desc svelte-dyfxu7");
    			add_location(div3, file$a, 146, 8, 5042);
    			attr_dev(div4, "class", "info svelte-dyfxu7");
    			add_location(div4, file$a, 143, 6, 4886);
    			attr_dev(div5, "class", "cover-bg svelte-dyfxu7");
    			add_location(div5, file$a, 137, 4, 4660);
    			attr_dev(div6, "class", "cover-box svelte-dyfxu7");
    			add_location(div6, file$a, 136, 2, 4631);
    			attr_dev(div7, "class", "play svelte-dyfxu7");
    			add_location(div7, file$a, 151, 4, 5163);
    			attr_dev(div8, "class", "btn svelte-dyfxu7");
    			add_location(div8, file$a, 150, 2, 5140);
    			add_location(div9, file$a, 174, 2, 5907);
    			attr_dev(div10, "class", "page svelte-dyfxu7");
    			add_location(div10, file$a, 135, 0, 4609);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			mount_component(lazy, div0, null);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, t2);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div2, t4);
    			append_dev(div2, t5);
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div2, t8);
    			append_dev(div2, t9);
    			append_dev(div4, t10);
    			append_dev(div4, div3);
    			append_dev(div3, t11);
    			append_dev(div10, t12);
    			append_dev(div10, div8);
    			append_dev(div8, div7);
    			mount_component(button, div7, null);
    			append_dev(div8, t13);
    			if (if_block) if_block.m(div8, null);
    			append_dev(div10, t14);
    			append_dev(div10, div9);
    			mount_component(title, div9, null);
    			append_dev(div9, t15);
    			mount_component(songlist, div9, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div3, "click", /*toDescFun*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*name*/ 128) navbar_changes.title = /*name*/ ctx[7];
    			navbar.$set(navbar_changes);
    			const lazy_changes = {};

    			if (dirty & /*$$scope, coverImgUrl*/ 8388672) {
    				lazy_changes.$$scope = { dirty, ctx };
    			}

    			lazy.$set(lazy_changes);
    			if (!current || dirty & /*name*/ 128) set_data_dev(t2, /*name*/ ctx[7]);
    			if (!current || dirty & /*musicSize*/ 16) set_data_dev(t4, /*musicSize*/ ctx[4]);
    			if (!current || dirty & /*albumSize*/ 8) set_data_dev(t6, /*albumSize*/ ctx[3]);
    			if (!current || dirty & /*mvSize*/ 32) set_data_dev(t8, /*mvSize*/ ctx[5]);
    			if (!current || dirty & /*description*/ 4) set_data_dev(t11, /*description*/ ctx[2]);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8388608) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*$isLoginStore*/ ctx[9]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isLoginStore*/ 512) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div8, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const title_changes = {};
    			if (dirty & /*hotSongs*/ 2) title_changes.title = ` ${/*hotSongs*/ ctx[1].length} `;
    			if (dirty & /*hotSongs*/ 2) title_changes.isShowRight = /*hotSongs*/ ctx[1].length === 50;
    			title.$set(title_changes);
    			const songlist_changes = {};
    			if (dirty & /*hotSongs*/ 2) songlist_changes.songList = /*hotSongs*/ ctx[1];
    			songlist.$set(songlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(lazy.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(title.$$.fragment, local);
    			transition_in(songlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(lazy.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(title.$$.fragment, local);
    			transition_out(songlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div10);
    			destroy_component(lazy);
    			destroy_component(button);
    			if (if_block) if_block.d();
    			destroy_component(title);
    			destroy_component(songlist);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let coverImgUrl;
    	let name;
    	let description;
    	let mvSize;
    	let musicSize;
    	let albumSize;
    	let hotSongs;
    	let collect;
    	let currentSongerId;
    	let $currentDetailSongerIdStore;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $isLoginStore;
    	let $defaultResumableStore;
    	validate_store(currentDetailSongerIdStore, 'currentDetailSongerIdStore');
    	component_subscribe($$self, currentDetailSongerIdStore, $$value => $$invalidate(15, $currentDetailSongerIdStore = $$value));
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(16, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(17, $currentPlayListStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(9, $isLoginStore = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(18, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongerDetail', slots, []);

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			allMount();
    		}
    	});

    	onMount(() => {
    		allMount();
    	});

    	afterUpdate(() => {
    		if (currentSongerId !== $currentDetailSongerIdStore) {
    			allMount();
    		}
    	});

    	function allMount() {
    		getSongerDetailFun();
    		getSongerTopFun();

    		if ($isLoginStore) {
    			const ids = JSON.parse(localStorage.getItem('useLoveSongerIds'));
    			$$invalidate(0, collect = ids.includes($currentDetailSongerIdStore));
    		} else {
    			$$invalidate(0, collect = false);
    		}
    	}

    	async function getSongerDetailFun() {
    		$$invalidate(8, currentSongerId = $currentDetailSongerIdStore);
    		const res = await getSongerDetail($currentDetailSongerIdStore);

    		if (res.code === 200) {
    			$$invalidate(7, name = res.data.artist.name);

    			$$invalidate(6, coverImgUrl = res.data.user
    			? res.data.user.avatarUrl
    			: res.data.artist.cover);

    			$$invalidate(2, description = res.data.artist.briefDesc);
    			$$invalidate(5, mvSize = res.data.artist.mvSize);
    			$$invalidate(4, musicSize = res.data.artist.musicSize);
    			$$invalidate(3, albumSize = res.data.artist.albumSize);
    		}
    	}

    	async function getSongerTopFun() {
    		const res = await getSongerTop($currentDetailSongerIdStore);

    		if (res.code === 200) {
    			$$invalidate(1, hotSongs = res.songs);
    		}
    	}

    	function toDescFun() {
    		if (description != '') {
    			push('/songerDesc?' + $currentDetailSongerIdStore);
    		}
    	}

    	function playListFun(index) {
    		playRepeatModelStore.set('repeat');
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		currentPlayListStore.set(hotSongs);
    		let ids = [];

    		for (let r = 0; r < hotSongs.length; r++) {
    			ids.push(hotSongs[r].id);
    		}

    		localStorage.setItem('localPlayList', JSON.stringify(ids));
    		currentSongIndexStore.set(index);
    		getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	async function loveSongerFun() {
    		const res = await followAArtist({
    			id: $currentDetailSongerIdStore,
    			t: collect ? 0 : 1
    		});

    		if (res.code === 200) {
    			const ids = JSON.parse(localStorage.getItem('useLoveSongerIds'));

    			if (collect) {
    				let i = ids.indexOf(Number($currentDetailSongerIdStore));
    				ids.splice(i, 1);
    			} else {
    				ids.unshift(Number($currentDetailSongerIdStore));
    			}

    			localStorage.setItem('useLoveSongerIds', JSON.stringify(ids));
    			$$invalidate(0, collect = !collect);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongerDetail> was created with unknown prop '${key}'`);
    	});

    	const BtnClick_handler = () => playListFun(0);

    	const TitleClick_handler = () => {
    		coverImgUrlStore.set(coverImgUrl.replace(/^http:/, 'https:'));
    		push('/moreSong?name=' + name + '&id=' + currentSongerId);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		Lazy: Src,
    		push,
    		onResume,
    		PlayCircleLine,
    		ChatHeartFill,
    		ChatHeartLine,
    		NavBar,
    		Title,
    		Button,
    		SongList,
    		defaultResumableStore,
    		isLoginStore,
    		currentDetailSongerIdStore,
    		coverImgUrlStore,
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		getSongerDetail,
    		getSongerTop,
    		followAArtist,
    		getSongUrl,
    		allMount,
    		getSongerDetailFun,
    		getSongerTopFun,
    		toDescFun,
    		playListFun,
    		getSongUrlFun,
    		loveSongerFun,
    		collect,
    		hotSongs,
    		description,
    		albumSize,
    		musicSize,
    		mvSize,
    		coverImgUrl,
    		name,
    		currentSongerId,
    		$currentDetailSongerIdStore,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$isLoginStore,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collect' in $$props) $$invalidate(0, collect = $$props.collect);
    		if ('hotSongs' in $$props) $$invalidate(1, hotSongs = $$props.hotSongs);
    		if ('description' in $$props) $$invalidate(2, description = $$props.description);
    		if ('albumSize' in $$props) $$invalidate(3, albumSize = $$props.albumSize);
    		if ('musicSize' in $$props) $$invalidate(4, musicSize = $$props.musicSize);
    		if ('mvSize' in $$props) $$invalidate(5, mvSize = $$props.mvSize);
    		if ('coverImgUrl' in $$props) $$invalidate(6, coverImgUrl = $$props.coverImgUrl);
    		if ('name' in $$props) $$invalidate(7, name = $$props.name);
    		if ('currentSongerId' in $$props) $$invalidate(8, currentSongerId = $$props.currentSongerId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(6, coverImgUrl = '/images/defaultCover.png');
    	$$invalidate(7, name = '--');
    	$$invalidate(2, description = '');
    	$$invalidate(5, mvSize = 0);
    	$$invalidate(4, musicSize = 0);
    	$$invalidate(3, albumSize = 0);
    	$$invalidate(1, hotSongs = []);
    	$$invalidate(0, collect = false);
    	$$invalidate(8, currentSongerId = 0); // ID

    	return [
    		collect,
    		hotSongs,
    		description,
    		albumSize,
    		musicSize,
    		mvSize,
    		coverImgUrl,
    		name,
    		currentSongerId,
    		$isLoginStore,
    		toDescFun,
    		playListFun,
    		loveSongerFun,
    		BtnClick_handler,
    		TitleClick_handler
    	];
    }

    class SongerDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongerDetail",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src\pages\BrSelect.svelte generated by Svelte v3.46.4 */
    const file$9 = "src\\pages\\BrSelect.svelte";

    function create_fragment$9(ctx) {
    	let navbar;
    	let t0;
    	let div;
    	let radio;
    	let t1;
    	let tip;
    	let current;
    	navbar = new NavBar({ props: { title: "" }, $$inline: true });

    	radio = new Radio({
    			props: {
    				radioData: /*radioData*/ ctx[0],
    				active: /*active*/ ctx[2]
    			},
    			$$inline: true
    		});

    	radio.$on("RadioClick", /*getActiveFun*/ ctx[3]);

    	tip = new Tip({
    			props: { tipTextList: /*tipTextList*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(radio.$$.fragment);
    			t1 = space();
    			create_component(tip.$$.fragment);
    			attr_dev(div, "class", "br-page svelte-uc65sw");
    			add_location(div, file$9, 27, 0, 788);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(radio, div, null);
    			append_dev(div, t1);
    			mount_component(tip, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(radio.$$.fragment, local);
    			transition_in(tip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(radio.$$.fragment, local);
    			transition_out(tip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(radio);
    			destroy_component(tip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $musicQualityStore;
    	validate_store(musicQualityStore, 'musicQualityStore');
    	component_subscribe($$self, musicQualityStore, $$value => $$invalidate(4, $musicQualityStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BrSelect', slots, []);

    	let radioData = [
    		{ text: "", desc: "128K" },
    		{ text: "", desc: "192K" },
    		{ text: "", desc: "320K" },
    		{ text: "", desc: "FLAC" }
    	];

    	let tipTextList = [
    		"",
    		"1FLAC  M  100M",
    		"2192K",
    		"3",
    		"4"
    	];

    	let active = Number($musicQualityStore);

    	function getActiveFun(e) {
    		musicQualityStore.set(e.detail.active.toString());
    		localStorage.setItem("musicQuality", e.detail.active.toString());
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrSelect> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		NavBar,
    		Radio,
    		Tip,
    		musicQualityStore,
    		radioData,
    		tipTextList,
    		active,
    		getActiveFun,
    		$musicQualityStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('radioData' in $$props) $$invalidate(0, radioData = $$props.radioData);
    		if ('tipTextList' in $$props) $$invalidate(1, tipTextList = $$props.tipTextList);
    		if ('active' in $$props) $$invalidate(2, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [radioData, tipTextList, active, getActiveFun];
    }

    class BrSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BrSelect",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\pages\MusicComment.svelte generated by Svelte v3.46.4 */
    const file$8 = "src\\pages\\MusicComment.svelte";

    // (91:16) {#if item.user.authStatus === 1}
    function create_if_block_3(ctx) {
    	let span;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			img = element("img");
    			attr_dev(img, "class", "authStatus svelte-hhobj8");
    			if (!src_url_equal(img.src, img_src_value = "/images/auth.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$8, 92, 20, 2841);
    			attr_dev(span, "class", "vip");
    			add_location(span, file$8, 91, 18, 2801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(91:16) {#if item.user.authStatus === 1}",
    		ctx
    	});

    	return block;
    }

    // (96:16) {#if item.user.vipType !== 0}
    function create_if_block_2(ctx) {
    	let span;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			img = element("img");
    			attr_dev(img, "class", "cvip svelte-hhobj8");
    			if (!src_url_equal(img.src, img_src_value = `/images/vip/${/*item*/ ctx[12].user.vipRights.redVipLevel}.png`)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$8, 97, 20, 3054);
    			attr_dev(span, "class", "vip");
    			add_location(span, file$8, 96, 18, 3014);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 4096 && !src_url_equal(img.src, img_src_value = `/images/vip/${/*item*/ ctx[12].user.vipRights.redVipLevel}.png`)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(96:16) {#if item.user.vipType !== 0}",
    		ctx
    	});

    	return block;
    }

    // (115:14) {:else}
    function create_else_block(ctx) {
    	let thumbupline;
    	let current;

    	thumbupline = new ThumbUpLine({
    			props: {
    				size: "12",
    				style: "vertical-align: middle;margin-left:4px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(thumbupline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(thumbupline, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(thumbupline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(thumbupline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(thumbupline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(115:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (113:14) {#if item.liked}
    function create_if_block_1$1(ctx) {
    	let thumbupfill;
    	let current;

    	thumbupfill = new ThumbUpFill({
    			props: {
    				size: "12",
    				style: "vertical-align: middle;margin-left:4px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(thumbupfill.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(thumbupfill, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(thumbupfill.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(thumbupfill.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(thumbupfill, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(113:14) {#if item.liked}",
    		ctx
    	});

    	return block;
    }

    // (123:10) {#if item.beReplied && item.beReplied.length > 0}
    function create_if_block$2(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*item*/ ctx[12].beReplied[0].user.nickname + "";
    	let t1;
    	let t2;
    	let t3_value = /*item*/ ctx[12].beReplied[0].content + "";
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("@ ");
    			t1 = text(t1_value);
    			t2 = text("");
    			t3 = text(t3_value);
    			attr_dev(div, "class", "beReplied svelte-hhobj8");
    			add_location(div, file$8, 123, 12, 4096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 4096 && t1_value !== (t1_value = /*item*/ ctx[12].beReplied[0].user.nickname + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*item*/ 4096 && t3_value !== (t3_value = /*item*/ ctx[12].beReplied[0].content + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(123:10) {#if item.beReplied && item.beReplied.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={hotComments}      let:item      let:index      {hasMore}      on:load={() => {        if (hasMore) {          offset = hotComments.length;          getHotCommentFun(offset);        }      }}    >
    function create_default_slot$3(ctx) {
    	let div9;
    	let div8;
    	let div6;
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div3;
    	let div1;
    	let t1_value = /*item*/ ctx[12].user.nickname + "";
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let div2;
    	let t5_value = formatTime(/*item*/ ctx[12].time, 'yyyy-MM-dd hh:mm:ss') + "";
    	let t5;
    	let t6;
    	let div5;
    	let span;
    	let current_block_type_index;
    	let if_block2;
    	let t7;
    	let t8_value = tranNumber(/*item*/ ctx[12].likedCount) + "";
    	let t8;
    	let t9;
    	let div7;
    	let html_tag;
    	let raw_value = /*item*/ ctx[12].content + "";
    	let t10;
    	let t11;
    	let divider;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*item*/ ctx[12].user.authStatus === 1 && create_if_block_3(ctx);
    	let if_block1 = /*item*/ ctx[12].user.vipType !== 0 && create_if_block_2(ctx);
    	const if_block_creators = [create_if_block_1$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[12].liked) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*item*/ ctx[12]);
    	}

    	let if_block3 = /*item*/ ctx[12].beReplied && /*item*/ ctx[12].beReplied.length > 0 && create_if_block$2(ctx);
    	divider = new Divider({ $$inline: true });

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div2 = element("div");
    			t5 = text(t5_value);
    			t6 = space();
    			div5 = element("div");
    			span = element("span");
    			if_block2.c();
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			div7 = element("div");
    			html_tag = new HtmlTag();
    			t10 = space();
    			if (if_block3) if_block3.c();
    			t11 = space();
    			create_component(divider.$$.fragment);
    			if (!src_url_equal(img.src, img_src_value = /*item*/ ctx[12].user.avatarUrl.replace(/^http:/, 'https:') + '?param=50y50')) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-hhobj8");
    			add_location(img, file$8, 85, 14, 2522);
    			attr_dev(div0, "class", "cover svelte-hhobj8");
    			add_location(div0, file$8, 84, 12, 2487);
    			attr_dev(div1, "class", "name");
    			add_location(div1, file$8, 88, 14, 2675);
    			attr_dev(div2, "class", "time svelte-hhobj8");
    			add_location(div2, file$8, 101, 14, 3228);
    			attr_dev(div3, "class", "info svelte-hhobj8");
    			add_location(div3, file$8, 87, 12, 2641);
    			attr_dev(div4, "class", "user svelte-hhobj8");
    			add_location(div4, file$8, 83, 10, 2455);
    			attr_dev(span, "class", "liked-span svelte-hhobj8");
    			add_location(span, file$8, 111, 12, 3592);
    			attr_dev(div5, "class", "like svelte-hhobj8");

    			set_style(div5, "color", /*item*/ ctx[12].liked
    			? 'var(--primary-text-color)'
    			: '#666');

    			add_location(div5, file$8, 106, 10, 3382);
    			attr_dev(div6, "class", "top svelte-hhobj8");
    			add_location(div6, file$8, 82, 8, 2426);
    			html_tag.a = t10;
    			attr_dev(div7, "class", "content svelte-hhobj8");
    			add_location(div7, file$8, 120, 8, 3968);
    			attr_dev(div8, "class", "comment svelte-hhobj8");
    			add_location(div8, file$8, 80, 6, 2339);
    			add_location(div9, file$8, 79, 4, 2326);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			append_dev(div6, div4);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, t1);
    			append_dev(div1, t2);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, t5);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			append_dev(div5, span);
    			if_blocks[current_block_type_index].m(span, null);
    			append_dev(span, t7);
    			append_dev(div5, t8);
    			append_dev(div8, t9);
    			append_dev(div8, div7);
    			html_tag.m(raw_value, div7);
    			append_dev(div7, t10);
    			if (if_block3) if_block3.m(div7, null);
    			append_dev(div9, t11);
    			mount_component(divider, div9, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div5, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*item*/ 4096 && !src_url_equal(img.src, img_src_value = /*item*/ ctx[12].user.avatarUrl.replace(/^http:/, 'https:') + '?param=50y50')) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*item*/ 4096) && t1_value !== (t1_value = /*item*/ ctx[12].user.nickname + "")) set_data_dev(t1, t1_value);

    			if (/*item*/ ctx[12].user.authStatus === 1) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(div1, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*item*/ ctx[12].user.vipType !== 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*item*/ 4096) && t5_value !== (t5_value = formatTime(/*item*/ ctx[12].time, 'yyyy-MM-dd hh:mm:ss') + "")) set_data_dev(t5, t5_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(span, t7);
    			}

    			if ((!current || dirty & /*item*/ 4096) && t8_value !== (t8_value = tranNumber(/*item*/ ctx[12].likedCount) + "")) set_data_dev(t8, t8_value);

    			if (!current || dirty & /*item*/ 4096) {
    				set_style(div5, "color", /*item*/ ctx[12].liked
    				? 'var(--primary-text-color)'
    				: '#666');
    			}

    			if ((!current || dirty & /*item*/ 4096) && raw_value !== (raw_value = /*item*/ ctx[12].content + "")) html_tag.p(raw_value);

    			if (/*item*/ ctx[12].beReplied && /*item*/ ctx[12].beReplied.length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$2(ctx);
    					if_block3.c();
    					if_block3.m(div7, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			transition_in(divider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			transition_out(divider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    			if (if_block3) if_block3.d();
    			destroy_component(divider);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(66:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={hotComments}      let:item      let:index      {hasMore}      on:load={() => {        if (hasMore) {          offset = hotComments.length;          getHotCommentFun(offset);        }      }}    >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let navbar;
    	let t;
    	let div;
    	let pagination;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: `${/*totalCount*/ ctx[2] || 0}`
    			},
    			$$inline: true
    		});

    	pagination = new Pagination({
    			props: {
    				bottomHeight: 70,
    				paginationHeight: /*paginationHeight*/ ctx[4],
    				items: /*hotComments*/ ctx[0],
    				hasMore: /*hasMore*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot$3,
    						({ item, index }) => ({ 12: item, 13: index }),
    						({ item, index }) => (item ? 4096 : 0) | (index ? 8192 : 0)
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pagination.$on("load", /*load_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div = element("div");
    			create_component(pagination.$$.fragment);
    			attr_dev(div, "class", "comment-page svelte-hhobj8");
    			add_location(div, file$8, 64, 0, 2024);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(pagination, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*totalCount*/ 4) navbar_changes.title = `${/*totalCount*/ ctx[2] || 0}`;
    			navbar.$set(navbar_changes);
    			const pagination_changes = {};
    			if (dirty & /*paginationHeight*/ 16) pagination_changes.paginationHeight = /*paginationHeight*/ ctx[4];
    			if (dirty & /*hotComments*/ 1) pagination_changes.items = /*hotComments*/ ctx[0];
    			if (dirty & /*hasMore*/ 2) pagination_changes.hasMore = /*hasMore*/ ctx[1];

    			if (dirty & /*$$scope, item*/ 20480) {
    				pagination_changes.$$scope = { dirty, ctx };
    			}

    			pagination.$set(pagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(pagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(pagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(pagination);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let totalCount;
    	let hotComments;
    	let currentSongId;
    	let hasMore;
    	let offset;
    	let paginationHeight;
    	let $currentSongStore;
    	let $isLoginStore;
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(10, $currentSongStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(11, $isLoginStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MusicComment', slots, []);

    	onMount(() => {
    		$$invalidate(4, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    		getHotCommentFun(0);
    	});

    	afterUpdate(() => {
    		if (currentSongId !== $currentSongStore.id) {
    			$$invalidate(0, hotComments = []);
    			$$invalidate(3, offset = 0);
    			$$invalidate(1, hasMore = true);
    			getHotCommentFun(offset);
    		}
    	});

    	async function getHotCommentFun(offset) {
    		currentSongId = $currentSongStore.id;
    		const res = await getHotComment($currentSongStore.id, offset);

    		if (res.code === 200) {
    			$$invalidate(2, totalCount = res.total);
    			$$invalidate(0, hotComments = hotComments.concat(res.hotComments));
    			$$invalidate(1, hasMore = res.hasMore);

    			// 
    			$$invalidate(0, hotComments = hotComments.filter(item => item.user.nickname !== ''));

    			for (let r = 0; r < hotComments.length; r++) {
    				// emoji 
    				$$invalidate(0, hotComments[r].content = emojiToImg(hotComments[r].content), hotComments);
    			}
    		}
    	}

    	async function commentClickFun(commentId, liked) {
    		if ($isLoginStore) {
    			const res = await likeComment($currentSongStore.id, commentId, 0, liked ? 0 : 1);

    			if (res.code === 200) {
    				for (let y = 0; y < hotComments.length; y++) {
    					if (hotComments[y].commentId === commentId) {
    						$$invalidate(0, hotComments[y].liked = !liked, hotComments);
    					}
    				}
    			}
    		} else {
    			Toast$1('');
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MusicComment> was created with unknown prop '${key}'`);
    	});

    	const click_handler = item => commentClickFun(item.commentId, item.liked);

    	const load_handler = () => {
    		if (hasMore) {
    			$$invalidate(3, offset = hotComments.length);
    			getHotCommentFun(offset);
    		}
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		ThumbUpLine,
    		ThumbUpFill,
    		NavBar,
    		Divider,
    		Pagination,
    		getHotComment,
    		likeComment,
    		currentSongStore,
    		isLoginStore,
    		formatTime,
    		Toast: Toast$1,
    		tranNumber,
    		emojiToImg,
    		getHotCommentFun,
    		commentClickFun,
    		hotComments,
    		hasMore,
    		totalCount,
    		currentSongId,
    		offset,
    		paginationHeight,
    		$currentSongStore,
    		$isLoginStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('hotComments' in $$props) $$invalidate(0, hotComments = $$props.hotComments);
    		if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
    		if ('totalCount' in $$props) $$invalidate(2, totalCount = $$props.totalCount);
    		if ('currentSongId' in $$props) currentSongId = $$props.currentSongId;
    		if ('offset' in $$props) $$invalidate(3, offset = $$props.offset);
    		if ('paginationHeight' in $$props) $$invalidate(4, paginationHeight = $$props.paginationHeight);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(2, totalCount = 0);
    	$$invalidate(0, hotComments = []);
    	currentSongId = 0; // ID
    	$$invalidate(1, hasMore = true);
    	$$invalidate(3, offset = 0);
    	$$invalidate(4, paginationHeight = 0);

    	return [
    		hotComments,
    		hasMore,
    		totalCount,
    		offset,
    		paginationHeight,
    		getHotCommentFun,
    		commentClickFun,
    		click_handler,
    		load_handler
    	];
    }

    class MusicComment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MusicComment",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\pages\AllCollectSongers.svelte generated by Svelte v3.46.4 */
    const file$7 = "src\\pages\\AllCollectSongers.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (33:2) {#if collectSongers.length > 0}
    function create_if_block$1(ctx) {
    	let div;
    	let current;
    	let each_value = /*collectSongers*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "songer-box svelte-svzm6k");
    			add_location(div, file$7, 33, 4, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*collectSongers*/ 1) {
    				each_value = /*collectSongers*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(33:2) {#if collectSongers.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (35:6) {#each collectSongers as songer}
    function create_each_block$2(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: {
    				songer: /*songer*/ ctx[3],
    				coverSize: 200
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty & /*collectSongers*/ 1) songer_changes.songer = /*songer*/ ctx[3];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(35:6) {#each collectSongers as songer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let navbar;
    	let t;
    	let div;
    	let current;

    	navbar = new NavBar({
    			props: { title: "" },
    			$$inline: true
    		});

    	let if_block = /*collectSongers*/ ctx[0].length > 0 && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "page svelte-svzm6k");
    			add_location(div, file$7, 31, 0, 708);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*collectSongers*/ ctx[0].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*collectSongers*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let collectSongers;
    	let $defaultResumableStore;
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(1, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AllCollectSongers', slots, []);

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			likedArtistsFun();
    		}
    	});

    	onMount(() => {
    		likedArtistsFun();
    	});

    	//
    	async function likedArtistsFun() {
    		const res = await likedArtists({ limit: 2000 });

    		if (res.code === 200) {
    			$$invalidate(0, collectSongers = res.data);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AllCollectSongers> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onResume,
    		Songer: Singer,
    		NavBar,
    		defaultResumableStore,
    		likedArtists,
    		likedArtistsFun,
    		collectSongers,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('collectSongers' in $$props) $$invalidate(0, collectSongers = $$props.collectSongers);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(0, collectSongers = []);
    	return [collectSongers];
    }

    class AllCollectSongers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AllCollectSongers",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\pages\SongerDesc.svelte generated by Svelte v3.46.4 */
    const file$6 = "src\\pages\\SongerDesc.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (38:2) {#each introduction as i}
    function create_each_block$1(ctx) {
    	let div0;
    	let t0_value = /*i*/ ctx[6].ti + "";
    	let t0;
    	let t1;
    	let div1;
    	let raw_value = /*i*/ ctx[6].txt + "";

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "title svelte-18yar7i");
    			add_location(div0, file$6, 38, 4, 911);
    			attr_dev(div1, "class", "text svelte-18yar7i");
    			add_location(div1, file$6, 39, 4, 948);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			div1.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*introduction*/ 1 && t0_value !== (t0_value = /*i*/ ctx[6].ti + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*introduction*/ 1 && raw_value !== (raw_value = /*i*/ ctx[6].txt + "")) div1.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(38:2) {#each introduction as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let navbar;
    	let t0;
    	let div2;
    	let div0;
    	let t2;
    	let div1;
    	let t3;
    	let t4;
    	let current;

    	navbar = new NavBar({
    			props: { title: "", dark: true },
    			$$inline: true
    		});

    	let each_value = /*introduction*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "";
    			t2 = space();
    			div1 = element("div");
    			t3 = text(/*briefDesc*/ ctx[1]);
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "title svelte-18yar7i");
    			add_location(div0, file$6, 35, 2, 810);
    			attr_dev(div1, "class", "text svelte-18yar7i");
    			add_location(div1, file$6, 36, 2, 841);
    			attr_dev(div2, "class", "page svelte-18yar7i");
    			add_location(div2, file$6, 34, 0, 788);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, t3);
    			append_dev(div2, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*briefDesc*/ 2) set_data_dev(t3, /*briefDesc*/ ctx[1]);

    			if (dirty & /*introduction*/ 1) {
    				each_value = /*introduction*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let briefDesc;
    	let introduction;
    	let topicData;
    	let $search;
    	let $defaultResumableStore;
    	validate_store(search$1, 'search');
    	component_subscribe($$self, search$1, $$value => $$invalidate(3, $search = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(4, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongerDesc', slots, []);

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			getSongerDescFun();
    		}
    	});

    	onMount(() => {
    		getSongerDescFun();
    	});

    	async function getSongerDescFun() {
    		const res = await getSongerDesc($search.substr(1));

    		if (res.code === 200) {
    			$$invalidate(1, briefDesc = res.briefDesc);
    			$$invalidate(0, introduction = res.introduction);
    			topicData = res.topicData;
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongerDesc> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		search: search$1,
    		onResume,
    		NavBar,
    		defaultResumableStore,
    		getSongerDesc,
    		getSongerDescFun,
    		topicData,
    		introduction,
    		briefDesc,
    		$search,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('topicData' in $$props) topicData = $$props.topicData;
    		if ('introduction' in $$props) $$invalidate(0, introduction = $$props.introduction);
    		if ('briefDesc' in $$props) $$invalidate(1, briefDesc = $$props.briefDesc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(1, briefDesc = "");
    	$$invalidate(0, introduction = []);
    	topicData = [];
    	return [introduction, briefDesc];
    }

    class SongerDesc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongerDesc",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\pages\MoreSonger.svelte generated by Svelte v3.46.4 */
    const file$5 = "src\\pages\\MoreSonger.svelte";

    // (44:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={hotSongers}      let:item      let:index      {hasMore}      grid={3}      on:load={() => {        if (hasMore) {          offset = hotSongers.length;          topArtistsFun(offset);        }      }}    >
    function create_default_slot$2(ctx) {
    	let songer;
    	let current;

    	songer = new Singer({
    			props: { songer: /*item*/ ctx[8], coverSize: 200 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songer_changes = {};
    			if (dirty & /*item*/ 256) songer_changes.songer = /*item*/ ctx[8];
    			songer.$set(songer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(44:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={hotSongers}      let:item      let:index      {hasMore}      grid={3}      on:load={() => {        if (hasMore) {          offset = hotSongers.length;          topArtistsFun(offset);        }      }}    >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let navbar;
    	let t;
    	let div;
    	let pagination;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: ` ${/*hotSongers*/ ctx[1].length} `
    			},
    			$$inline: true
    		});

    	pagination = new Pagination({
    			props: {
    				bottomHeight: 70,
    				paginationHeight: /*paginationHeight*/ ctx[2],
    				items: /*hotSongers*/ ctx[1],
    				hasMore: /*hasMore*/ ctx[0],
    				grid: 3,
    				$$slots: {
    					default: [
    						create_default_slot$2,
    						({ item, index }) => ({ 8: item, 9: index }),
    						({ item, index }) => (item ? 256 : 0) | (index ? 512 : 0)
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pagination.$on("load", /*load_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div = element("div");
    			create_component(pagination.$$.fragment);
    			attr_dev(div, "class", "comment-page svelte-1fc8ytt");
    			add_location(div, file$5, 42, 0, 1134);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(pagination, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*hotSongers*/ 2) navbar_changes.title = ` ${/*hotSongers*/ ctx[1].length} `;
    			navbar.$set(navbar_changes);
    			const pagination_changes = {};
    			if (dirty & /*paginationHeight*/ 4) pagination_changes.paginationHeight = /*paginationHeight*/ ctx[2];
    			if (dirty & /*hotSongers*/ 2) pagination_changes.items = /*hotSongers*/ ctx[1];
    			if (dirty & /*hasMore*/ 1) pagination_changes.hasMore = /*hasMore*/ ctx[0];

    			if (dirty & /*$$scope, item*/ 1280) {
    				pagination_changes.$$scope = { dirty, ctx };
    			}

    			pagination.$set(pagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(pagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(pagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(pagination);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let hotSongers;
    	let hasMore;
    	let offset;
    	let paginationHeight;
    	let $defaultResumableStore;
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(6, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoreSonger', slots, []);
    	let limit = 20;

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			$$invalidate(1, hotSongers = []);
    			$$invalidate(0, hasMore = true);
    			$$invalidate(3, offset = 0);
    			$$invalidate(2, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    			topArtistsFun();
    		}
    	});

    	onMount(() => {
    		$$invalidate(2, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    		topArtistsFun(0);
    	});

    	//
    	async function topArtistsFun(offset) {
    		const res = await topArtists(limit, offset);

    		if (res.code === 200) {
    			$$invalidate(1, hotSongers = hotSongers.concat(res.artists));
    			$$invalidate(0, hasMore = res.more);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreSonger> was created with unknown prop '${key}'`);
    	});

    	const load_handler = () => {
    		if (hasMore) {
    			$$invalidate(3, offset = hotSongers.length);
    			topArtistsFun(offset);
    		}
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onResume,
    		NavBar,
    		Pagination,
    		Songer: Singer,
    		defaultResumableStore,
    		topArtists,
    		limit,
    		topArtistsFun,
    		hasMore,
    		hotSongers,
    		paginationHeight,
    		offset,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('hasMore' in $$props) $$invalidate(0, hasMore = $$props.hasMore);
    		if ('hotSongers' in $$props) $$invalidate(1, hotSongers = $$props.hotSongers);
    		if ('paginationHeight' in $$props) $$invalidate(2, paginationHeight = $$props.paginationHeight);
    		if ('offset' in $$props) $$invalidate(3, offset = $$props.offset);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(1, hotSongers = []);
    	$$invalidate(0, hasMore = true);
    	$$invalidate(3, offset = 0);
    	$$invalidate(2, paginationHeight = 0);
    	return [hasMore, hotSongers, paginationHeight, offset, topArtistsFun, load_handler];
    }

    class MoreSonger extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoreSonger",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\pages\MoreList.svelte generated by Svelte v3.46.4 */
    const file$4 = "src\\pages\\MoreList.svelte";

    // (68:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={playList}      let:item      let:index      {hasMore}      grid={2}      on:load={() => {        if (hasMore) {          if (searchObj.type === 'high') {            before = playList.slice(-1)[0].updateTime;            highQualityPlaylistFun(searchObj.cat);          } else {            offset = playList.length;            topPlaylistFun(searchObj.cat);          }        }      }}    >
    function create_default_slot$1(ctx) {
    	let miniplaylistcover;
    	let current;

    	miniplaylistcover = new MiniPlayListCover({
    			props: {
    				name: /*item*/ ctx[13].name,
    				coverImgUrl: /*item*/ ctx[13].coverImgUrl,
    				id: /*item*/ ctx[13].id,
    				width: 150,
    				playCount: /*item*/ ctx[13].playCount,
    				trackCount: /*item*/ ctx[13].trackCount
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(miniplaylistcover.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(miniplaylistcover, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const miniplaylistcover_changes = {};
    			if (dirty & /*item*/ 8192) miniplaylistcover_changes.name = /*item*/ ctx[13].name;
    			if (dirty & /*item*/ 8192) miniplaylistcover_changes.coverImgUrl = /*item*/ ctx[13].coverImgUrl;
    			if (dirty & /*item*/ 8192) miniplaylistcover_changes.id = /*item*/ ctx[13].id;
    			if (dirty & /*item*/ 8192) miniplaylistcover_changes.playCount = /*item*/ ctx[13].playCount;
    			if (dirty & /*item*/ 8192) miniplaylistcover_changes.trackCount = /*item*/ ctx[13].trackCount;
    			miniplaylistcover.$set(miniplaylistcover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(miniplaylistcover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(miniplaylistcover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(miniplaylistcover, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(68:2) <Pagination      bottomHeight={70}      {paginationHeight}      items={playList}      let:item      let:index      {hasMore}      grid={2}      on:load={() => {        if (hasMore) {          if (searchObj.type === 'high') {            before = playList.slice(-1)[0].updateTime;            highQualityPlaylistFun(searchObj.cat);          } else {            offset = playList.length;            topPlaylistFun(searchObj.cat);          }        }      }}    >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let navbar;
    	let t;
    	let div;
    	let pagination;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: /*searchObj*/ ctx[4].cat === ''
    				? ''
    				: `${/*searchObj*/ ctx[4].cat} - ${/*searchObj*/ ctx[4].type === 'top' ? '' : ''}`
    			},
    			$$inline: true
    		});

    	pagination = new Pagination({
    			props: {
    				bottomHeight: 70,
    				paginationHeight: /*paginationHeight*/ ctx[5],
    				items: /*playList*/ ctx[1],
    				hasMore: /*hasMore*/ ctx[0],
    				grid: 2,
    				$$slots: {
    					default: [
    						create_default_slot$1,
    						({ item, index }) => ({ 13: item, 14: index }),
    						({ item, index }) => (item ? 8192 : 0) | (index ? 16384 : 0)
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pagination.$on("load", /*load_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div = element("div");
    			create_component(pagination.$$.fragment);
    			attr_dev(div, "class", "comment-page svelte-1fc8ytt");
    			add_location(div, file$4, 66, 0, 1855);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(pagination, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*searchObj*/ 16) navbar_changes.title = /*searchObj*/ ctx[4].cat === ''
    			? ''
    			: `${/*searchObj*/ ctx[4].cat} - ${/*searchObj*/ ctx[4].type === 'top' ? '' : ''}`;

    			navbar.$set(navbar_changes);
    			const pagination_changes = {};
    			if (dirty & /*paginationHeight*/ 32) pagination_changes.paginationHeight = /*paginationHeight*/ ctx[5];
    			if (dirty & /*playList*/ 2) pagination_changes.items = /*playList*/ ctx[1];
    			if (dirty & /*hasMore*/ 1) pagination_changes.hasMore = /*hasMore*/ ctx[0];

    			if (dirty & /*$$scope, item*/ 40960) {
    				pagination_changes.$$scope = { dirty, ctx };
    			}

    			pagination.$set(pagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(pagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(pagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(pagination);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let playList;
    	let hasMore;
    	let offset;
    	let paginationHeight;
    	let searchObj;
    	let before;
    	let $search;
    	let $defaultResumableStore;
    	validate_store(search$1, 'search');
    	component_subscribe($$self, search$1, $$value => $$invalidate(9, $search = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(10, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoreList', slots, []);
    	let limit = 20;

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			$$invalidate(1, playList = []);
    			$$invalidate(0, hasMore = true);
    			$$invalidate(3, offset = 0);
    			$$invalidate(5, paginationHeight = 0);
    			$$invalidate(2, before = 0);
    			$$invalidate(4, searchObj = {});
    			allMount();
    		}
    	});

    	onMount(() => {
    		allMount();
    	});

    	function allMount() {
    		$$invalidate(5, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    		$$invalidate(4, searchObj = getRequest($search));

    		if (searchObj.type === 'high') {
    			highQualityPlaylistFun(searchObj.cat);
    		} else {
    			topPlaylistFun(searchObj.cat);
    		}
    	}

    	//
    	async function topPlaylistFun(cat) {
    		const res = await topPlaylist({
    			limit,
    			cat: cat === '' ? '' : cat,
    			offset
    		});

    		if (res.code === 200) {
    			$$invalidate(1, playList = playList.concat(res.playlists));
    			$$invalidate(0, hasMore = res.more);
    		}
    	}

    	//
    	async function highQualityPlaylistFun(cat) {
    		const res = await highQualityPlaylist({
    			limit,
    			cat: cat === '' ? '' : cat,
    			before
    		});

    		if (res.code === 200) {
    			$$invalidate(1, playList = playList.concat(res.playlists));
    			$$invalidate(0, hasMore = res.more);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreList> was created with unknown prop '${key}'`);
    	});

    	const load_handler = () => {
    		if (hasMore) {
    			if (searchObj.type === 'high') {
    				$$invalidate(2, before = playList.slice(-1)[0].updateTime);
    				highQualityPlaylistFun(searchObj.cat);
    			} else {
    				$$invalidate(3, offset = playList.length);
    				topPlaylistFun(searchObj.cat);
    			}
    		}
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onResume,
    		search: search$1,
    		Lazy: Src,
    		NavBar,
    		Pagination,
    		MiniPlayListCover,
    		defaultResumableStore,
    		topPlaylist,
    		highQualityPlaylist,
    		getRequest,
    		limit,
    		allMount,
    		topPlaylistFun,
    		highQualityPlaylistFun,
    		hasMore,
    		playList,
    		before,
    		offset,
    		searchObj,
    		paginationHeight,
    		$search,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('hasMore' in $$props) $$invalidate(0, hasMore = $$props.hasMore);
    		if ('playList' in $$props) $$invalidate(1, playList = $$props.playList);
    		if ('before' in $$props) $$invalidate(2, before = $$props.before);
    		if ('offset' in $$props) $$invalidate(3, offset = $$props.offset);
    		if ('searchObj' in $$props) $$invalidate(4, searchObj = $$props.searchObj);
    		if ('paginationHeight' in $$props) $$invalidate(5, paginationHeight = $$props.paginationHeight);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(1, playList = []);
    	$$invalidate(0, hasMore = true);
    	$$invalidate(3, offset = 0);
    	$$invalidate(5, paginationHeight = 0);
    	$$invalidate(4, searchObj = {});
    	$$invalidate(2, before = 0);

    	return [
    		hasMore,
    		playList,
    		before,
    		offset,
    		searchObj,
    		paginationHeight,
    		topPlaylistFun,
    		highQualityPlaylistFun,
    		load_handler
    	];
    }

    class MoreList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoreList",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\pages\MoreSong.svelte generated by Svelte v3.46.4 */
    const file$3 = "src\\pages\\MoreSong.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (121:4) {#each typeList as t}
    function create_each_block(ctx) {
    	let div;
    	let t0_value = /*t*/ ctx[22].text + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[11](/*t*/ ctx[22]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "type-item svelte-18svwxv");
    			toggle_class(div, "active", /*active*/ ctx[5] === /*t*/ ctx[22].index);
    			add_location(div, file$3, 121, 6, 4134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*active, typeList*/ 288) {
    				toggle_class(div, "active", /*active*/ ctx[5] === /*t*/ ctx[22].index);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(121:4) {#each typeList as t}",
    		ctx
    	});

    	return block;
    }

    // (140:4) <Pagination        bottomHeight={70}        {paginationHeight}        items={songList}        let:item        let:index        {hasMore}        on:load={() => {          if (hasMore) {            offset = songList.length;            getAllSongsFun(offset, order);          }        }}      >
    function create_default_slot(ctx) {
    	let song;
    	let current;

    	song = new Song({
    			props: {
    				song: /*item*/ ctx[20],
    				index: /*index*/ ctx[21],
    				customCoverUrl: /*$coverImgUrlStore*/ ctx[7] + '?param=100y100'
    			},
    			$$inline: true
    		});

    	song.$on("songClick", /*getSongClick*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(song.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(song, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const song_changes = {};
    			if (dirty & /*item*/ 1048576) song_changes.song = /*item*/ ctx[20];
    			if (dirty & /*index*/ 2097152) song_changes.index = /*index*/ ctx[21];
    			if (dirty & /*$coverImgUrlStore*/ 128) song_changes.customCoverUrl = /*$coverImgUrlStore*/ ctx[7] + '?param=100y100';
    			song.$set(song_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(song.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(song.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(song, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(140:4) <Pagination        bottomHeight={70}        {paginationHeight}        items={songList}        let:item        let:index        {hasMore}        on:load={() => {          if (hasMore) {            offset = songList.length;            getAllSongsFun(offset, order);          }        }}      >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let navbar;
    	let t0;
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let div2;
    	let pagination;
    	let current;

    	navbar = new NavBar({
    			props: {
    				title: `${/*searchObj*/ ctx[2].name}`
    			},
    			$$inline: true
    		});

    	let each_value = /*typeList*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	pagination = new Pagination({
    			props: {
    				bottomHeight: 70,
    				paginationHeight: /*paginationHeight*/ ctx[4],
    				items: /*songList*/ ctx[0],
    				hasMore: /*hasMore*/ ctx[1],
    				$$slots: {
    					default: [
    						create_default_slot,
    						({ item, index }) => ({ 20: item, 21: index }),
    						({ item, index }) => (item ? 1048576 : 0) | (index ? 2097152 : 0)
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pagination.$on("load", /*load_handler*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div2 = element("div");
    			create_component(pagination.$$.fragment);
    			attr_dev(div0, "class", "type svelte-18svwxv");
    			add_location(div0, file$3, 119, 2, 4081);
    			attr_dev(div1, "class", "active-line svelte-18svwxv");
    			set_style(div1, "left", 20 + (localStorage.getItem('fullWidth') - 40) / 2 * /*active*/ ctx[5] + "px");
    			add_location(div1, file$3, 137, 2, 4489);
    			set_style(div2, "margin-top", "40px");
    			add_location(div2, file$3, 138, 2, 4600);
    			attr_dev(div3, "class", "comment-page svelte-18svwxv");
    			add_location(div3, file$3, 118, 0, 4051);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			mount_component(pagination, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*searchObj*/ 4) navbar_changes.title = `${/*searchObj*/ ctx[2].name}`;
    			navbar.$set(navbar_changes);

    			if (dirty & /*active, typeList, order, songList, hasMore, offset, getAllSongsFun*/ 875) {
    				each_value = /*typeList*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*active*/ 32) {
    				set_style(div1, "left", 20 + (localStorage.getItem('fullWidth') - 40) / 2 * /*active*/ ctx[5] + "px");
    			}

    			const pagination_changes = {};
    			if (dirty & /*paginationHeight*/ 16) pagination_changes.paginationHeight = /*paginationHeight*/ ctx[4];
    			if (dirty & /*songList*/ 1) pagination_changes.items = /*songList*/ ctx[0];
    			if (dirty & /*hasMore*/ 2) pagination_changes.hasMore = /*hasMore*/ ctx[1];

    			if (dirty & /*$$scope, item, index, $coverImgUrlStore*/ 36700288) {
    				pagination_changes.$$scope = { dirty, ctx };
    			}

    			pagination.$set(pagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(pagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(pagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			destroy_component(pagination);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let songList;
    	let hasMore;
    	let offset;
    	let paginationHeight;
    	let searchObj;
    	let active;
    	let order;
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $coverImgUrlStore;
    	let $search;
    	let $defaultResumableStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(13, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(14, $currentPlayListStore = $$value));
    	validate_store(coverImgUrlStore, 'coverImgUrlStore');
    	component_subscribe($$self, coverImgUrlStore, $$value => $$invalidate(7, $coverImgUrlStore = $$value));
    	validate_store(search$1, 'search');
    	component_subscribe($$self, search$1, $$value => $$invalidate(15, $search = $$value));
    	validate_store(defaultResumableStore, 'defaultResumableStore');
    	component_subscribe($$self, defaultResumableStore, $$value => $$invalidate(16, $defaultResumableStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoreSong', slots, []);
    	let limit = 20;
    	let typeList = [{ index: 0, type: 'hot', text: '' }, { index: 1, type: 'time', text: '' }];

    	onResume(() => {
    		if (!$defaultResumableStore) {
    			$$invalidate(0, songList = []);
    			$$invalidate(1, hasMore = true);
    			$$invalidate(6, offset = 0);
    			$$invalidate(5, active = 0);
    			$$invalidate(3, order = 'hot');
    			$$invalidate(2, searchObj = getRequest($search));
    			$$invalidate(4, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    			getAllSongsFun(0, order);
    		}
    	});

    	onMount(() => {
    		$$invalidate(2, searchObj = getRequest($search));
    		$$invalidate(4, paginationHeight = document.documentElement.clientHeight || document.body.clientHeight - 120);
    		getAllSongsFun(0, order);
    	});

    	//
    	async function getAllSongsFun(offset, order) {
    		const res = await getAllSongs(searchObj.id, order, limit, offset);

    		if (res.code === 200) {
    			$$invalidate(0, songList = songList.concat(res.songs));
    			$$invalidate(1, hasMore = res.more);
    		}
    	}

    	function playListFun(index) {
    		isFMPlayStore.set(false);
    		localStorage.setItem('isFMPlay', '0');
    		let newcurrentPlayList = $currentPlayListStore;
    		let newPlayListIds = [];

    		for (let r = 0; r < newcurrentPlayList.length; r++) {
    			newPlayListIds.push(newcurrentPlayList[r].id);
    		}

    		if (newPlayListIds.includes(songList[index].id)) {
    			currentSongIndexStore.set(newPlayListIds.indexOf(songList[index].id));
    			getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    		} else {
    			newcurrentPlayList.splice($currentSongIndexStore + 1, 0, songList[index]);
    			currentPlayListStore.set(newcurrentPlayList);
    			let ids = [];

    			for (let r = 0; r < newcurrentPlayList.length; r++) {
    				ids.push(newcurrentPlayList[r].id);
    			}

    			localStorage.setItem('localPlayList', JSON.stringify(ids));
    			currentSongIndexStore.set($currentSongIndexStore + 1);
    			getSongUrlFun($currentPlayListStore[$currentSongIndexStore]);
    		}
    	}

    	async function getSongUrlFun(song) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				song.al.picUrl = $coverImgUrlStore;
    				currentSongStore.set(song);
    				localStorage.setItem('currentSong', JSON.stringify(song));
    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';
    				if ($currentSongIndexStore !== $currentPlayListStore.length - 1) getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	function getSongClick(event) {
    		playListFun(event.detail.index);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreSong> was created with unknown prop '${key}'`);
    	});

    	const click_handler = t => {
    		$$invalidate(5, active = t.index);
    		$$invalidate(3, order = t.type);
    		$$invalidate(0, songList = []);
    		$$invalidate(1, hasMore = true);
    		$$invalidate(6, offset = 0);
    		getAllSongsFun(offset, order);
    	};

    	const load_handler = () => {
    		if (hasMore) {
    			$$invalidate(6, offset = songList.length);
    			getAllSongsFun(offset, order);
    		}
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onResume,
    		search: search$1,
    		NavBar,
    		Pagination,
    		Song,
    		defaultResumableStore,
    		coverImgUrlStore,
    		currentSongStore,
    		playStatusStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		isFMPlayStore,
    		currentSongQualityStore,
    		getAllSongs,
    		getSongUrl,
    		getRequest,
    		Toast: Toast$1,
    		limit,
    		typeList,
    		getAllSongsFun,
    		playListFun,
    		getSongUrlFun,
    		getSongClick,
    		songList,
    		hasMore,
    		searchObj,
    		order,
    		paginationHeight,
    		active,
    		offset,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$coverImgUrlStore,
    		$search,
    		$defaultResumableStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('typeList' in $$props) $$invalidate(8, typeList = $$props.typeList);
    		if ('songList' in $$props) $$invalidate(0, songList = $$props.songList);
    		if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
    		if ('searchObj' in $$props) $$invalidate(2, searchObj = $$props.searchObj);
    		if ('order' in $$props) $$invalidate(3, order = $$props.order);
    		if ('paginationHeight' in $$props) $$invalidate(4, paginationHeight = $$props.paginationHeight);
    		if ('active' in $$props) $$invalidate(5, active = $$props.active);
    		if ('offset' in $$props) $$invalidate(6, offset = $$props.offset);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(0, songList = []);
    	$$invalidate(1, hasMore = true);
    	$$invalidate(6, offset = 0);
    	$$invalidate(4, paginationHeight = 0);
    	$$invalidate(2, searchObj = {});
    	$$invalidate(5, active = 0);
    	$$invalidate(3, order = typeList[0].type);

    	return [
    		songList,
    		hasMore,
    		searchObj,
    		order,
    		paginationHeight,
    		active,
    		offset,
    		$coverImgUrlStore,
    		typeList,
    		getAllSongsFun,
    		getSongClick,
    		click_handler,
    		load_handler
    	];
    }

    class MoreSong extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoreSong",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    var md$1 = "<p align=\"center\">\n  <a href=\"https://simplecloudmusic.com\" target=\"blank\">\n    <img src=\"https://simplecloudmusic.com/assets/logo.png\" alt=\"Logo\" width=\"30%\">\n  </a>\n  <h2 align=\"center\" style=\"font-weight: 600\"></h2>\n  <p align=\"center\">\n    \n    <br />\n    <br />\n    <a href=\"https://simplecloudmusic.com\" target=\"blank\"><strong> </strong></a>&nbsp;&nbsp;|&nbsp;&nbsp;\n    <a href=\"https://github.com/dufu1991/simple-cloud-music\" target=\"blank\"><strong> GitHub</strong></a>\n    <br />\n    <br />\n  </p>\n</p>\n\n<h2 id=\"-\"> </h2>\n<ol>\n<li><p> PWA Svelte rollupsvelte-stack-routersvelte-lazy </p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n<li><p> FM</p>\n</li>\n<li><p></p>\n</li>\n<li><p> Android </p>\n</li>\n<li><p> PWA Chrome  Edge Safari </p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ol>\n<h2 id=\"-\"> </h2>\n<ol>\n<li><p> PWA </p>\n</li>\n<li><p>Android  Chrome  Edge  <a href=\"https://simplecloudmusic.com\"></a>  chromium  PWA  APP ------ Chrome  Edge ---- Microsoft  Google  Chrome  Edge<a href=\"https://simplecloudmusic.com/assets/microsoft-edge-92-0-902-59.apk\"> Edge apk</a><a href=\"https://simplecloudmusic.com/assets/google-chrome-92-0-4515-131.apk\"> Chrome apk</a></p>\n</li>\n<li><p>iOS  Safari  <a href=\"https://simplecloudmusic.com\"></a></p>\n</li>\n</ol>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/add.jpg\" alt=\"Logo\" width=\"100%\" style=\"max-width:500px\">\n<p>\n\n<h2 id=\"-\"> </h2>\n<p> Svelte API <a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\">Binaryify/NeteaseCloudMusicApi</a> </p>\n<p>UI  <a href=\"https://music.apple.com/cn/browse\">Apple Music</a>  <a href=\"https://github.com/qier222/YesPlayMusic\">YesPlayMusic</a></p>\n<p> APP </p>\n<h3 id=\"1-apple-music\">1. Apple Music</h3>\n<h4 id=\"\"></h4>\n<ul>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h4 id=\"\"></h4>\n<ul>\n<li><p>Mac </p>\n</li>\n<li><p> Siri </p>\n</li>\n<li><p> Apple Music </p>\n</li>\n<li><p> low </p>\n</li>\n</ul>\n<h3 id=\"2-\">2. </h3>\n<h4 id=\"-1\"></h4>\n<ul>\n<li><p> Spotify </p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h4 id=\"-1\"></h4>\n<ul>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n<li><p> UI  Apple Music </p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h3 id=\"3-qq-\">3. QQ </h3>\n<h4 id=\"-2\"></h4>\n<ul>\n<li> QQ </li>\n</ul>\n<h4 id=\"-2\"></h4>\n<ul>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h3 id=\"4-spotify\">4. Spotify</h3>\n<h4 id=\"-3\"></h4>\n<ul>\n<li><p>Apple </p>\n</li>\n<li><p> Spotify Connect </p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h4 id=\"-3\"></h4>\n<ul>\n<li><p></p>\n</li>\n<li><p></p>\n</li>\n</ul>\n<h2 id=\"-\"> </h2>\n<ol>\n<li><p> Android iOS  Safari </p>\n</li>\n<li><p> Safari  CSS  scroll-behavior: smooth scrollSmoothTo  Safari Android  smooth</p>\n</li>\n<li><p></p>\n</li>\n<li><p> API</p>\n</li>\n<li><p></p>\n</li>\n<li><p>PWA </p>\n</li>\n<li><p></p>\n</li>\n<li><p>iOS  Safari  PWA </p>\n</li>\n<li><p>iOS  Safari  PWA  Mac  Simulator </p>\n</li>\n<li><p>Android  API </p>\n</li>\n</ol>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/notice.jpg\" alt=\"notice\" width=\"40%\" style=\"max-width:500px\">\n<p>\n\n<h2 id=\"-\"> </h2>\n<p> API </p>\n<ol>\n<li><p> API <a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\">Binaryify/NeteaseCloudMusicApi</a></p>\n</li>\n<li><p><code>git clone https://github.com/dufu1991/simple-cloud-music.git</code></p>\n</li>\n<li><p> node  <code>node i</code> </p>\n</li>\n<li><p> <code>src/utils/request.js</code>  baseURL  API  <code>npm run dev</code>  public </p>\n</li>\n<li><p> <code>npm run build</code>  html  html  Web </p>\n</li>\n<li><p> <code>npm run deploy</code>  Web </p>\n</li>\n<li><p> PWA  Service Workers HTTPS </p>\n</li>\n</ol>\n<h2 id=\"-\"> </h2>\n<p></p>\n<p> <a href=\"https://opensource.org/licenses/MIT\">MIT license</a> </p>\n<h2 id=\"-\"> </h2>\n<p> API  <a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\">Binaryify/NeteaseCloudMusicApi</a> </p>\n<ul>\n<li><p><a href=\"https://music.apple.com/\">Apple Music</a></p>\n</li>\n<li><p><a href=\"https://www.spotify.com/\">Spotify</a></p>\n</li>\n<li><p><a href=\"https://music.163.com/\"></a></p>\n</li>\n<li><p><a href=\"https://github.com/qier222/YesPlayMusic\">YesPlayMusic</a></p>\n</li>\n</ul>\n<h2 id=\"-\"> </h2>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/screen1.jpg?v=1.0.0\" alt=\"screen1\" width=\"100%\" style=\"max-width:500px\">\n<p>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/screen2.jpg?v=1.0.0\" alt=\"screen2\" width=\"100%\" style=\"max-width:500px\">\n<p>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/screen3.jpg?v=1.0.0\" alt=\"screen3\" width=\"100%\" style=\"max-width:500px\">\n<p>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/screen4.jpg?v=1.0.0\" alt=\"Loscreen4go\" width=\"100%\" style=\"max-width:500px\">\n<p>\n\n<h2 id=\"-design\"> Design</h2>\n<p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/cover.jpg?v=1.0.0\" alt=\"cover\" width=\"100%\" style=\"max-width:500px\">\n<p>\n\n<h2 id=\"-\"> </h2>\n<ul>\n<li> UI </li>\n<li><p align=\"center\">\n<img src=\"https://simplecloudmusic.com/assets/lollipop.jpg?v=1.0.0\" alt=\"lollipop\" width=\"30%\" style=\"max-width:30%\">\n<p>\n\n</li>\n</ul>\n<h2 id=\"-\"> </h2>\n<p> Android  bug</p>\n<ul>\n<li> GitHub  <a href=\"https://github.com/dufu1991/simple-cloud-music/issues\">Issues</a> </li>\n<li> <a href=\"mailto:simplecloudmusic@163.com?subject=\">simplecloudmusic@163.com</a></li>\n</ul>\n";

    /* src\pages\About.svelte generated by Svelte v3.46.4 */
    const file$2 = "src\\pages\\About.svelte";

    function create_fragment$2(ctx) {
    	let navbar;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	navbar = new NavBar({ props: { title: "" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "id", "markdown");
    			add_location(div0, file$2, 7, 2, 154);
    			attr_dev(div1, "class", "about svelte-1l25dxc");
    			add_location(div1, file$2, 6, 0, 131);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = md$1;
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('About', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ md: md$1, NavBar });
    	return [];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    var md = "<h1 id=\"\"></h1>\n<h2 id=\"103\">1.0.3</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"102\">1.0.2</h2>\n<ol>\n<li></li>\n</ol>\n<h2 id=\"101\">1.0.1</h2>\n<ol>\n<li></li>\n<li></li>\n<li>PWA </li>\n</ol>\n<h2 id=\"100\">1.0.0</h2>\n<ol>\n<li></li>\n</ol>\n";

    /* src\pages\Version.svelte generated by Svelte v3.46.4 */
    const file$1 = "src\\pages\\Version.svelte";

    function create_fragment$1(ctx) {
    	let navbar;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	navbar = new NavBar({ props: { title: "" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "id", "markdown");
    			add_location(div0, file$1, 7, 2, 157);
    			attr_dev(div1, "class", "about svelte-1l25dxc");
    			add_location(div1, file$1, 6, 0, 134);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = md;
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Version', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Version> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ md, NavBar });
    	return [];
    }

    class Version extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Version",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    const routes = {
      '/playlistdetail': PlayListDetail,
      '/todayListDetail': TodayListDetail,
      '/loveListDetail': LoveListDetail,
      '/myAllPlayList': MyAllPlayList,
      '/login': Login,
      '/setting': Setting,
      '/search': Search,
      '/songerDetail': SongerDetail,
      '/brSelect': BrSelect,
      '/musicComment': MusicComment,
      '/allCollectSongers': AllCollectSongers,
      '/songerDesc': SongerDesc,
      '/moreSonger': MoreSonger,
      '/moreList': MoreList,
      '/moreSong': MoreSong,
      '/about': About,
      '/version': Version,
      '*': Home,
    };

    /* src\App.svelte generated by Svelte v3.46.4 */

    const file = "src\\App.svelte";

    // (386:0) {#if $playIsMinStore && audioDOMIsRander}
    function create_if_block_1(ctx) {
    	let miniplay;
    	let current;

    	miniplay = new MiniPlay({
    			props: {
    				currentTimeLong: /*currentTimeLong*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(miniplay.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(miniplay, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const miniplay_changes = {};
    			if (dirty & /*currentTimeLong*/ 16) miniplay_changes.currentTimeLong = /*currentTimeLong*/ ctx[4];
    			miniplay.$set(miniplay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(miniplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(miniplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(miniplay, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(386:0) {#if $playIsMinStore && audioDOMIsRander}",
    		ctx
    	});

    	return block;
    }

    // (391:0) {#if $isLoadingStore}
    function create_if_block(ctx) {
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(391:0) {#if $isLoadingStore}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let audio;
    	let audio_src_value;
    	let t0;
    	let stackrouter;
    	let t1;
    	let t2;
    	let play;
    	let t3;
    	let tabbar;
    	let t4;
    	let if_block1_anchor;
    	let current;

    	stackrouter = new StackRouter({
    			props: {
    				routes,
    				restoreScroll: /*$restoreScrollStore*/ ctx[5],
    				transitionFn: slide(300)
    			},
    			$$inline: true
    		});

    	stackrouter.$on("navigation-start", /*navigation_start_handler*/ ctx[9]);
    	let if_block0 = /*$playIsMinStore*/ ctx[6] && /*audioDOMIsRander*/ ctx[1] && create_if_block_1(ctx);

    	play = new Play({
    			props: {
    				endTime: /*endTime*/ ctx[2],
    				currentTime: /*currentTime*/ ctx[3],
    				currentTimeLong: /*currentTimeLong*/ ctx[4]
    			},
    			$$inline: true
    		});

    	tabbar = new TabBar({ $$inline: true });
    	let if_block1 = /*$isLoadingStore*/ ctx[7] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			audio = element("audio");
    			t0 = space();
    			create_component(stackrouter.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			create_component(play.$$.fragment);
    			t3 = space();
    			create_component(tabbar.$$.fragment);
    			t4 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (!src_url_equal(audio.src, audio_src_value = "")) attr_dev(audio, "src", audio_src_value);
    			attr_dev(audio, "id", "audioDom");
    			add_location(audio, file, 367, 0, 12759);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, audio, anchor);
    			/*audio_binding*/ ctx[8](audio);
    			insert_dev(target, t0, anchor);
    			mount_component(stackrouter, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(play, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(tabbar, target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const stackrouter_changes = {};
    			if (dirty & /*$restoreScrollStore*/ 32) stackrouter_changes.restoreScroll = /*$restoreScrollStore*/ ctx[5];
    			stackrouter.$set(stackrouter_changes);

    			if (/*$playIsMinStore*/ ctx[6] && /*audioDOMIsRander*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$playIsMinStore, audioDOMIsRander*/ 66) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const play_changes = {};
    			if (dirty & /*endTime*/ 4) play_changes.endTime = /*endTime*/ ctx[2];
    			if (dirty & /*currentTime*/ 8) play_changes.currentTime = /*currentTime*/ ctx[3];
    			if (dirty & /*currentTimeLong*/ 16) play_changes.currentTimeLong = /*currentTimeLong*/ ctx[4];
    			play.$set(play_changes);

    			if (/*$isLoadingStore*/ ctx[7]) {
    				if (if_block1) {
    					if (dirty & /*$isLoadingStore*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stackrouter.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(play.$$.fragment, local);
    			transition_in(tabbar.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stackrouter.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(play.$$.fragment, local);
    			transition_out(tabbar.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(audio);
    			/*audio_binding*/ ctx[8](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(stackrouter, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(play, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(tabbar, detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $currentSongIndexStore;
    	let $currentPlayListStore;
    	let $FMPlayStore;
    	let $isFMPlayStore;
    	let $currentSongStore;
    	let $mainCoverTypeStore;
    	let $playRepeatModelStore;
    	let $FMPlayNextStore;
    	let $userInfoStore;
    	let $isLoginStore;
    	let $playIsMaxStore;
    	let $restoreScrollStore;
    	let $playIsMinStore;
    	let $isLoadingStore;
    	validate_store(currentSongIndexStore, 'currentSongIndexStore');
    	component_subscribe($$self, currentSongIndexStore, $$value => $$invalidate(10, $currentSongIndexStore = $$value));
    	validate_store(currentPlayListStore, 'currentPlayListStore');
    	component_subscribe($$self, currentPlayListStore, $$value => $$invalidate(11, $currentPlayListStore = $$value));
    	validate_store(FMPlayStore, 'FMPlayStore');
    	component_subscribe($$self, FMPlayStore, $$value => $$invalidate(12, $FMPlayStore = $$value));
    	validate_store(isFMPlayStore, 'isFMPlayStore');
    	component_subscribe($$self, isFMPlayStore, $$value => $$invalidate(13, $isFMPlayStore = $$value));
    	validate_store(currentSongStore, 'currentSongStore');
    	component_subscribe($$self, currentSongStore, $$value => $$invalidate(14, $currentSongStore = $$value));
    	validate_store(mainCoverTypeStore, 'mainCoverTypeStore');
    	component_subscribe($$self, mainCoverTypeStore, $$value => $$invalidate(15, $mainCoverTypeStore = $$value));
    	validate_store(playRepeatModelStore, 'playRepeatModelStore');
    	component_subscribe($$self, playRepeatModelStore, $$value => $$invalidate(16, $playRepeatModelStore = $$value));
    	validate_store(FMPlayNextStore, 'FMPlayNextStore');
    	component_subscribe($$self, FMPlayNextStore, $$value => $$invalidate(17, $FMPlayNextStore = $$value));
    	validate_store(userInfoStore, 'userInfoStore');
    	component_subscribe($$self, userInfoStore, $$value => $$invalidate(18, $userInfoStore = $$value));
    	validate_store(isLoginStore, 'isLoginStore');
    	component_subscribe($$self, isLoginStore, $$value => $$invalidate(19, $isLoginStore = $$value));
    	validate_store(playIsMaxStore, 'playIsMaxStore');
    	component_subscribe($$self, playIsMaxStore, $$value => $$invalidate(20, $playIsMaxStore = $$value));
    	validate_store(restoreScrollStore, 'restoreScrollStore');
    	component_subscribe($$self, restoreScrollStore, $$value => $$invalidate(5, $restoreScrollStore = $$value));
    	validate_store(playIsMinStore, 'playIsMinStore');
    	component_subscribe($$self, playIsMinStore, $$value => $$invalidate(6, $playIsMinStore = $$value));
    	validate_store(isLoadingStore, 'isLoadingStore');
    	component_subscribe($$self, isLoadingStore, $$value => $$invalidate(7, $isLoadingStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let audioDOM;
    	let audioDOMIsRander = false;
    	let endTime = 0;
    	let currentTime = '0:00';
    	let currentTimeLong = 0;

    	window.addEventListener('hashchange', function (event) {
    		if (event.newURL.indexOf('#') < 0 || event.newURL.split('#')[1] === '' || event.newURL.split('#')[1] === '/') {
    			isHomePageStore.set(true);
    		} else {
    			isHomePageStore.set(false);
    		}

    		if (event.oldURL.indexOf('#') > 0 && event.oldURL.split('#')[1] === '/login') {
    			location.reload();
    		}
    	});

    	// history.pushState(null, null, location.href);
    	window.addEventListener('popstate', function (event) {
    		if ($playIsMaxStore) {
    			playIsMaxStore.set(false);
    			mainCoverTypeStore.set('cover');
    			maxPlayToTopStore.set(window.screen.height + 'px');
    		}
    	});

    	// pushHistory();
    	// window.addEventListener(
    	//   "popstate",
    	//   function (e) {
    	//     console.log(11, e);
    	//     // $(".onback").show();
    	//   },
    	//   false
    	// );
    	// function pushHistory() {
    	//   var state = {
    	//     title: "title",
    	//     url: "#",
    	//   };
    	//   window.history.pushState(state, "title", "#");
    	// }
    	onMount(() => {
    		if (localStorage.getItem('noAlertStart') != '1') {
    			// if (getOsInfo().os === 'iPhone' && (getUserAgentInfo().browser != 'safari' || !isStandalone)) {
    			//   Confirm(
    			//     ' iOS  PWA  iPhone  Safari ',
    			//     () => {},
    			//     '',
    			//     '',
    			//     () => {
    			//       localStorage.setItem('noAlertStart', '1');
    			//     }
    			//   );
    			// }
    			if (getOsInfo().os === 'iPhone' && getUserAgentInfo().browser == 'safari' && isStandalone) {
    				Confirm(
    					' iOS  PWA  iPhone  Safari ',
    					() => {
    						
    					},
    					'',
    					'',
    					() => {
    						localStorage.setItem('noAlertStart', '1');
    					}
    				);
    			}

    			if (getOsInfo().os === 'Android') {
    				if (!isStandalone && localStorage.getItem('isAlertPWA') != '1') {
    					Confirm(
    						' PWA ',
    						() => {
    							
    						},
    						'',
    						'',
    						() => {
    							localStorage.setItem('noAlertStart', '1');
    						}
    					);
    				} else {
    					if (getUserAgentInfo().browser != 'chrome' && getUserAgentInfo().browser != 'edge') {
    						Confirm(
    							' Android  Chrome  Edge ',
    							() => {
    								
    							},
    							'',
    							'',
    							() => {
    								localStorage.setItem('noAlertStart', '1');
    							}
    						);
    					} else {
    						if (getUserAgentInfo().browser === 'chrome' && getUserAgentInfo().version < 90) {
    							Confirm(
    								' Android  Chrome ',
    								() => {
    									
    								},
    								'',
    								'',
    								() => {
    									localStorage.setItem('noAlertStart', '1');
    								}
    							);
    						}

    						if (getUserAgentInfo().browser === 'edge' && getUserAgentInfo().version < 90) {
    							Confirm(
    								' Android  Edge ',
    								() => {
    									
    								},
    								'',
    								'',
    								() => {
    									localStorage.setItem('noAlertStart', '1');
    								}
    							);
    						}
    					}
    				}
    			}

    			if (getOsInfo().os != 'Android' && getOsInfo().os != 'iPhone') {
    				Confirm(
    					' iPhone  Android ',
    					() => {
    						
    					},
    					'',
    					'',
    					() => {
    						localStorage.setItem('noAlertStart', '1');
    					}
    				);
    			}
    		}

    		if ($isLoginStore) {
    			userPlaylistFun($userInfoStore);
    			likedArtistsFun();
    		}

    		// 
    		if (localStorage.getItem('localPlayList')) {
    			let localPlayList = JSON.parse(localStorage.getItem('localPlayList'));

    			if (localPlayList.length > 300) {
    				localPlayList = localPlayList.slice(0, 300);
    			}

    			getLocalPlayListFun(localPlayList.join(','));
    		}

    		if (location.href.indexOf('#') < 0 || location.href.split('#')[1] === '' || location.href.split('#')[1] === '/') {
    			isHomePageStore.set(true);
    		} else {
    			isHomePageStore.set(false);
    		}

    		window.audioDOM = audioDOM;

    		window.audioDOM.addEventListener('canplaythrough', function () {
    			// 
    			$$invalidate(1, audioDOMIsRander = true);

    			$$invalidate(2, endTime = '-' + timeToMinute(window.audioDOM.duration - window.audioDOM.currentTime));
    		});

    		window.audioDOM.addEventListener('timeupdate', function () {
    			currentTimeStore.set(window.audioDOM.currentTime);

    			// 
    			$$invalidate(3, currentTime = timeToMinute(window.audioDOM.currentTime));

    			$$invalidate(4, currentTimeLong = window.audioDOM.currentTime / window.audioDOM.duration * 100);
    			$$invalidate(2, endTime = '-' + timeToMinute(window.audioDOM.duration - window.audioDOM.currentTime));
    		});

    		window.audioDOM.addEventListener(
    			'ended',
    			function () {
    				if ($isFMPlayStore) {
    					//FM
    					mainCoverTypeStore.set('cover');

    					getSongUrlFun($FMPlayNextStore, 'fm');
    				} else {
    					if ($playRepeatModelStore != 'repeatOnce' && $currentSongIndexStore === $currentPlayListStore.length - 1) {
    						Toast$1('', 2000);
    					} else {
    						if ($playRepeatModelStore === 'shuffle') {
    							//
    							let index = Math.floor(Math.random() * ($currentPlayListStore.length - 1));

    							if ($mainCoverTypeStore === 'lyric') mainCoverTypeStore.set('cover');
    							getSongUrlFun($currentPlayListStore[index], 'shuffle', index);
    						} else if ($playRepeatModelStore === 'repeatOnce') {
    							//
    							if ($mainCoverTypeStore === 'lyric') mainCoverTypeStore.set('cover');

    							getSongUrlFun($currentPlayListStore[$currentSongIndexStore], 'once', $currentSongIndexStore);
    						} else {
    							if ($mainCoverTypeStore === 'lyric') mainCoverTypeStore.set('cover');
    							getSongUrlFun($currentPlayListStore[$currentSongIndexStore + 1]);
    						}
    					}
    				}
    			},
    			false
    		);

    		//URL(30)
    		if ((new Date().getTime() - Number(localStorage.getItem('pauseTimes'))) / 1000 / 60 > 30) {
    			window.audioDOM.src = `https://music.163.com/song/media/outer/url?id=${$currentSongStore.id}.mp3`;
    		} else {
    			window.audioDOM.src = $currentSongStore.url;
    		}

    		// window.audioDOM.src = "https://m8.music.126.net/20210907010112/541ee038536db12045e4a99d565becd8/ymusic/5614/195d/ad51/33fff191fffc2fd5da6c94d71e7777ef.mp3";
    		window.audioDOM.load(); //iOS canplaythrough
    	});

    	//
    	async function getLocalPlayListFun(songIds) {
    		const res = await getSongDetail(songIds);

    		if (res.code === 200) {
    			let songs = res.songs;

    			if (!songIds.split(',').includes($currentSongStore.id.toString())) {
    				songs.unshift($currentSongStore);
    				currentSongIndexStore.set(0);
    			} else {
    				currentSongIndexStore.set(songIds.split(',').indexOf($currentSongStore.id.toString()));
    			}

    			currentPlayListStore.set(songs);
    			let ids = [];

    			for (let r = 0; r < songs.length; r++) {
    				ids.push(songs[r].id);
    			}

    			localStorage.setItem('localPlayList', JSON.stringify(ids));
    		}
    	}

    	//
    	async function likedArtistsFun() {
    		const res = await likedArtists({ limit: 2000 });

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.data.length; i++) {
    				ids.push(res.data[i].id);
    			}

    			localStorage.setItem('useLoveSongerIds', JSON.stringify(ids));
    		} else {
    			alert('');
    		}
    	}

    	async function getSongUrlFun(song, type, index) {
    		const res = await getSongUrl(song.id); //url

    		if (res.code === 200) {
    			if (res.data[0].url) {
    				song.url = res.data[0].url.replace(/^http:/, 'https:');

    				if (res.data[0].fee === 1 && res.data[0].freeTrialInfo != null) {
    					currentSongQualityStore.set('');
    				} else if (res.data[0].type === 'flac') {
    					currentSongQualityStore.set('FLAC');
    				} else {
    					currentSongQualityStore.set(res.data[0].br);
    				}

    				window.audioDOM.src = song.url;
    				window.audioDOM.play();
    				playStatusStore.set(true);
    				if (document.getElementById('playgroundImg')) document.getElementById('playgroundImg').style.animationPlayState = 'running';

    				if ($isFMPlayStore) {
    					//FM
    					personalFMFun();

    					FMPlayStore.set(song);
    					currentSongStore.set(song);
    					currentPlayListStore.set([$FMPlayStore]);
    					currentSongIndexStore.set(0);
    					localStorage.setItem('currentSong', JSON.stringify(song));
    				} else {
    					if (type === 'shuffle') {
    						currentSongStore.set(song);
    						localStorage.setItem('currentSong', JSON.stringify(song));
    						currentSongIndexStore.set(index);
    					} else if (type === 'once') {
    						currentSongStore.set(song);
    						localStorage.setItem('currentSong', JSON.stringify(song));
    						currentSongIndexStore.set(index);

    						if ($currentSongIndexStore !== $currentPlayListStore.length - 1) {
    							getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    						}
    					} else {
    						currentSongStore.set(song);
    						localStorage.setItem('currentSong', JSON.stringify(song));
    						currentSongIndexStore.set($currentSongIndexStore + 1);

    						if ($currentSongIndexStore !== $currentPlayListStore.length - 1) {
    							getSongUrl($currentPlayListStore[$currentSongIndexStore + 1].id);
    						}
    					}
    				}
    			} else {
    				Toast$1(` ${song.name}......`, 2000);
    			}
    		}
    	}

    	//FM
    	async function personalFMFun() {
    		const res = await personalFM();

    		if (res.code === 200) {
    			res.data[0].al = res.data[0].album;
    			res.data[0].ar = res.data[0].artists;
    			res.data[0].alia = res.data[0].alias;
    			FMPlayNextStore.set(res.data[0]);
    		}
    	}

    	async function userPlaylistFun(login) {
    		//ID,
    		const res = await userPlaylist({
    			uid: login.account.id,
    			limit: 10000,
    			offset: 0
    		});

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.playlist.length; i++) {
    				ids.push(res.playlist[i].id);
    			}

    			localStorage.setItem('usePlayListIds', JSON.stringify(ids));
    			userLikedSongsIDsFun(login);
    		} else {
    			Alert('');
    		}
    	}

    	async function userLikedSongsIDsFun(login) {
    		//ID,
    		const res = await userLikedSongsIDs(login.account.id);

    		if (res.code === 200) {
    			let ids = [];

    			for (let i = 0; i < res.ids.length; i++) {
    				ids.push(res.ids[i]);
    			}

    			userLikeSongIdsStore.set(JSON.stringify(ids));
    			localStorage.setItem('useLoveSongIds', JSON.stringify(ids));
    		} else {
    			alert('');
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function audio_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			audioDOM = $$value;
    			$$invalidate(0, audioDOM);
    		});
    	}

    	const navigation_start_handler = e => {
    		// 0--2--,1--
    		if (e.detail.navigationType === 0) {
    			defaultResumableStore.set(false);
    		} else if (e.detail.navigationType === 2) {
    			defaultResumableStore.set(true);
    		} else {
    			defaultResumableStore.set(false);
    		}
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		StackRouter,
    		slide,
    		isStandalone,
    		Play,
    		MiniPlay,
    		Loading,
    		TabBar,
    		getSongUrl,
    		personalFM,
    		getSongDetail,
    		userPlaylist,
    		userLikedSongsIDs,
    		likedArtists,
    		routes,
    		isLoadingStore,
    		isHomePageStore,
    		restoreScrollStore,
    		defaultResumableStore,
    		isLoginStore,
    		currentSongStore,
    		currentPlayListStore,
    		currentSongIndexStore,
    		playIsMaxStore,
    		playIsMinStore,
    		playStatusStore,
    		maxPlayToTopStore,
    		isFMPlayStore,
    		FMPlayStore,
    		FMPlayNextStore,
    		currentTimeStore,
    		mainCoverTypeStore,
    		playRepeatModelStore,
    		currentSongQualityStore,
    		userInfoStore,
    		userLikeSongIdsStore,
    		timeToMinute,
    		Toast: Toast$1,
    		Alert,
    		Confirm,
    		getUserAgentInfo,
    		getOsInfo,
    		audioDOM,
    		audioDOMIsRander,
    		endTime,
    		currentTime,
    		currentTimeLong,
    		getLocalPlayListFun,
    		likedArtistsFun,
    		getSongUrlFun,
    		personalFMFun,
    		userPlaylistFun,
    		userLikedSongsIDsFun,
    		$currentSongIndexStore,
    		$currentPlayListStore,
    		$FMPlayStore,
    		$isFMPlayStore,
    		$currentSongStore,
    		$mainCoverTypeStore,
    		$playRepeatModelStore,
    		$FMPlayNextStore,
    		$userInfoStore,
    		$isLoginStore,
    		$playIsMaxStore,
    		$restoreScrollStore,
    		$playIsMinStore,
    		$isLoadingStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('audioDOM' in $$props) $$invalidate(0, audioDOM = $$props.audioDOM);
    		if ('audioDOMIsRander' in $$props) $$invalidate(1, audioDOMIsRander = $$props.audioDOMIsRander);
    		if ('endTime' in $$props) $$invalidate(2, endTime = $$props.endTime);
    		if ('currentTime' in $$props) $$invalidate(3, currentTime = $$props.currentTime);
    		if ('currentTimeLong' in $$props) $$invalidate(4, currentTimeLong = $$props.currentTimeLong);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		audioDOM,
    		audioDOMIsRander,
    		endTime,
    		currentTime,
    		currentTimeLong,
    		$restoreScrollStore,
    		$playIsMinStore,
    		$isLoadingStore,
    		audio_binding,
    		navigation_start_handler
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    localStorage.setItem('isShowToast', '0');
    if (localStorage.getItem('searchkeywords')) {
      if (localStorage.getItem('searchkeywords').length > 10000) localStorage.removeItem('searchkeywords');
    }

    //750font-size
    const oHtml = document.documentElement;
    const clientWidth = oHtml.clientWidth;
    const vM = 750;
    const vfontSize = 100;
    // 
    oHtml.style.fontSize = (vfontSize * clientWidth) / vM + 'px';
    localStorage.setItem('fullWidth', clientWidth);

    const app = new App({
      target: document.body,
      props: {
        name: 'world',
      },
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
